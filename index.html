<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Vault v7.7 - Registry Edition</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f1115',
                            card: '#111827',
                            border: '#374151',
                            text: '#ffffff',
                            subtext: '#9ca3af',
                            accent: '#6366f1'
                        },
                        light: {
                            bg: '#f3f4f6',
                            card: '#ffffff',
                            border: '#e5e7eb',
                            text: '#111827',
                            subtext: '#4b5563',
                            accent: '#4f46e5'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(99, 102, 241, 0.5); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(99, 102, 241, 0.8); }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; }
        input[type=range]:focus { outline: none; }
    </style>
</head>
<body class="bg-light-bg dark:bg-dark-bg text-light-text dark:text-dark-text transition-colors duration-300 overflow-y-scroll">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useCallback, useRef } = React;
        
        // --- CONFIG ---
        const supabaseClient = window.supabase.createClient(
              "https://ugllcdapuzihpkgcoaxj.supabase.co",
              "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVnbGxjZGFwdXppaHBrZ2NvYXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0OTA3NzksImV4cCI6MjA4NjA2Njc3OX0.73I1cW1fqRUha5_6spK7C8m-SXUHQQfyjmcbNNbdfCI"
        );

        // --- ADMIN CONFIG ---
        const ADMIN_IDS = [
            "74e5b3ea-113f-4d6c-be2a-b0b52b2e92c3"
        ];

        // --- ICONS ---
        const IconBase = ({ size = 20, className, children, ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        const Film = (p) => <IconBase {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></IconBase>;
        const Tv = (p) => <IconBase {...p}><rect width="20" height="15" x="2" y="7" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></IconBase>;
        const Play = (p) => <IconBase {...p}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Star = ({ fill, ...p }) => <IconBase {...p} fill={fill || "none"}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>;
        const Search = (p) => <IconBase {...p}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></IconBase>;
        const CheckCircle = (p) => <IconBase {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>;
        const ListPlus = (p) => <IconBase {...p}><path d="M11 12H3"/><path d="M16 6H3"/><path d="M16 18H3"/><path d="M18 9v6"/><path d="M21 12h-6"/></IconBase>;
        const X = (p) => <IconBase {...p}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Upload = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconBase>;
        const Download = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const Settings = (p) => <IconBase {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const RefreshCw = (p) => <IconBase {...p}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></IconBase>;
        const Edit = (p) => <IconBase {...p}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></IconBase>;
        const Repeat = (p) => <IconBase {...p}><path d="m17 2 4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="m7 22-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></IconBase>;
        const Zap = (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Globe = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>;
        const Trash = (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></IconBase>;
        const BarChart = (p) => <IconBase {...p}><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></IconBase>;
        const CheckSquare = (p) => <IconBase {...p}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>;
        const LogIn = (p) => <IconBase {...p}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></IconBase>;
        const User = (p) => <IconBase {...p}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconBase>;
        const Eye = (p) => <IconBase {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const EyeOff = (p) => <IconBase {...p}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></IconBase>;
        const Clock = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const TrendingUp = (p) => <IconBase {...p}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></IconBase>;
        const Grid = (p) => <IconBase {...p}><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></IconBase>;
        const Database = (p) => <IconBase {...p}><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></IconBase>;
        const Copy = (p) => <IconBase {...p}><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></IconBase>;
        const Inbox = (p) => <IconBase {...p}><polyline points="22 12 16 12 14 15 10 15 8 12 2 12"/><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/></IconBase>;

        // Custom Vault Logo
        const VaultLogoIcon = (p) => (
            <IconBase {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                <path d="M3 7h2v10H3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1z" fill="currentColor" fillOpacity="0.2" />
                <path d="M5 9h2" strokeLinecap="round" />
                <path d="M5 15h2" strokeLinecap="round" />
                <circle cx="15" cy="12" r="8" strokeWidth="2" />
                <circle cx="15" cy="12" r="6.2" strokeDasharray="0.5 2.5" strokeLinecap="round" strokeWidth="1.5" className="opacity-60" />
                <circle cx="15" cy="12" r="3" strokeWidth="1.5" />
                <path d="M15 9V6" strokeLinecap="round" />
                <path d="M15 15v3" strokeLinecap="round" />
                <path d="M12.4 10.5L9.8 9" strokeLinecap="round" />
                <path d="M17.6 10.5L20.2 9" strokeLinecap="round" />
                <path d="M12.4 13.5L9.8 15" strokeLinecap="round" />
                <path d="M17.6 13.5L20.2 15" strokeLinecap="round" />
                <ellipse cx="15" cy="12" rx="1.2" ry="1.8" fill="currentColor" />
                <path d="M15 11v2" stroke="white" strokeWidth="0.5" className="dark:stroke-gray-900" />
            </IconBase>
        );

        // --- CONSTANTS ---
        const DEFAULT_KEYS = { omdb: '5591108c', tmdb: '68b27c1f85725736f0aec18b903197b0', rapid: '9782bOaf7fmsh8b54c22e5cOaf5cp13e6e8jsn8e2e765657a5' };
        const RAPID_HOST_MDL = "mydramalist-api.p.rapidapi.com"; 

        const SMART_LISTS = [
            { id: 'top_rated', label: 'Top Rated', icon: Star, filter: item => item.userMeta?.ratings?.overall >= 9 },
            { id: 'rewatch', label: 'Rewatch Worthy', icon: Repeat, filter: item => item.userMeta?.rewatchCount > 0 },
            { id: 'foreign', label: 'Foreign', icon: Globe, filter: item => item.Language && !item.Language.includes('English') },
            { id: 'progress', label: 'In Progress', icon: Play, filter: item => item.userMeta?.series?.lastEpisode?.season > 0 },
        ];

        // --- SQL FOR USER ---
        const DB_SCHEMA_SQL = `
-- 1. MDL Registry (Public Global Table)
create table if not exists mdl_registry (
  mdl_id text primary key,
  title text,
  alt_titles text[],
  year int,
  country text,
  type text,
  episodes int,
  rating float,
  votes int,
  genres text[],
  synopsis text,
  poster_url text,
  raw jsonb,
  created_at timestamp default now(),
  updated_at timestamp default now()
);
alter table mdl_registry enable row level security;
-- Allow everyone to read and insert (since it's crowd-sourced)
create policy "Public read registry" on mdl_registry for select using (true);
create policy "Public insert registry" on mdl_registry for insert with check (true);
create policy "Public update registry" on mdl_registry for update using (true);

-- 2. MDL <-> IMDb Map (Public Mapping)
create table if not exists mdl_imdb_map (
  mdl_id text,
  imdb_id text,
  confidence float default 1.0,
  source text,
  created_at timestamp default now(),
  primary key (mdl_id, imdb_id)
);
alter table mdl_imdb_map enable row level security;
create policy "Public read map" on mdl_imdb_map for select using (true);
create policy "Public insert map" on mdl_imdb_map for insert with check (true);

-- 3. Suggestions System (NEW)
create table if not exists content_suggestions (
  id uuid default gen_random_uuid() primary key,
  imdb_id text,
  title text,
  year int,
  type text,
  suggested_by uuid,
  status text default 'pending', -- pending, approved, rejected
  created_at timestamp default now()
);
alter table content_suggestions enable row level security;
create policy "Public read suggestions" on content_suggestions for select using (true);
create policy "Public insert suggestions" on content_suggestions for insert with check (true);
create policy "Public update suggestions" on content_suggestions for update using (true);
`;

        // --- GLOBAL CACHE SYSTEM (30-DAY TTL) ---
        const CACHE_TTL_30_DAYS = 30 * 24 * 60 * 60 * 1000;
        
        const cacheGet = (key) => {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return null;
                const { data, ts } = JSON.parse(raw);
                if (Date.now() - ts > CACHE_TTL_30_DAYS) {
                    localStorage.removeItem(key);
                    return null;
                }
                return data;
            } catch (e) { return null; }
        };

        const cacheSet = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify({ data, ts: Date.now() }));
            } catch (e) { console.warn("Cache quota exceeded"); }
        };

        // --- HELPERS (Outside App) ---
        const normalize = (q) => q.toLowerCase().trim().replace(/[^a-z0-9]/g, '');

        // 3ï¸âƒ£ Ratings Helper
        const normalizeRatings = (item) => {
            const ratings = {
                imdb: { rating: item.imdbRating, votes: item.imdbVotes },
                rotten: null,
                metacritic: null
            };
            item.Ratings?.forEach(r => {
                if (r.Source === "Rotten Tomatoes") ratings.rotten = r.Value;
                if (r.Source === "Metacritic") ratings.metacritic = r.Value;
            });
            return ratings;
        };

        const isAsianDrama = (item) => {
            const countries = /South Korea|China|Japan|Thailand|Taiwan|Hong Kong/i;
            const genres = /Drama|Romance|Comedy/i;
            const isCountry = item.Country && countries.test(item.Country);
            return isCountry && item.Genre && genres.test(item.Genre);
        };

        // Cloud Throttle Queue
        const cloudQueue = {
            current: new Map(),
            timer: null
        };
        const saveToCloudThrottled = (id, item, session) => {
            if (!session) return;
            cloudQueue.current.set(id, item);
            
            if (cloudQueue.timer) clearTimeout(cloudQueue.timer);
            
            cloudQueue.timer = setTimeout(async () => {
                const batch = [];
                cloudQueue.current.forEach((val, key) => {
                    batch.push({
                        user_id: session.user.id,
                        imdb_id: key,
                        user_meta: val,
                        updated_at: new Date()
                    });
                });
                cloudQueue.current.clear();
                
                if (batch.length > 0) {
                     const { error } = await supabaseClient.from("vault_items").upsert(batch);
                     if (error) console.error("Batch save failed", error);
                }
            }, 2000); 
        };

        // --- UTILS ---
        const getHighResPoster = (url, width = 600) => {
            if (!url || url === "N/A") return "https://via.placeholder.com/300x450?text=No+Poster";
            if (url.includes("media-amazon.com") || url.includes("images-na.ssl-images-amazon.com")) {
                return url.replace(/_V1_.*\.jpg$/, `_V1_SX${width}.jpg`);
            }
            if (url.includes("tmdb.org")) return url.replace(/\/w\d+\//, width > 700 ? "/original/" : `/w${width}/`);
            return url;
        };

        const tmdbImg = (path, size = "w780") => path ? `https://image.tmdb.org/t/p/${size}${path}` : null;

        // 1ï¸âƒ£ Migrate Item & Extend Data Model
        const migrateItem = (item, status) => {
            if (item.userMeta && item.meta && item.tmdb && item.meta.ratingsExternal && item.meta.tvmaze) return item;
            
            const isSeries = item.Type === 'series' || item.Genre?.includes('Animation');
            const oldRating = parseFloat(item.userRating || item.userMeta?.userRating || 0);

            return {
              ...item,
              meta: item.meta || {
                  director: item.Director || "",
                  genre: item.Genre?.split(",").map(g => g.trim()) || [],
                  cast: item.Actors ? item.Actors.split(",").map(a => ({ name: a.trim(), character: null })) : [],
                  series: isSeries ? { seasons: [] } : null,
                  ratingsExternal: normalizeRatings(item),
                  anime: null,
                  asian: null,
                  tvmaze: null
              },
              tmdb: item.tmdb || { id: null, credits: null, images: null, seasons: null, enriched: false },
              userMeta: {
                status: status || item.userMeta?.status || 'watchlist',
                userRating: oldRating, 
                rewatchCount: item.userMeta?.rewatchCount || 0,
                series: isSeries ? (item.userMeta?.series || { lastEpisode: { season: 0, episode: 0 }, completed: false }) : null,
                ratings: item.userMeta?.ratings || { overall: oldRating, story: 0, direction: 0, emotion: 0 },
                lastUpdated: item.userMeta?.lastUpdated || Date.now(),
                watchedOn: item.userMeta?.watchedOn || new Date().toISOString().split('T')[0],
                autoOverall: true,
                notes: item.userMeta?.notes || ""
              }
            };
        };

        // --- AUTH COMPONENT ---
        const AuthModal = ({ isOpen, onClose, onLogin }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            if (!isOpen) return null;

            const handleSubmit = async (e) => {
              e.preventDefault();
              setError("");

              try {
                if (isRegister) {
                  const { error } = await supabaseClient.auth.signUp({ email, password });
                  if (error) throw error;
                  alert("Registered! Now login.");
                  setIsRegister(false);
                } else {
                  const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
                  if (error) throw error;
                  onLogin(data.session);
                  onClose();
                }
              } catch (err) { setError(err.message); }
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-sm rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-8 relative">
                         <div className="text-center mb-8">
                             <div className="inline-block p-3 rounded-full bg-indigo-100 dark:bg-indigo-900/30 text-indigo-600 mb-4"><VaultLogoIcon size={48} /></div>
                             <h2 className="text-2xl font-black text-gray-900 dark:text-white uppercase tracking-wider">{isRegister ? 'Join The Vault' : 'Welcome Back'}</h2>
                             <p className="text-sm text-gray-500 mt-2">Sync your collection across devices</p>
                         </div>
                         {error && <div className="mb-4 p-3 bg-red-100 text-red-700 text-sm rounded-lg">{error}</div>}
                         <form onSubmit={handleSubmit} className="space-y-4">
                             <div><label className="block text-xs font-bold uppercase text-gray-500 mb-1">Email</label><input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required /></div>
                             <div><label className="block text-xs font-bold uppercase text-gray-500 mb-1">Password</label><input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required /></div>
                             <button type="submit" className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition-colors shadow-lg shadow-indigo-600/20">{isRegister ? 'Create Account' : 'Access Vault'}</button>
                         </form>
                         <div className="mt-6 text-center"><button onClick={() => setIsRegister(!isRegister)} className="text-sm text-gray-500 hover:text-indigo-600 dark:hover:text-white transition-colors">{isRegister ? 'Already have an account? Login' : 'Need an account? Register'}</button></div>
                    </div>
                </div>
            );
        }

        // --- SETTINGS MODAL ---
        const SettingsModal = ({ isOpen, onClose, apiKeys, setApiKeys, theme, setTheme, onReset, onImport, onExport }) => {
            const [activeTab, setActiveTab] = useState('general');
            const [copySuccess, setCopySuccess] = useState('');

            if (!isOpen) return null;

            const copySQL = () => {
                navigator.clipboard.writeText(DB_SCHEMA_SQL);
                setCopySuccess('Copied!');
                setTimeout(() => setCopySuccess(''), 2000);
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-lg rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative flex flex-col max-h-[90vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-6 dark:text-white flex items-center gap-2"><Settings size={20} /> Vault Settings</h2>
                        
                        <div className="flex gap-4 border-b border-gray-200 dark:border-gray-700 mb-6">
                            <button onClick={() => setActiveTab('general')} className={`pb-2 text-sm font-medium transition-colors ${activeTab === 'general' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}>General</button>
                            <button onClick={() => setActiveTab('database')} className={`pb-2 text-sm font-medium transition-colors ${activeTab === 'database' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}>Database Schema</button>
                        </div>

                        <div className="overflow-y-auto custom-scrollbar flex-1">
                            {activeTab === 'general' && (
                                <div className="space-y-6">
                                    <div>
                                        <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">Appearance</label>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button onClick={() => setTheme('light')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'light' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Light Mode</button>
                                            <button onClick={() => setTheme('dark')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'dark' ? 'bg-indigo-900/30 border-indigo-500 text-indigo-300' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Dark Mode</button>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">API Connections</label>
                                        <div className="space-y-3">
                                            <input type="text" placeholder="OMDb API Key" value={apiKeys.omdb} onChange={(e) => setApiKeys(p => ({...p, omdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                            <input type="text" placeholder="TMDB API Key" value={apiKeys.tmdb} onChange={(e) => setApiKeys(p => ({...p, tmdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                            <input type="text" placeholder="RapidAPI Key (For MDL)" value={apiKeys.rapid || ''} onChange={(e) => setApiKeys(p => ({...p, rapid: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                        </div>
                                    </div>

                                    <div className="pt-4 border-t border-gray-200 dark:border-gray-700 space-y-3">
                                        <div className="grid grid-cols-2 gap-3">
                                            <button onClick={onExport} className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700"><Download size={14}/> Backup</button>
                                            <label className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer">
                                                <Upload size={14}/> Restore
                                                <input type="file" accept=".json" onChange={onImport} className="hidden" />
                                            </label>
                                        </div>
                                        <button onClick={onReset} className="w-full text-red-500 hover:text-red-600 text-xs font-bold py-2">Factory Reset Vault</button>
                                    </div>
                                </div>
                            )}

                            {activeTab === 'database' && (
                                <div className="space-y-4">
                                    <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
                                        <h3 className="text-sm font-bold text-yellow-800 dark:text-yellow-200 flex items-center gap-2"><Database size={16}/> Action Required</h3>
                                        <p className="text-xs text-yellow-700 dark:text-yellow-300 mt-1">To enable the Persistent MDL Registry, you must run this SQL in your Supabase SQL Editor.</p>
                                    </div>
                                    <div className="relative">
                                        <pre className="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg text-[10px] font-mono text-gray-600 dark:text-gray-300 overflow-x-auto whitespace-pre-wrap border border-gray-200 dark:border-gray-700">
                                            {DB_SCHEMA_SQL}
                                        </pre>
                                        <button onClick={copySQL} className="absolute top-2 right-2 p-2 bg-white dark:bg-dark-card border border-gray-200 dark:border-gray-700 rounded-md shadow-sm hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
                                            {copySuccess ? <span className="text-xs font-bold text-green-500">{copySuccess}</span> : <Copy size={14} className="text-gray-500"/>}
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- SUGGESTIONS MODAL ---
        const SuggestionsModal = ({ isOpen, onClose, suggestions, onApprove, onReject }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-lg rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative flex flex-col max-h-[80vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-4 dark:text-white flex items-center gap-2"><Inbox size={20} /> Suggestions Inbox</h2>
                        {suggestions.length === 0 ? (
                            <div className="text-center py-10 text-gray-500">No pending suggestions.</div>
                        ) : (
                            <div className="space-y-3 overflow-y-auto custom-scrollbar p-1">
                                {suggestions.map(s => (
                                    <div key={s.id} className="p-3 bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-800 rounded-lg flex justify-between items-center gap-4">
                                        <div className="min-w-0">
                                            <div className="font-bold dark:text-white truncate">{s.title}</div>
                                            <div className="text-xs text-gray-500">{s.year} â€¢ {s.type} â€¢ ID: {s.imdb_id}</div>
                                            <div className="text-[10px] text-gray-400 mt-0.5">By: {s.suggested_by ? s.suggested_by.substring(0,8)+'...' : 'Unknown'}</div>
                                        </div>
                                        <div className="flex gap-2 shrink-0">
                                            <button onClick={() => onReject(s.id)} className="p-2 bg-red-100 hover:bg-red-200 text-red-600 rounded-lg text-xs font-bold">Reject</button>
                                            <button onClick={() => onApprove(s)} className="p-2 bg-green-100 hover:bg-green-200 text-green-600 rounded-lg text-xs font-bold">Approve</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        function App() {
            // -- State --
            const [session, setSession] = useState(null);
            
            // ADMIN CHECK
            const isAdmin = session && ADMIN_IDS.includes(session.user.id);

            const [vault, setVault] = useState({ watched: {}, watchlist: {} });
            const [apiKeys, setApiKeys] = useState(DEFAULT_KEYS);
            const [theme, setTheme] = useState('dark');
            const [viewMode, setViewMode] = useState('grid');
            
            const [showAuth, setShowAuth] = useState(false);
            const [syncStatus, setSyncStatus] = useState('idle');
            
            // -- UI State --
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [activeFilter, setActiveFilter] = useState('all');
            const [activeSmartList, setActiveSmartList] = useState(null);
            const [sortBy, setSortBy] = useState('updated');
            const [selectedMovie, setSelectedMovie] = useState(null);
            const [actorModalData, setActorModalData] = useState(null); 
            const [showSettings, setShowSettings] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);

            // -- ADMIN SUGGESTIONS STATE --
            const [adminSuggestions, setAdminSuggestions] = useState([]);
            const [showSuggestionsModal, setShowSuggestionsModal] = useState(false);
            
            const searchTimeout = useRef(null);

            // --- ðŸ”’ CACHED API WRAPPERS ---

            const fetchOmdbCached = async (url) => {
                const key = `omdb:${url}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(url);
                    const json = await res.json();
                    cacheSet(key, json);
                    return json;
                } catch(e) { console.error("OMDb Error", e); return null; }
            };

            const fetchTmdbCached = async (endpoint) => {
                if (!apiKeys.tmdb) return null;
                const key = `tmdb:${endpoint}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const sep = endpoint.includes('?') ? '&' : '?';
                    const res = await fetch(`https://api.themoviedb.org/3/${endpoint}${sep}api_key=${apiKeys.tmdb}`);
                    if (!res.ok) return null;
                    const json = await res.json();
                    cacheSet(key, json);
                    return json;
                } catch(e) { console.error("TMDB Error", e); return null; }
            };

            // ðŸŒŸ REGISTRY: FETCH MDL DETAILS (RAPIDAPI)
            const fetchMDLDetails = async (mdlId) => {
                if (!apiKeys.rapid) throw new Error("No RapidAPI Key");
                const res = await fetch(
                    `https://${RAPID_HOST_MDL}/tvshow/details/${mdlId}`,
                    {
                        headers: {
                            "x-rapidapi-host": RAPID_HOST_MDL,
                            "x-rapidapi-key": apiKeys.rapid
                        }
                    }
                );
                if (!res.ok) throw new Error("MDL fetch failed");
                return await res.json();
            };

            const normalizeMDL = (raw) => ({
                mdl_id: String(raw.data?.id || raw.id), // Ensure string for consistency
                title: raw.data?.title || raw.title,
                alt_titles: raw.data?.alternative_titles || [],
                year: parseInt(raw.data?.year || raw.year || 0),
                country: raw.data?.country || raw.country,
                type: raw.data?.type || raw.type,
                episodes: raw.data?.episodes || raw.episodes,
                rating: parseFloat(raw.data?.score || raw.data?.rating || raw.rating || 0),
                votes: parseInt(raw.data?.scored_by || raw.data?.votes || raw.votes || 0),
                genres: raw.data?.genres || [],
                synopsis: raw.data?.synopsis || raw.synopsis,
                poster_url: raw.data?.cover || raw.poster,
                raw: raw.data || raw
            });

            // ðŸŒŸ REGISTRY: STORE FOREVER PATTERN
            const storeMDLForever = async (mdlId) => {
                // 1. Check registry (Supabase)
                const { data: existing } = await supabaseClient
                    .from("mdl_registry")
                    .select("*") // Fetch all fields for local use
                    .eq("mdl_id", String(mdlId))
                    .single();

                if (existing) return existing;

                // 2. Fetch & normalize (RapidAPI)
                try {
                    const raw = await fetchMDLDetails(mdlId);
                    const normalized = normalizeMDL(raw);

                    // 3. Store forever (Supabase)
                    const { error } = await supabaseClient
                        .from("mdl_registry")
                        .upsert(normalized);
                    
                    if (error) console.error("Registry upsert error:", error);

                    return normalized;
                } catch (e) {
                    console.error("Store MDL Forever Error:", e);
                    return null;
                }
            };

            // ðŸŒŸ REGISTRY: LINK ITEM TO MDL
            const linkItemToMDL = async (imdbId, mdlId) => {
                await supabaseClient.from("mdl_imdb_map").upsert({
                    mdl_id: String(mdlId),
                    imdb_id: imdbId,
                    confidence: 1.0,
                    source: "manual-enrich"
                });
            };

            // ðŸŒŸ REGISTRY: SEARCH MDL (To find ID first)
            const searchMDLTitle = async (title) => {
                if (!apiKeys.rapid) return null;
                try {
                    const res = await fetch(`https://${RAPID_HOST_MDL}/search`, {
                        method: "POST", 
                        headers: { "content-type": "application/json", "X-RapidAPI-Key": apiKeys.rapid, "X-RapidAPI-Host": RAPID_HOST_MDL },
                        body: JSON.stringify({ query: title, limit: 1 })
                    });
                    if (!res.ok) return null;
                    const json = await res.json();
                    if (!json || !json.results?.length) return null;
                    return json.results[0]; // Returns search result object (has ID)
                } catch(e) { return null; }
            };

            // ðŸ¥ JIKAN API (MAL) - No Key
            const fetchMALAnime = async (title) => {
                const cacheKey = `mal:${title.toLowerCase()}`;
                const cached = cacheGet(cacheKey);
                if (cached) return cached;

                try {
                    const res = await fetch(`https://api.jikan.moe/v4/anime?q=${encodeURIComponent(title)}&limit=1`);
                    const json = await res.json();
                    const anime = json.data?.[0];
                    if (!anime) return null;

                    const normalized = {
                        id: anime.mal_id,
                        title: anime.title,
                        rating: anime.score,
                        votes: anime.scored_by,
                        episodes: anime.episodes,
                        status: anime.status,
                        aired: anime.aired?.string,
                        genres: anime.genres.map(g => g.name),
                        poster: anime.images?.jpg?.large_image_url,
                        url: anime.url
                    };
                    cacheSet(cacheKey, normalized);
                    return normalized;
                } catch(e) { return null; }
            };

            // ðŸ“º TVMAZE API - No Key
            const fetchTVMazeByImdb = async (imdbID) => {
                const key = `tvmaze:${imdbID}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/lookup/shows?imdb=${imdbID}`);
                    if (!res.ok) return null;
                    const show = await res.json();
                    cacheSet(key, show);
                    return show;
                } catch(e) { return null; }
            };

            const fetchTVMazeEpisodes = async (tvmazeId) => {
                const key = `tvmaze:episodes:${tvmazeId}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/shows/${tvmazeId}/episodes`);
                    const episodes = await res.json();
                    const normalized = episodes.map(ep => ({
                        season: ep.season,
                        episode: ep.number,
                        title: ep.name,
                        airDate: ep.airdate,
                        runtime: ep.runtime,
                        summary: ep.summary ? ep.summary.replace(/<[^>]*>?/gm, '') : ''
                    }));
                    cacheSet(key, normalized);
                    return normalized;
                } catch(e) { return []; }
            };

            const fetchTVMazeCast = async (tvmazeId) => {
                const key = `tvmaze:cast:${tvmazeId}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/shows/${tvmazeId}/cast`);
                    const cast = await res.json();
                    const normalized = cast.slice(0,10).map(c => ({
                        name: c.person.name,
                        character: c.character.name,
                        photo: c.person.image?.medium || null
                    }));
                    cacheSet(key, normalized);
                    return normalized;
                } catch(e) { return []; }
            };


            // --- HELPER FUNCTIONS REFACTORED TO USE CACHE ---

            const fetchTmdbId = async (imdbID, type) => {
              if (!apiKeys.tmdb) return null;
              const json = await fetchTmdbCached(`find/${imdbID}?external_source=imdb_id`);
              if (!json) return null;
              return type === "movie" ? json.movie_results?.[0]?.id : json.tv_results?.[0]?.id;
            };

            const extractDirectors = (crew, type) => {
              if (!crew) return [];
              if (type === "movie") return crew.filter(c => c.job === "Director").map(d => d.name);
              return crew.filter(c => c.department === "Directing" || c.job === "Executive Producer").slice(0,2).map(d => d.name); 
            };

            const fetchCredits = async (tmdbId, type) => {
              const endpoint = type === "movie" ? "movie" : "tv";
              return await fetchTmdbCached(`${endpoint}/${tmdbId}/credits`);
            };

            const normalizeCast = (cast) =>
              cast.slice(0, 12).map(actor => ({
                id: actor.id,
                name: actor.name,
                character: actor.character,
                photo: actor.profile_path ? `https://image.tmdb.org/t/p/w185${actor.profile_path}` : null
              }));

            const fetchTvDetails = async (tmdbId) => {
              return await fetchTmdbCached(`tv/${tmdbId}`);
            };

            const fetchSeasonEpisodes = async (tmdbId, seasonNumber) => {
              const json = await fetchTmdbCached(`tv/${tmdbId}/season/${seasonNumber}`);
              if (!json) return [];
              return json.episodes.map(ep => ({
                episode: ep.episode_number,
                title: ep.name,
                airDate: ep.air_date,
                overview: ep.overview,
                still: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : null,
                imdbRating: ep.vote_average ? ep.vote_average.toFixed(1) : null,
                rating: null,
                watched: false,
                watchedOn: null,
                notes: ""
              }));
            };

            const fetchFilmography = async (actorId) => {
                const json = await fetchTmdbCached(`person/${actorId}/combined_credits`);
                if (!json) return [];
                return json.cast
                    .filter(c => c.poster_path && (c.media_type === 'movie' || c.media_type === 'tv'))
                    .sort((a, b) => b.popularity - a.popularity)
                    .slice(0, 20);
            };

            const onActorClick = async (actor) => {
                const credits = await fetchFilmography(actor.id);
                setActorModalData({ name: actor.name, credits, id: actor.id, photo: actor.photo });
            };

            const searchByPerson = async (query) => {
              if(!apiKeys.tmdb) return [];
              const json = await fetchTmdbCached(`search/person?query=${encodeURIComponent(query)}`);
              if (!json) return [];
              return json.results.slice(0, 3).map(p => ({
                  ...p,
                  media_type: 'person',
                  Title: p.name,
                  imdbID: `person_${p.id}` 
              }));
            };


            // --- 3ï¸âƒ£ UNIFIED ENRICHMENT PIPELINE (REGISTRY UPGRADED) ---
            const enrichItem = async (item) => {
                let updates = {};
                let metaUpdates = { ...item.meta };

                // A. Anime Detection & Fetch (Jikan)
                if (item.Genre?.includes('Animation') && !item.meta.anime) {
                    const mal = await fetchMALAnime(item.Title);
                    if (mal) {
                        metaUpdates.anime = { mal };
                    }
                }

                // B. TV Show Deep Dive (TVMaze)
                if (item.Type === "series" && !item.meta.tvmaze) {
                    const show = await fetchTVMazeByImdb(item.imdbID);
                    if (show) {
                        const episodes = await fetchTVMazeEpisodes(show.id);
                        const cast = await fetchTVMazeCast(show.id);
                        metaUpdates.tvmaze = { id: show.id, episodes, cast };
                    }
                }

                // C. Asian Drama (MDL REGISTRY FLOW)
                if (isAsianDrama(item) && !item.meta.asian) {
                     // 1. Check Supabase Mapping
                     const { data: map } = await supabaseClient.from("mdl_imdb_map").select("mdl_id").eq("imdb_id", item.imdbID).single();
                     
                     let mdlData = null;

                     if (map) {
                         // Found in map -> Get from Registry
                         mdlData = await storeMDLForever(map.mdl_id);
                     } else {
                         // Not found -> Search API
                         const searchResult = await searchMDLTitle(item.Title);
                         if (searchResult) {
                             // Found -> Detail Fetch + Store Forever
                             mdlData = await storeMDLForever(searchResult.id);
                             if (mdlData) {
                                 // Create Mapping for future
                                 await linkItemToMDL(item.imdbID, mdlData.mdl_id);
                             }
                         }
                     }

                     if (mdlData) {
                         // Adapting registry format to UI expectations (rating/votes/url)
                         metaUpdates.asian = { 
                             mdl: { 
                                 id: mdlData.mdl_id,
                                 title: mdlData.title,
                                 rating: mdlData.rating,
                                 votes: mdlData.votes,
                                 url: `https://mydramalist.com/${mdlData.mdl_id}`, // Construct URL as API might not give full web link in details
                                 lastFetched: Date.now() 
                             } 
                         };
                     }
                }

                // D. TMDB Core Data
                const needsTmdb = !item.tmdb?.enriched && apiKeys.tmdb;
                if (needsTmdb) {
                    const tmdbId = item.tmdb?.id || await fetchTmdbId(item.imdbID, item.Type === 'series' ? 'tv' : 'movie');
                    if (tmdbId) {
                        const credits = await fetchCredits(tmdbId, item.Type === 'series' ? 'tv' : 'movie');
                        const directors = extractDirectors(credits?.crew, item.Type);
                        const cast = normalizeCast(credits?.cast || []);

                        let seasons = null;
                        if (item.Type === "series") {
                            const tv = await fetchTvDetails(tmdbId);
                            if (tv && tv.seasons) {
                                seasons = await Promise.all(
                                    tv.seasons
                                        .filter(s => s.season_number > 0)
                                        .map(async s => ({
                                            season: s.season_number,
                                            airDate: s.air_date,
                                            episodes: await fetchSeasonEpisodes(tmdbId, s.season_number)
                                        }))
                                );
                            }
                        }
                        
                        metaUpdates.director = directors.length > 0 ? directors : metaUpdates.director;
                        metaUpdates.cast = cast.length > 0 ? cast : metaUpdates.cast;
                        if (seasons) metaUpdates.series = { seasons };
                        
                        updates.tmdb = {
                            id: tmdbId,
                            credits: { cast: cast, crew: credits?.crew?.slice(0,5) },
                            seasons,
                            enriched: true
                        };
                    }
                }

                updates.meta = metaUpdates;
                
                // Only update if there are changes
                if (Object.keys(updates).length > 0) {
                    updateItem(item.imdbID, i => ({ ...i, ...updates }));
                }
            };

            // -- Initialization --
            useEffect(() => {
                if (theme === 'dark') document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
                const localKeys = localStorage.getItem('vault_v5_keys');
                if (localKeys) setApiKeys(JSON.parse(localKeys));
                
                // Load local data and backfill metadata if missing
                const localVault = localStorage.getItem('vault_v6_data');
                if (localVault) {
                    try {
                        const parsed = JSON.parse(localVault);
                        let changed = false;
                        
                        // Self-healing migration for existing data
                        ['watched', 'watchlist'].forEach(listKey => {
                            if (parsed[listKey]) {
                                Object.keys(parsed[listKey]).forEach(key => {
                                    const item = parsed[listKey][key];
                                    if (!item.tmdb || !item.meta.ratingsExternal || item.meta.asian === undefined || item.meta.tvmaze === undefined) {
                                        parsed[listKey][key] = migrateItem(item);
                                        changed = true;
                                    }
                                });
                            }
                        });

                        setVault(parsed);
                        if (changed) {
                            localStorage.setItem('vault_v6_data', JSON.stringify(parsed));
                        }
                    } catch (e) { console.error("Corrupted local vault", e); }
                }
            }, []);

            // -- Session Restore Effect --
            useEffect(() => {
                supabaseClient.auth.getSession().then(({ data }) => setSession(data.session));
                const { data: listener } = supabaseClient.auth.onAuthStateChange((_event, session) => setSession(session));
                return () => listener.subscription.unsubscribe();
            }, []);

            useEffect(() => { localStorage.setItem('vault_v5_keys', JSON.stringify(apiKeys)); }, [apiKeys]);
            useEffect(() => { if (theme === 'dark') document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); }, [theme]);

            // -- AUTH & SYNC --
            const handleLogin = (session) => setSession(session);
            const handleLogout = async () => { await supabaseClient.auth.signOut(); setSession(null); };

            // -- BACKUP & RESTORE --
            const handleExport = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(vault));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "vault_backup_" + new Date().toISOString().split('T')[0] + ".json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const rawData = JSON.parse(event.target.result);
                        if (!rawData.watched && !rawData.watchlist) throw new Error("Invalid format: Not a Vault backup file");
                        const processedVault = { watched: {}, watchlist: {} };
                        Object.entries(rawData.watched || {}).forEach(([id, item]) => processedVault.watched[id] = migrateItem(item, 'watched'));
                        Object.entries(rawData.watchlist || {}).forEach(([id, item]) => processedVault.watchlist[id] = migrateItem(item, 'watchlist'));
                        setVault(processedVault);
                        localStorage.setItem('vault_v6_data', JSON.stringify(processedVault));
                        
                        if (session) {
                            setSyncStatus('syncing');
                            await supabaseClient.from('vault_items').delete().eq('user_id', session.user.id);
                            const items = [];
                            [...Object.values(processedVault.watched), ...Object.values(processedVault.watchlist)].forEach(item => {
                                items.push({ user_id: session.user.id, imdb_id: item.imdbID, user_meta: item, updated_at: new Date() });
                            });
                            const chunkSize = 50;
                            for (let i = 0; i < items.length; i += chunkSize) {
                                const chunk = items.slice(i, i + chunkSize);
                                await supabaseClient.from('vault_items').upsert(chunk);
                            }
                            setSyncStatus('idle');
                        }
                        setShowSettings(false);
                        alert("Vault restored successfully!");
                    } catch (err) { alert("Failed to import file: " + err.message); }
                };
                reader.readAsText(file);
            };

            // Cloud Fetch Effect
           useEffect(() => {
              if (!session) return;
              setSyncStatus("syncing");
              supabaseClient.from("vault_items").select("*").then(({ data, error }) => {
                  if (error) { setSyncStatus("error"); return console.error(error); }
                  setSyncStatus("idle");
                  const newVault = { watched: {}, watchlist: {} };
                  data.forEach(row => {
                    let item = row.user_meta;
                    const defaultStatus = (item.userRating && parseFloat(item.userRating) > 0) ? 'watched' : 'watchlist';
                    const status = item.userMeta?.status || defaultStatus;
                    item = migrateItem(item, status); 
                    if (item.userMeta?.status === "watched") newVault.watched[row.imdb_id] = item;
                    else newVault.watchlist[row.imdb_id] = item;
                  });
                  setVault(newVault);
                  localStorage.setItem("vault_v6_data", JSON.stringify(newVault));
                }).catch(err => { setSyncStatus("error"); console.error(err); });
            }, [session]);

            const updateItem = useCallback((imdbID, updater) => {
                setVault(prev => {
                    const item = prev.watched[imdbID] || prev.watchlist[imdbID];
                    if (!item) return prev;
                    const updatedItem = updater(item);
                    if (!updatedItem.userMeta.lastUpdated) updatedItem.userMeta.lastUpdated = Date.now();
                    const newStatus = updatedItem.userMeta.status;
                    const nextWatched = { ...prev.watched };
                    const nextWatchlist = { ...prev.watchlist };
                    delete nextWatched[imdbID];
                    delete nextWatchlist[imdbID];
                    if (newStatus === 'watched') nextWatched[imdbID] = updatedItem;
                    else nextWatchlist[imdbID] = updatedItem;
                    const nextVault = { watched: nextWatched, watchlist: nextWatchlist };
                    localStorage.setItem("vault_v6_data", JSON.stringify(nextVault));
                    saveToCloudThrottled(imdbID, updatedItem, session);
                    return nextVault;
                });
            }, [session]);

            // Sync selectedMovie stale data and trigger enrichment
            useEffect(() => {
                if (!selectedMovie) return;
                const updated = vault.watched[selectedMovie.imdbID] || vault.watchlist[selectedMovie.imdbID];
                if (updated && updated !== selectedMovie) setSelectedMovie(updated);
                if (updated) enrichItem(updated); // Unified Enrichment Call
            }, [vault, selectedMovie]);

            const toggleEpisode = (imdbID, seasonNum, epNum) => {
              updateItem(imdbID, item => {
                const seasons = item.meta.series.seasons.map(s => s.season !== seasonNum ? s : { ...s, episodes: s.episodes.map(e => e.episode !== epNum ? e : { ...e, watched: !e.watched, watchedOn: !e.watched ? new Date().toISOString() : null }) });
                return { ...item, meta: { ...item.meta, series: { seasons } } };
              });
            };

            const rateEpisode = (imdbID, seasonNum, epNum, rating) => {
              updateItem(imdbID, item => ({ ...item, meta: { ...item.meta, series: { seasons: item.meta.series.seasons.map(s => s.season !== seasonNum ? s : { ...s, episodes: s.episodes.map(e => e.episode === epNum ? { ...e, rating } : e) }) } } }));
            };

            // --- SEARCH LOGIC ---
            const existsInVault = useCallback((imdbID) => !!(vault.watched[imdbID] || vault.watchlist[imdbID]), [vault]);

            const searchOfflineVault = useCallback((query) => {
              const norm = normalize(query);
              if (!norm) return [];
              const all = [...Object.values(vault.watched), ...Object.values(vault.watchlist)];
              const matches = all.filter(item => normalize(item.Title).includes(norm) || item.imdbID === query);
              return matches.sort((a, b) => (b.userMeta?.lastUpdated || 0) - (a.userMeta?.lastUpdated || 0));
            }, [vault]);

            const smartSearch = useCallback(async (query, type = "", year = "") => {
              const offline = searchOfflineVault(query);
              if (offline.length > 0) return { source: "offline", results: offline };

              const cacheKey = `vault_search_${type}_${query}_${year}`;
              const cached = cacheGet(cacheKey);
              if (cached) return { source: "cache", results: cached };

              try {
                  const json = await fetchOmdbCached(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&s=${encodeURIComponent(query)}&type=${type}&y=${year}`);
                  let results = [];
                  if (json && json.Response === "True") results = json.Search;

                  const people = await searchByPerson(query);
                  results = [...results, ...people];

                  const ranked = results.sort((a, b) => {
                    const exactA = normalize(a.Title) === normalize(query);
                    const exactB = normalize(b.Title) === normalize(query);
                    if (exactA !== exactB) return exactB - exactA;
                    return (parseInt(b.Year) || 0) - (parseInt(a.Year) || 0);
                  });

                  cacheSet(cacheKey, ranked);
                  return { source: "remote", results: ranked };
              } catch (e) { console.error(e); return { source: "error", results: [] }; }
            }, [apiKeys, searchOfflineVault]);

            const addToVault = async (imdbID, status = "watchlist") => {
              // ADMIN GUARD - KEEPING THIS AS A SAFETY, BUT IT IS ONLY CALLED BY APPROVE OR ADMIN UI
              if (!isAdmin) {
                alert("Only admin can add to the library directly.");
                return;
              }

              const fullItem = await fetchOmdbCached(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${imdbID}&plot=full`);
              if (!fullItem || fullItem.Response === "False") return;

              const migrated = migrateItem(fullItem, status);
              setVault(prev => {
                const next = { watched: { ...prev.watched }, watchlist: { ...prev.watchlist } };
                delete next.watched[imdbID];
                delete next.watchlist[imdbID];
                if (status === "watched") next.watched[imdbID] = migrated;
                else next.watchlist[imdbID] = migrated;
                localStorage.setItem("vault_v6_data", JSON.stringify(next));
                return next;
              });
              saveToCloudThrottled(imdbID, migrated, session);
              setSearchResults([]);
              setSearchQuery('');
            };

            // --- SUGGESTION SYSTEM ---
            const suggestTitle = async (item) => {
                if (!session) { alert("Please login to suggest content."); return; }
                if (existsInVault(item.imdbID)) { alert("Already in the Vault!"); return; }

                const { data: existing } = await supabaseClient
                    .from("content_suggestions")
                    .select("id")
                    .eq("imdb_id", item.imdbID)
                    .eq("status", "pending")
                    .single();
                
                if (existing) { alert("Already suggested and pending approval!"); return; }

                const { error } = await supabaseClient.from("content_suggestions").insert({
                    imdb_id: item.imdbID,
                    title: item.Title,
                    year: parseInt(item.Year) || 0,
                    type: item.Type === "series" ? "series" : "movie",
                    suggested_by: session.user.id
                });

                if (error) { console.error(error); alert("Failed to send suggestion."); }
                else { alert("Suggestion sent to admin! ðŸ‘"); }
            };

            const fetchSuggestions = async () => {
                if (!isAdmin) return;
                const { data } = await supabaseClient
                    .from("content_suggestions")
                    .select("*") 
                    .eq("status", "pending")
                    .order("created_at", { ascending: false });
                setAdminSuggestions(data || []);
            };

            useEffect(() => {
                if (isAdmin) fetchSuggestions();
            }, [isAdmin]);

            const handleApprove = async (s) => {
                await addToVault(s.imdb_id, "watchlist");
                await supabaseClient.from("content_suggestions").update({ status: 'approved' }).eq('id', s.id);
                fetchSuggestions();
            };

            const handleReject = async (id) => {
                await supabaseClient.from("content_suggestions").update({ status: 'rejected' }).eq('id', id);
                fetchSuggestions();
            };

            // --- END SUGGESTION SYSTEM ---

            const handleSearch = async (q) => {
              if (!q || q.length < 3) { setSearchResults([]); return; }
              const { results } = await smartSearch(q);
              setSearchResults(results || []);
            };
            
            const handleSearchInput = (value) => {
                setSearchQuery(value);
                if (searchTimeout.current) clearTimeout(searchTimeout.current);
                if (value.length < 3) { setSearchResults([]); return; }
                searchTimeout.current = setTimeout(() => { handleSearch(value); }, 400); 
            };

            // --- COMPUTED DATA ---
            const allItems = useMemo(() => [...Object.values(vault.watched), ...Object.values(vault.watchlist)], [vault]);
            
            const analytics = useMemo(() => {
                const total = allItems.length;
                if (total === 0) return { avgRating: 0, totalRewatch: 0, watchedCount: 0, watchedEpisodes: 0, avgEpisodeRating: 0 };
                const watched = Object.values(vault.watched);
                const avgRating = watched.reduce((acc, curr) => acc + (curr.userMeta?.ratings?.overall || 0), 0) / (watched.length || 1);
                const totalRewatch = watched.reduce((acc, curr) => acc + (curr.userMeta?.rewatchCount || 0), 0);
                const eps = allItems.filter(i => i.Type === "series" && i.meta?.series?.seasons).flatMap(i => i.meta.series.seasons.flatMap(s => s.episodes || []));
                const watchedEps = eps.filter(e => e.watched);
                const ratedEps = eps.filter(e => e.rating > 0);
                const avgEpRating = ratedEps.length > 0 ? ratedEps.reduce((a, e) => a + (e.rating || 0), 0) / ratedEps.length : 0;
                return { avgRating: avgRating.toFixed(1), totalRewatch, watchedCount: watched.length, watchedEpisodes: watchedEps.length, avgEpisodeRating: avgEpRating.toFixed(1) };
            }, [allItems, vault]);

            const mdlStats = useMemo(() => {
                const dramas = allItems.map(i => i.meta?.asian?.mdl).filter(Boolean);
                return { avgMDL: dramas.length > 0 ? (dramas.reduce((a, d) => a + (d.rating || 0), 0) / dramas.length).toFixed(1) : 0, totalTitles: dramas.length };
            }, [allItems]);

            const filteredItems = useMemo(() => {
                let items = allItems;
                if (searchQuery) { const q = searchQuery.toLowerCase(); items = items.filter(i => i.Title.toLowerCase().includes(q)); }
                if (activeSmartList) { const list = SMART_LISTS.find(l => l.id === activeSmartList); if (list) items = items.filter(list.filter); } 
                else { if (activeFilter === 'movies') items = items.filter(i => i.Type === 'movie'); else if (activeFilter === 'series') items = items.filter(i => i.Type === 'series'); }
                return items.sort((a, b) => {
                    if (sortBy === 'rating') return (b.userMeta?.ratings?.overall || 0) - (a.userMeta?.ratings?.overall || 0);
                    if (sortBy === 'updated') return (b.userMeta?.lastUpdated || 0) - (a.userMeta?.lastUpdated || 0);
                    return a.Title.localeCompare(b.Title); 
                });
            }, [allItems, searchQuery, activeFilter, activeSmartList, sortBy]);

            const timelineEvents = useMemo(() => {
                const events = [];
                Object.values(vault.watched).forEach(item => { events.push({ type: "movie", imdbID: item.imdbID, title: item.Title, watchedOn: item.userMeta.watchedOn, rating: item.userMeta.ratings.overall, poster: item.Poster }); });
                allItems.filter(i => i.Type === "series" && i.meta?.series?.seasons).forEach(series => { series.meta.series.seasons.forEach(s => s.episodes.forEach(e => { if (e.watched) { events.push({ type: "episode", imdbID: series.imdbID, title: `${series.Title} â€¢ S${s.season}E${e.episode}`, watchedOn: e.watchedOn, rating: e.rating, poster: series.Poster }); } })); });
                return events.sort((a, b) => new Date(b.watchedOn) - new Date(a.watchedOn));
            }, [vault, allItems]);

            const peopleStats = useMemo(() => {
                const map = {};
                allItems.forEach(item => {
                    if (Array.isArray(item.meta?.director)) { item.meta.director.forEach(name => { map[name] ??= { movies: 0, avgRating: [], type: "director" }; map[name].movies++; if(item.userMeta.ratings.overall > 0) map[name].avgRating.push(item.userMeta.ratings.overall); }); } 
                    else if (item.meta?.director && item.meta.director !== "N/A") { const name = item.meta.director; map[name] ??= { movies: 0, avgRating: [], type: "director" }; map[name].movies++; if(item.userMeta.ratings.overall > 0) map[name].avgRating.push(item.userMeta.ratings.overall); }
                    item.meta?.cast?.forEach(actor => { map[actor.name] ??= { movies: 0, avgRating: [], type: "actor" }; map[actor.name].movies++; if(item.userMeta.ratings.overall > 0) map[actor.name].avgRating.push(item.userMeta.ratings.overall); });
                });
                return Object.entries(map).map(([name, d]) => ({ name, type: d.type, count: d.movies, avgRating: d.avgRating.length > 0 ? (d.avgRating.reduce((a, b) => a + b, 0) / d.avgRating.length) : 0 })).filter(p => p.count > 1).sort((a, b) => b.count - a.count).slice(0, 8);
            }, [allItems]);

            return (
                <div className="min-h-screen pb-32 selection:bg-indigo-500 selection:text-white">
                    <AuthModal isOpen={showAuth} onClose={() => setShowAuth(false)} onLogin={handleLogin} />

                    <header className="sticky top-0 z-30 bg-white/80 dark:bg-dark-bg/80 backdrop-blur-md border-b border-light-border dark:border-dark-border px-4 h-16 flex items-center justify-between">
                         <div className="flex items-center gap-3">
                             <div className="text-indigo-600 dark:text-indigo-500"><VaultLogoIcon size={38} strokeWidth={1.5} /></div>
                             <div className="flex flex-col justify-center">
                                 <span className="text-[10px] font-bold tracking-[0.25em] leading-tight text-gray-500 dark:text-gray-400 uppercase pl-0.5">The</span>
                                 <span className="text-2xl font-black tracking-[0.15em] leading-none uppercase text-gray-900 dark:text-white font-sans">Vault</span>
                             </div>
                         </div>
                         <div className="flex bg-gray-100 dark:bg-gray-800 rounded-full p-1 mx-4">
                             <button onClick={() => setViewMode('grid')} className={`p-2 rounded-full transition-all ${viewMode === 'grid' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><Grid size={18}/></button>
                             <button onClick={() => setViewMode('timeline')} className={`p-2 rounded-full transition-all ${viewMode === 'timeline' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><Clock size={18}/></button>
                             <button onClick={() => setViewMode('analytics')} className={`p-2 rounded-full transition-all ${viewMode === 'analytics' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><BarChart size={18}/></button>
                         </div>
                         <div className="flex items-center gap-2">
                             {/* ADMIN BADGE & INBOX */}
                             {isAdmin && (
                                <div className="flex items-center mr-2 gap-2">
                                    <span className="text-[10px] font-black tracking-widest text-indigo-500 border border-indigo-500/30 px-2 py-1 rounded bg-indigo-500/10">ADMIN</span>
                                    <button onClick={() => setShowSuggestionsModal(true)} className="relative p-2 text-gray-500 hover:text-indigo-600 bg-gray-100 dark:bg-gray-800 rounded-full">
                                        <Inbox size={18}/>
                                        {adminSuggestions.length > 0 && <span className="absolute top-0 right-0 w-3 h-3 bg-red-500 rounded-full border-2 border-white dark:border-dark-bg"></span>}
                                    </button>
                                </div>
                             )}
                             
                             {!session ? (<button onClick={() => setShowAuth(true)} className="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold transition-colors"><LogIn size={16} /> Login</button>) : ( <div className="flex items-center gap-2"> <div className={`w-2 h-2 rounded-full ${syncStatus === 'syncing' ? 'bg-yellow-400 animate-pulse' : syncStatus === 'error' ? 'bg-red-500' : 'bg-green-500'}`} title={`Sync Status: ${syncStatus}`}></div> <button onClick={handleLogout} className="p-2 text-gray-500 hover:text-red-500"><User size={20}/></button> </div> )}
                             <button onClick={() => setShowSettings(true)} className="p-2 text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-white"><Settings size={20} /></button>
                         </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-4 pt-8">
                        {viewMode === 'grid' && (
                            <>
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-blue-100 dark:bg-blue-900/30 text-blue-600 rounded-lg"><Film size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Total Items</div><div className="text-xl font-black dark:text-white">{allItems.length}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-600 rounded-lg"><Star size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Avg Rating</div><div className="text-xl font-black dark:text-white">{analytics.avgRating}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-green-100 dark:bg-green-900/30 text-green-600 rounded-lg"><CheckSquare size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Ep. Watched</div><div className="text-xl font-black dark:text-white">{analytics.watchedEpisodes}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-purple-100 dark:bg-purple-900/30 text-purple-600 rounded-lg"><BarChart size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Ep. Score</div><div className="text-xl font-black dark:text-white">{analytics.avgEpisodeRating}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-teal-100 dark:bg-teal-900/30 text-teal-600 rounded-lg"><Globe size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">MDL Avg</div><div className="text-xl font-black dark:text-white">{mdlStats.avgMDL}</div></div>
                                    </div>
                                </div>

                                <div className="flex flex-wrap items-center justify-between gap-4 mb-6">
                                    <div className="flex items-center gap-2 overflow-x-auto">
                                        {[ { id: 'all', label: 'Everything' }, { id: 'movies', label: 'Movies' }, { id: 'series', label: 'TV Shows' } ].map(f => (
                                            <button key={f.id} onClick={() => { setActiveFilter(f.id); setActiveSmartList(null); }} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap ${activeFilter === f.id && !activeSmartList ? 'bg-gray-900 text-white dark:bg-white dark:text-black' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}>{f.label}</button>
                                        ))}
                                        {SMART_LISTS.map(list => (
                                            <button key={list.id} onClick={() => { setActiveSmartList(list.id === activeSmartList ? null : list.id); setActiveFilter('all'); }} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap flex items-center gap-2 ${activeSmartList === list.id ? 'bg-indigo-600 text-white' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}><list.icon size={14}/> {list.label}</button>
                                        ))}
                                    </div>
                                    <div className="relative w-full md:w-64">
                                        <Search className="absolute left-3 top-2.5 text-gray-400" size={16} />
                                        <input type="text" placeholder="Search movies, series..." value={searchQuery} onChange={(e) => handleSearchInput(e.target.value)} className="w-full bg-gray-100 dark:bg-gray-800 rounded-full pl-10 pr-4 py-2 text-sm text-gray-900 dark:text-white outline-none focus:border-indigo-500" />
                                        {searchResults.length > 0 && (
                                            <div className="absolute z-50 mt-2 w-full bg-white dark:bg-dark-card rounded-xl shadow-xl max-h-96 overflow-y-auto border border-gray-200 dark:border-gray-700">
                                                {searchResults.map((item, idx) => {
                                                const inVault = item.media_type !== 'person' && existsInVault(item.imdbID);
                                                if (item.media_type === 'person') {
                                                    return (
                                                        <div key={`${item.id}_person_${idx}`} onClick={() => { onActorClick({ id: item.id, name: item.Title, photo: item.profile_path ? `https://image.tmdb.org/t/p/w185${item.profile_path}` : null }); setSearchResults([]); setSearchQuery(''); }} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-800 border-b border-gray-100 dark:border-gray-800 cursor-pointer">
                                                            <div className="w-8 h-8 rounded-full bg-indigo-100 dark:bg-indigo-900/50 flex items-center justify-center text-indigo-600 dark:text-indigo-400">{item.profile_path ? <img src={`https://image.tmdb.org/t/p/w45${item.profile_path}`} className="w-full h-full rounded-full object-cover"/> : <User size={14} />}</div>
                                                            <div className="flex-1"><p className="font-semibold text-sm dark:text-white">{item.Title}</p><p className="text-xs text-gray-500">Actor â€¢ View Credits</p></div>
                                                        </div>
                                                    )
                                                }
                                                return (
                                                    <div key={`${item.imdbID}_${idx}`} className="flex items-center justify-between px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-800 border-b border-gray-100 dark:border-gray-800 last:border-0">
                                                        <div className="flex-1 min-w-0 mr-2"><p className="font-semibold text-sm truncate dark:text-white">{item.Title}</p><p className="text-xs text-gray-500">{item.Year} â€¢ {item.Type}</p></div>
                                                        <div className="flex gap-2 shrink-0">
                                                            {inVault ? (
                                                                <span className="text-xs px-2 py-0.5 rounded bg-green-600/20 text-green-400 border border-green-600/30 font-bold">
                                                                  Available in Vault
                                                                </span>
                                                            ) : ( 
                                                                isAdmin ? (
                                                                    <>
                                                                    <button onClick={() => addToVault(item.imdbID, "watchlist")} className="text-xs px-3 py-1.5 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-medium">Watchlist</button>
                                                                    <button onClick={() => addToVault(item.imdbID, "watched")} className="text-xs px-3 py-1.5 rounded-lg bg-green-600 hover:bg-green-700 text-white font-medium">Watched</button>
                                                                    </> 
                                                                ) : (
                                                                    <button onClick={() => suggestTitle(item)} className="text-xs px-3 py-1.5 rounded-lg bg-indigo-100 hover:bg-indigo-200 text-indigo-700 dark:bg-indigo-900/50 dark:text-indigo-300 dark:hover:bg-indigo-900 font-medium">Suggest to Admin</button>
                                                                )
                                                            )}
                                                        </div>
                                                    </div>
                                                );
                                                })}
                                            </div>
                                        )}
                                    </div>
                                </div>

                                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-6 gap-y-10">
                                    {filteredItems.map((item, idx) => (
                                        <div key={`${item.imdbID}_${idx}`} onClick={() => setSelectedMovie(item)} className="group relative bg-white dark:bg-dark-card rounded-xl overflow-hidden shadow-lg hover:scale-[1.02] transition-all cursor-pointer border border-light-border dark:border-dark-border">
                                            <div className="relative aspect-[2/3] overflow-hidden bg-gray-900">
                                                <img src={tmdbImg(item.tmdb?.credits?.images?.posters?.[0]?.file_path, "w342") || getHighResPoster(item.Poster, 400)} className="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity" loading="lazy" />
                                                <div className="absolute top-2 right-2 flex flex-col gap-1 items-end">{item.userMeta?.status === 'watched' && <span className="bg-green-500/90 text-white text-[10px] font-bold px-2 py-1 rounded-md shadow-lg"><CheckCircle size={10} /></span>}</div>
                                                {item.userMeta?.ratings?.overall > 0 && <div className="absolute bottom-2 left-2 bg-yellow-500 text-white px-1.5 py-0.5 rounded text-xs font-bold flex items-center gap-1 shadow-lg"><Star size={10} fill="currentColor" /> {item.userMeta.ratings.overall}</div>}
                                                {item.meta?.asian?.mdl?.rating && <div className="absolute bottom-2 right-2 bg-teal-600 text-white px-1.5 py-0.5 rounded text-[10px] font-bold shadow-lg">MDL {item.meta.asian.mdl.rating}</div>}
                                            </div>
                                            <div className="p-3 space-y-1">
                                                <h3 className="font-bold text-sm line-clamp-1 dark:text-white">{item.Title}</h3>
                                                <div className="text-[11px] text-gray-500 flex flex-wrap gap-x-2"><span>{item.Year}</span><span>â€¢</span><span>{item.Type === "series" ? "TV Series" : "Movie"}</span></div>
                                                {item.meta?.director && <div className="text-[11px] text-gray-400 line-clamp-1"><span className="font-semibold">Dir:</span> {Array.isArray(item.meta.director) ? item.meta.director.join(", ") : item.meta.director}</div>}
                                                <div className="flex flex-wrap gap-1 pt-1">{item.meta?.genre?.slice(0, 2).map(g => <span key={g} className="px-1.5 py-0.5 text-[9px] rounded bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300">{g}</span>)}</div>
                                                {item.Type === "series" && <div className="text-[10px] text-indigo-400 pt-1 font-medium">{item.meta?.totalSeasons || '?'} seasons</div>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </>
                        )}

                        {viewMode === 'timeline' && (
                            <div className="max-w-2xl mx-auto space-y-6">
                                <h2 className="text-2xl font-black dark:text-white mb-6">Watch History</h2>
                                {timelineEvents.length === 0 && <div className="text-center text-gray-500 py-10">No history found. Mark items as watched!</div>}
                                {timelineEvents.map((ev, idx) => (
                                    <div key={`${ev.imdbID}-${idx}-${ev.watchedOn}`} className="flex gap-4 p-4 bg-white dark:bg-dark-card rounded-xl border border-gray-100 dark:border-gray-800 shadow-sm relative">
                                        <div className="w-16 h-24 shrink-0 rounded-lg overflow-hidden bg-gray-200"><img src={getHighResPoster(ev.poster, 200)} className="w-full h-full object-cover" loading="lazy" /></div>
                                        <div className="flex-1 min-w-0">
                                            <div className="flex justify-between items-start"><h3 className="font-bold dark:text-white text-base truncate">{ev.title}</h3><span className="text-xs text-gray-400 whitespace-nowrap">{new Date(ev.watchedOn).toLocaleDateString()}</span></div>
                                            <div className="flex items-center gap-2 mt-1"><span className={`text-[10px] uppercase font-bold px-2 py-0.5 rounded ${ev.type === 'movie' ? 'bg-blue-100 text-blue-600' : 'bg-purple-100 text-purple-600'}`}>{ev.type}</span>{ev.rating > 0 && <span className="text-yellow-500 text-sm font-bold">â˜… {ev.rating}</span>}</div>
                                        </div>
                                        {idx !== timelineEvents.length - 1 && <div className="absolute left-8 top-28 bottom-[-24px] w-0.5 bg-gray-200 dark:bg-gray-800 -z-10"></div>}
                                    </div>
                                ))}
                            </div>
                        )}

                        {viewMode === 'analytics' && (
                            <div className="space-y-10">
                                <div>
                                    <h2 className="text-2xl font-black dark:text-white mb-6 flex items-center gap-2"><User size={24}/> Top Directors & Actors</h2>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    {peopleStats.map((p, idx) => (
                                        <div key={`${p.name}-${idx}`} className="p-4 rounded-xl bg-white dark:bg-dark-card border border-gray-100 dark:border-gray-800 shadow-sm">
                                            <div className="font-bold dark:text-white truncate">{p.name}</div>
                                            <div className="text-xs text-gray-500 uppercase font-bold tracking-wider mb-2">{p.type}</div>
                                            <div className="flex justify-between items-end"><span className="text-2xl font-black text-indigo-600">{p.count}</span>{p.avgRating > 0 && <span className="text-sm font-bold text-yellow-500">â˜… {p.avgRating.toFixed(1)}</span>}</div>
                                        </div>
                                    ))}
                                    </div>
                                </div>
                                <div>
                                    <h2 className="text-2xl font-black dark:text-white mb-6">Library Composition</h2>
                                    <div className="h-4 bg-gray-200 dark:bg-gray-800 rounded-full overflow-hidden flex"><div className="bg-blue-500 h-full" style={{width: `${(allItems.filter(i=>i.Type==='movie').length / allItems.length * 100) || 0}%`}}></div><div className="bg-purple-500 h-full" style={{width: `${(allItems.filter(i=>i.Type==='series').length / allItems.length * 100) || 0}%`}}></div></div>
                                    <div className="flex justify-between text-xs text-gray-500 mt-2"><span className="flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-blue-500"></div> Movies ({allItems.filter(i=>i.Type==='movie').length})</span><span className="flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-purple-500"></div> TV Shows ({allItems.filter(i=>i.Type==='series').length})</span></div>
                                </div>
                            </div>
                        )}
                    </main>

                     {/* Detail Modal */}
                     {selectedMovie && (
                         <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-md">
                             <div className="bg-white dark:bg-dark-card w-full max-w-lg p-6 rounded-2xl relative max-h-[90vh] overflow-y-auto custom-scrollbar">
                                 {selectedMovie.tmdb?.enriched && (
                                     <div className="absolute top-0 left-0 w-full h-48 rounded-t-2xl z-0 overflow-hidden">
                                         <div className="absolute inset-0 bg-gradient-to-b from-transparent to-white dark:to-dark-card z-10"></div>
                                         <img src={tmdbImg(selectedMovie.tmdb.credits?.images?.backdrops?.[0]?.file_path, "w780") || getHighResPoster(selectedMovie.Poster, 800)} className="w-full h-full object-cover opacity-50" />
                                     </div>
                                 )}
                                 
                                 <button onClick={() => setSelectedMovie(null)} className="absolute top-4 right-4 text-gray-500 hover:text-white z-20"><X/></button>
                                 <div className="relative z-10 mt-20">
                                    <h2 className="text-3xl font-black dark:text-white mb-1 leading-tight">{selectedMovie.Title}</h2>
                                    <p className="text-xs text-gray-500 mb-4">{selectedMovie.Year} â€¢ {selectedMovie.Runtime}</p>
                                    
                                    {selectedMovie.meta.ratingsExternal && (
                                        <div className="flex flex-wrap gap-2 mb-6 text-xs font-bold">
                                            {selectedMovie.meta.ratingsExternal.imdb?.rating && selectedMovie.meta.ratingsExternal.imdb.rating !== "N/A" && (<span className="bg-yellow-400/20 text-yellow-600 px-2 py-1 rounded">IMDb {selectedMovie.meta.ratingsExternal.imdb.rating}</span>)}
                                            {selectedMovie.meta.ratingsExternal.rotten && (<span className="bg-red-400/20 text-red-600 px-2 py-1 rounded">ðŸ… {selectedMovie.meta.ratingsExternal.rotten}</span>)}
                                            {selectedMovie.meta.ratingsExternal.metacritic && (<span className="bg-green-400/20 text-green-600 px-2 py-1 rounded">MC {selectedMovie.meta.ratingsExternal.metacritic}</span>)}
                                            {/* MAL Badge */}
                                            {selectedMovie.meta.anime?.mal && (
                                                <a href={selectedMovie.meta.anime.mal.url} target="_blank" className="bg-blue-400/20 text-blue-600 px-2 py-1 rounded hover:bg-blue-400/30">MAL {selectedMovie.meta.anime.mal.rating || 'N/A'}</a>
                                            )}
                                            {/* MDL Badge */}
                                            {selectedMovie.meta?.asian?.mdl && (
                                                 <a href={selectedMovie.meta.asian.mdl.url} target="_blank" className="bg-teal-400/20 text-teal-600 px-2 py-1 rounded hover:bg-teal-400/30 flex items-center gap-1">MDL {selectedMovie.meta.asian.mdl.rating}<span className="text-[10px] opacity-70">({selectedMovie.meta.asian.mdl.votes} v)</span></a>
                                            )}
                                        </div>
                                    )}

                                    <div className="mb-6 text-sm text-gray-600 dark:text-gray-300">
                                        <p className="mb-2 italic opacity-80">{selectedMovie.Plot}</p>
                                        <div className="flex flex-wrap gap-2 text-xs">{selectedMovie.meta?.genre.map(g => <span key={g} className="px-2 py-1 bg-gray-100 dark:bg-gray-800 rounded-md">{g}</span>)}</div>
                                    </div>

                                    {selectedMovie.meta?.tvmaze && (
                                        <div className="mb-6 bg-gray-50 dark:bg-gray-800/50 p-3 rounded-lg border border-gray-100 dark:border-gray-700">
                                            <h3 className="text-xs font-bold text-gray-500 uppercase mb-2">TVMaze Data</h3>
                                            <div className="flex gap-4 text-xs dark:text-gray-300">
                                                <div><span className="font-bold">{selectedMovie.meta.tvmaze.episodes.length}</span> Ep. Known</div>
                                                <div><span className="font-bold">{selectedMovie.meta.tvmaze.cast.length}</span> Cast Known</div>
                                            </div>
                                        </div>
                                    )}

                                    <div className="mb-6">
                                        <h3 className="font-bold text-sm mb-3 dark:text-white flex items-center gap-2"><User size={14}/> Top Cast</h3>
                                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 text-sm">
                                            {selectedMovie.meta?.cast.map((a, idx) => (
                                            <div key={`${a.id || 'cast'}-${idx}`} onClick={() => { if(a.id) onActorClick(a) }} className={`flex gap-2 items-center group ${a.id ? 'cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800 rounded-lg p-1 transition-colors' : ''}`}>
                                                {a.photo ? (<img src={a.photo} className="w-10 h-10 rounded-full object-cover shadow-sm bg-gray-700" alt={a.name}/>) : (<div className="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center text-xs font-bold text-gray-500">{a.name.charAt(0)}</div>)}
                                                <div className="text-xs flex flex-col justify-center min-w-0"><div className="font-semibold text-gray-900 dark:text-white truncate group-hover:text-indigo-400 transition-colors">{a.name}</div><div className="text-gray-500 truncate">{a.character || "Actor"}</div></div>
                                            </div>
                                            ))}
                                        </div>
                                    </div>

                                    {selectedMovie.Type === "series" && (
                                        selectedMovie.meta?.series?.seasons && selectedMovie.meta.series.seasons.length > 0 ? (
                                            <div className="mb-6">
                                                <h3 className="font-bold text-sm mb-3 dark:text-white flex items-center gap-2"><Tv size={14}/> Episodes</h3>
                                                <div className="space-y-6">
                                                    {selectedMovie.meta.series.seasons.map(season => (
                                                    <div key={season.season} className="">
                                                        <div className="font-bold text-xs text-indigo-400 mb-2 border-b border-gray-100 dark:border-gray-800 pb-1 flex justify-between items-end"><span className="text-sm">Season {season.season}</span>{season.airDate && <span className="text-gray-500 font-normal">{season.airDate.substring(0,4)}</span>}</div>
                                                        <div className="space-y-3">
                                                        {season.episodes.map((ep, eIdx) => (
                                                            <div key={`${ep.episode}-${eIdx}`} className={`flex gap-3 group relative rounded-lg p-2 ${ep.watched ? 'bg-gray-50 dark:bg-gray-800/50' : ''}`}>
                                                                <div className="w-24 h-14 shrink-0 rounded overflow-hidden bg-gray-200 dark:bg-gray-800 relative">
                                                                    {ep.still ? (<img src={tmdbImg(ep.still, "w300")} className={`w-full h-full object-cover transition-opacity ${ep.watched ? 'opacity-50 grayscale' : ''}`} />) : (<div className="w-full h-full flex items-center justify-center text-gray-500 text-[10px]">No Image</div>)}
                                                                    <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 bg-black/40 transition-opacity cursor-pointer" onClick={() => toggleEpisode(selectedMovie.imdbID, season.season, ep.episode)}>{ep.watched ? <EyeOff className="text-white"/> : <Eye className="text-white"/>}</div>
                                                                </div>
                                                                <div className="flex-1 min-w-0 py-0.5">
                                                                    <div className="flex justify-between items-start"><span className={`text-sm font-medium truncate ${ep.watched ? 'text-gray-500 line-through' : 'text-gray-900 dark:text-white'}`}><span className="font-mono text-gray-400 mr-2 text-xs">{ep.episode}.</span>{ep.title}</span><div className="flex items-center gap-2">{ep.rating ? (<span className="text-yellow-500 text-xs font-bold">â˜… {ep.rating}</span>) : (<div className="opacity-0 group-hover:opacity-100 flex gap-0.5">{[1,2,3,4,5].map(r => (<button key={r} onClick={() => rateEpisode(selectedMovie.imdbID, season.season, ep.episode, r*2)} className="w-1.5 h-1.5 rounded-full bg-gray-300 hover:bg-yellow-500"></button>))}</div>)}</div></div>
                                                                    <p className="text-[10px] text-gray-500 mt-1 line-clamp-2">{ep.overview}</p>
                                                                    <div className="flex justify-between items-center mt-1"><span className="text-[10px] text-gray-400">{ep.airDate}</span>{ep.watched && <span className="text-[9px] text-green-500 font-medium bg-green-100 dark:bg-green-900/30 px-1.5 rounded">WATCHED</span>}</div>
                                                                </div>
                                                            </div>
                                                        ))}
                                                        </div>
                                                    </div>
                                                    ))}
                                                </div>
                                            </div>
                                        ) : (
                                            selectedMovie.meta?.episodes && (
                                                <div className="mb-6">
                                                    <h3 className="font-bold text-sm mb-3 dark:text-white">Episodes (OMDb Legacy)</h3>
                                                    <div className="text-xs text-gray-500">Upgrade to TMDB for richer data...</div>
                                                </div>
                                            )
                                        )
                                    )}
                                    
                                    <div className="mb-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                                        <div className="flex gap-2">
                                            {/* ADMIN: Buttons visible only to admin or personal edits if you prefer, but sticking to prompt 'Only Admin' usually implies control */}
                                            <button onClick={() => updateItem(selectedMovie.imdbID, i => ({...i, userMeta: {...i.userMeta, status: 'watched'}}))} className={`flex-1 py-3 rounded-xl border text-sm font-bold transition-all ${selectedMovie.userMeta?.status === 'watched' ? 'bg-green-500 text-white border-green-500 shadow-lg shadow-green-500/20' : 'dark:text-white border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-800'}`}>Watched</button>
                                            <button onClick={() => updateItem(selectedMovie.imdbID, i => ({...i, userMeta: {...i.userMeta, status: 'watchlist'}}))} className={`flex-1 py-3 rounded-xl border text-sm font-bold transition-all ${selectedMovie.userMeta?.status === 'watchlist' ? 'bg-blue-500 text-white border-blue-500 shadow-lg shadow-blue-500/20' : 'dark:text-white border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-800'}`}>Watchlist</button>
                                        </div>
                                    </div>
                                 </div>
                             </div>
                         </div>
                     )}

                    {actorModalData && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md animate-fade-in">
                            <div className="bg-white dark:bg-dark-card w-full max-w-2xl h-[80vh] rounded-2xl relative flex flex-col overflow-hidden">
                                <button onClick={() => setActorModalData(null)} className="absolute top-4 right-4 p-2 bg-black/20 rounded-full text-white hover:bg-black/40 z-10"><X/></button>
                                <div className="p-6 border-b border-gray-100 dark:border-gray-800 flex items-center gap-4 shrink-0 bg-white dark:bg-dark-card z-0 relative">
                                    <div className="w-16 h-16 rounded-full overflow-hidden bg-gray-200 shrink-0">{actorModalData.photo ? <img src={actorModalData.photo} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-xl font-bold text-gray-400">{actorModalData.name.charAt(0)}</div>}</div>
                                    <div><h2 className="text-2xl font-black dark:text-white">{actorModalData.name}</h2><p className="text-sm text-gray-500">Filmography</p></div>
                                </div>
                                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                                    <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                                        {actorModalData.credits.map((credit, cIdx) => (
                                            <div key={`${credit.id}-${cIdx}`} className="group relative">
                                                <div className="aspect-[2/3] bg-gray-800 rounded-lg overflow-hidden mb-2 relative">
                                                    <img src={tmdbImg(credit.poster_path, "w342")} className="w-full h-full object-cover group-hover:opacity-75 transition-opacity" loading="lazy"/>
                                                    <button onClick={(e) => { e.stopPropagation(); handleSearch(credit.title || credit.name); setActorModalData(null); }} className="absolute bottom-2 right-2 bg-indigo-600 text-white p-1.5 rounded-full opacity-0 group-hover:opacity-100 transition-opacity shadow-lg" title="Find in Vault"><Search size={12}/></button>
                                                </div>
                                                <h4 className="text-xs font-bold dark:text-white line-clamp-1">{credit.title || credit.name}</h4>
                                                <p className="text-[10px] text-gray-500">{credit.character}</p>
                                                <p className="text-[10px] text-gray-600">{(credit.release_date || credit.first_air_date || "").substring(0,4)}</p>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <SuggestionsModal isOpen={showSuggestionsModal} onClose={() => setShowSuggestionsModal(false)} suggestions={adminSuggestions} onApprove={handleApprove} onReject={handleReject} />

                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} apiKeys={apiKeys} setApiKeys={setApiKeys} theme={theme} setTheme={setTheme} 
                        onImport={handleImport}
                        onExport={handleExport}
                        onReset={async () => {
                          if (session) { await supabaseClient.from("vault_items").delete().eq("user_id", session.user.id); }
                          setVault({ watched: {}, watchlist: {} });
                          localStorage.removeItem("vault_v6_data");
                        }}
                    />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>