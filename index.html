<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Vault</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Plus Jakarta Sans', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        vault: {
                            950: '#050609',
                            900: '#0a0c12',
                            800: '#11141d',
                            700: '#1c2230',
                            accent: '#6366f1',
                            secondary: '#10b981',
                            gold: '#f59e0b'
                        }
                    },
                    animation: {
                        'float': 'float 6s ease-in-out infinite',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'reveal': 'reveal 0.6s cubic-bezier(0.16, 1, 0.3, 1)',
                        'gradientShift': 'gradientShift 6s ease infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        },
                        reveal: {
                            '0%': { opacity: '0', transform: 'translateY(40px) scale(0.95)' },
                            '100%': { opacity: '1', transform: 'translateY(0) scale(1)' },
                        },
                        gradientShift: {
                            '0%': { backgroundPosition: '0% 50%' },
                            '50%': { backgroundPosition: '100% 50%' },
                            '100%': { backgroundPosition: '0% 50%' },
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background:
                radial-gradient(circle at 20% 20%, rgba(99, 102, 241, 0.08), transparent 40%),
                radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.06), transparent 40%),
                linear-gradient(to bottom, #050609, #0a0c12);
            color: #e2e8f0;
            scrollbar-gutter: stable;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)' opacity='0.015'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 0;
        }

        h1,
        h2,
        h3 {
            letter-spacing: -0.02em;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0c12;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #1c2230, #2a3245);
            border-radius: 10px;
            border: 2px solid #0a0c12;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #6366f1, #8b5cf6);
        }

        .glass {
            background: rgba(17, 20, 29, 0.6);
            backdrop-filter: blur(16px) saturate(140%);
            -webkit-backdrop-filter: blur(16px) saturate(140%);
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
        }

        .text-gradient {
            background: linear-gradient(90deg, #818cf8, #c084fc, #10b981);
            background-size: 200% 200%;
            animation: gradientShift 6s ease infinite;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .profile-hero {
            position: relative;
            overflow: hidden;
        }

        .profile-hero::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 20% 30%, rgba(99, 102, 241, 0.15), transparent 50%),
                radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.1), transparent 50%);
            pointer-events: none;
        }

        .profile-hero::after {
            content: "";
            position: absolute;
            inset: 0;
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            background: linear-gradient(to bottom, transparent, rgba(5, 6, 9, 0.7));
            pointer-events: none;
        }

        .group:hover .media-glow {
            opacity: 1;
        }

        .media-glow {
            position: absolute;
            inset: -1px;
            border-radius: 1rem;
            background: radial-gradient(circle at top left, rgba(99, 102, 241, 0.3), transparent 60%);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 5;
        }

        .mask-fade-bottom {
            mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
        }

        input[type="range"] {
            accent-color: #6366f1;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>

<body class="selection:bg-indigo-500/30">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useCallback, useRef } = React;

        // --- MOCK SUPABASE (Fallback) ---
        const mockSupabase = {
            createClient: () => mockSupabase,
            from: () => ({
                select: () => Promise.resolve({ data: [] }),
                insert: () => Promise.resolve({ error: null }),
                update: () => Promise.resolve({ error: null }),
                delete: () => Promise.resolve({ error: null }),
                upsert: () => Promise.resolve({ error: null }),
                eq: () => ({ single: () => Promise.resolve({ data: null }) })
            }),
            auth: {
                getUser: () => Promise.resolve({ data: { user: null } }),
                getSession: () => Promise.resolve({ data: { session: null } }),
                onAuthStateChange: () => ({ data: { subscription: { unsubscribe: () => { } } } }),
                signInWithPassword: () => Promise.resolve({ error: { message: "Mock Mode" } }),
                signOut: () => Promise.resolve()
            },
            channel: () => ({
                on: () => ({ subscribe: () => { } })
            }),
            removeChannel: () => { }
        };

        const SUPABASE_URL = "https://ugllcdapuzihpkgcoaxj.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVnbGxjZGFwdXppaHBrZ2NvYXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0OTA3NzksImV4cCI6MjA4NjA2Njc3OX0.73I1cW1fqRUha5_6spK7C8m-SXUHQQfyjmcbNNbdfCI";

        const supabase = (window.supabase && window.supabase.createClient)
            ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
            : mockSupabase;

        const ADMIN_IDS = ["74e5b3ea-113f-4d6c-be2a-b0b52b2e92c3"];
        const DEFAULT_KEYS = { omdb: '5591108c', tmdb: '68b27c1f85725736f0aec18b903197b0', rapid: '9782bOaf7fmsh8b54c22e5cOaf5cp13e6e8jsn8e2e765657a5' };
        const RAPID_HOST_MDL = 'mydramalist-api.p.rapidapi.com';

        // --- STEP 1: ADD HOME TO VIEWS ---
        const VIEWS = {
            HOME: 'home',
            LIBRARY: 'library',
            MOVIES: 'movies',
            SERIES: 'series',
            PROFILE: 'profile'
        };

        const ASIAN_SOURCES = { MDL: 'mdl', MAL: 'mal' };
        const CACHE_CONFIG = { VERSION: 'v1', TTL_MS: 30 * 24 * 60 * 60 * 1000, PREFIX: 'cinestat_cache:', MAX_ENTRIES: 500 };

        const EAST_SE_ASIA_COUNTRIES = ['japan', 'south korea', 'north korea', 'korea', 'china', 'hong kong', 'taiwan', 'thailand', 'vietnam', 'philippines', 'malaysia', 'indonesia', 'singapore'];
        const EAST_SE_ASIA_LANGUAGES = ['japanese', 'korean', 'mandarin', 'cantonese', 'chinese', 'thai', 'vietnamese', 'malay', 'indonesian'];
        const WESTERN_COUNTRIES = ['united states', 'usa', 'canada', 'united kingdom', 'uk', 'england', 'france', 'germany', 'spain', 'australia'];
        const WESTERN_LANGUAGES = ['english', 'french', 'spanish', 'german', 'italian', 'portuguese'];

        const normalize = s => (s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        const now = () => Date.now();
        const isAdminUser = (user) => user && user.id && ADMIN_IDS.includes(user.id);

        async function safeFetch(url, options = {}, retries = 2) {
            try {
                const res = await fetch(url, options);
                if (!res.ok) return { error: true, status: res.status };
                return await res.json();
            } catch (e) {
                if (retries > 0) {
                    await new Promise(r => setTimeout(r, 400 * (3 - retries)));
                    return safeFetch(url, options, retries - 1);
                }
                return { error: true, status: 'network_error' };
            }
        }

        function humanizeReason(reason) {
            if (reason === 'exact-title') return 'Exact title match';
            if (reason.startsWith('fuzzy')) return `Title similarity ${reason.match(/\d+/)?.[0]}%`;
            if (reason === 'exact-year') return 'Exact release year';
            if (reason === 'near-year') return 'Close release year';
            if (reason.startsWith('popularity')) return 'Popular title';
            if (reason.includes('tmdb')) return 'Trusted source (TMDB)';
            if (reason.includes('tvmaze')) return 'Trusted source (TVMaze)';
            return reason;
        }

        const getHighResPoster = (url, width = 600) => {
            if (!url || url === "N/A") return "https://via.placeholder.com/300x450?text=No+Poster";
            if (url.includes("media-amazon.com")) return url.replace(/_V1_.*\.jpg$/, `_V1_SX${width}.jpg`);
            if (url.includes("tmdb.org")) return url.replace(/\/w\d+\//, width > 700 ? "/original/" : `/w${width}/`);
            return url;
        };

        const tmdbImg = (path, size = "w780") => path ? `https://image.tmdb.org/t/p/${size}${path}` : null;
        // --- NEW: Runtime Formatter (122 min -> 2h 2m) ---
        const formatRuntime = (runtime) => {
            if (!runtime || runtime === "N/A") return "N/A";
            // Extract number from string (e.g., "122 min" -> 122)
            const minutes = parseInt(runtime.toString().replace(/\D/g, '')) || 0;
            if (minutes === 0) return runtime;
            
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            
            if (h === 0) return `${m}m`;
            return `${h}h ${m}m`;
        };
        const formatCurrency = (val) => val ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(val) : 'N/A';
        const hashString = (str) => {
            let hash = 0;
            for (let i = 0; i < str.length; i++) { hash = (hash << 5) - hash + str.charCodeAt(i); hash |= 0; }
            return Math.abs(hash).toString(16);
        };

        function createStorage() {
            try {
                const k = '__test__';
                localStorage.setItem(k, '1');
                localStorage.removeItem(k);
                return { get: k => localStorage.getItem(k), set: (k, v) => localStorage.setItem(k, v), remove: k => localStorage.removeItem(k), keys: () => Object.keys(localStorage) };
            } catch {
                const mem = new Map();
                return { get: k => mem.get(k) || null, set: (k, v) => mem.set(k, v), remove: k => mem.delete(k), keys: () => Array.from(mem.keys()) };
            }
        }

        const storage = createStorage();

        function enforceCacheSize() {
            const keys = storage.keys().filter(k => k.startsWith(CACHE_CONFIG.PREFIX));
            if (keys.length <= CACHE_CONFIG.MAX_ENTRIES) return;
            const entries = keys.map(k => {
                try {
                    const e = JSON.parse(storage.get(k));
                    return { key: k, lastAccessed: e?.lastAccessed || 0 };
                } catch { return { key: k, lastAccessed: 0 }; }
            }).sort((a, b) => a.lastAccessed - b.lastAccessed);
            const overflow = entries.length - CACHE_CONFIG.MAX_ENTRIES;
            for (let i = 0; i < overflow; i++) storage.remove(entries[i].key);
        }

        function cacheSet(key, value) {
            const entry = { v: CACHE_CONFIG.VERSION, value, expiresAt: now() + CACHE_CONFIG.TTL_MS, lastAccessed: now() };
            storage.set(CACHE_CONFIG.PREFIX + key, JSON.stringify(entry));
            const cacheKeys = storage.keys().filter(k => k.startsWith(CACHE_CONFIG.PREFIX));
            if (cacheKeys.length > CACHE_CONFIG.MAX_ENTRIES) enforceCacheSize();
        }

        function cacheGet(key) {
            const raw = storage.get(CACHE_CONFIG.PREFIX + key);
            if (!raw) return null;
            try {
                const entry = JSON.parse(raw);
                if (entry.v !== CACHE_CONFIG.VERSION || now() > entry.expiresAt) { storage.remove(CACHE_CONFIG.PREFIX + key); return null; }
                entry.expiresAt = now() + CACHE_CONFIG.TTL_MS;
                entry.lastAccessed = now();
                storage.set(CACHE_CONFIG.PREFIX + key, JSON.stringify(entry));
                return entry.value;
            } catch { storage.remove(CACHE_CONFIG.PREFIX + key); return null; }
        }

        function cacheDelete(key) { storage.remove(CACHE_CONFIG.PREFIX + key); }
        function clearAllCache() { storage.keys().filter(k => k.startsWith(CACHE_CONFIG.PREFIX)).forEach(k => storage.remove(k)); }

        function evictExpiredEntries() {
            for (const key of storage.keys()) {
                if (!key.startsWith(CACHE_CONFIG.PREFIX)) continue;
                try {
                    const entry = JSON.parse(storage.get(key));
                    if (!entry || entry.v !== CACHE_CONFIG.VERSION || now() > entry.expiresAt) storage.remove(key);
                } catch { storage.remove(key); }
            }
        }

        function getCacheStats() {
            const keys = storage.keys().filter(k => k.startsWith(CACHE_CONFIG.PREFIX));
            let expired = 0;
            for (const k of keys) {
                try {
                    const e = JSON.parse(storage.get(k));
                    if (!e || now() > e.expiresAt) expired++;
                } catch { expired++; }
            }
            return { totalEntries: keys.length, expiredEntries: expired, maxEntries: CACHE_CONFIG.MAX_ENTRIES };
        }

        evictExpiredEntries();

        function useCacheStats() {
            const [stats, setStats] = useState(null);
            useEffect(() => { setStats(getCacheStats()); }, []);
            return stats;
        }

        // --- STEP 1: CREATE REALTIME LIBRARY HOOK ---
        function useRealtimeLibrary() {
            const [library, setLibrary] = useState([]);

            useEffect(() => {
                // Initial fetch
                supabase
                    .from('library')
                    .select('*')
                    .then(({ data }) => {
                        if (data) setLibrary(data);
                    });

                // Realtime subscription
                const channel = supabase
                    .channel('library-updates')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'library'
                        },
                        payload => {
                            if (payload.eventType === 'INSERT') {
                                setLibrary(prev => [payload.new, ...prev]);
                            }

                            if (payload.eventType === 'UPDATE') {
                                setLibrary(prev =>
                                    prev.map(item =>
                                        item.id === payload.new.id
                                            ? payload.new
                                            : item
                                    )
                                );
                            }

                            if (payload.eventType === 'DELETE') {
                                setLibrary(prev =>
                                    prev.filter(item =>
                                        item.id !== payload.old.id
                                    )
                                );
                            }
                        }
                    )
                    .subscribe();

                return () => {
                    supabase.removeChannel(channel);
                };
            }, []);

            return library;
        }

        function useAdminSuggestions(user) {
            const [suggestions, setSuggestions] = useState([]);

            useEffect(() => {
                if (!user || !isAdminUser(user)) return;

                // Initial fetch
                supabase
                    .from('suggestions')
                    .select('*')
                    .eq('status', 'pending')
                    .order('created_at', { ascending: false })
                    .then(({ data }) => {
                        if (data) setSuggestions(data);
                    });

                // Realtime subscription
                const channel = supabase
                    .channel('admin-suggestions')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'suggestions'
                        },
                        payload => {
                            if (payload.new?.status === 'pending') {
                                setSuggestions(prev => [payload.new, ...prev]);
                            }
                            if (payload.new?.status === 'approved' || payload.new?.status === 'rejected') {
                                setSuggestions(prev =>
                                    prev.filter(s => s.id !== payload.new.id)
                                );
                            }
                        }
                    )
                    .subscribe();

                return () => {
                    supabase.removeChannel(channel);
                };
            }, [user]);

            return suggestions;
        }

        function useUserSuggestions(user) {
            const [suggestions, setSuggestions] = useState([]);

            useEffect(() => {
                if (!user || isAdminUser(user)) return;

                // Initial fetch
                supabase
                    .from('suggestions')
                    .select('*')
                    .eq('suggested_by', user.id)
                    .order('created_at', { ascending: false })
                    .then(({ data }) => {
                        if (data) setSuggestions(data);
                    });

                // Realtime updates for this user's suggestions
                const channel = supabase
                    .channel('user-suggestions')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'suggestions',
                            filter: `suggested_by=eq.${user.id}`
                        },
                        payload => {
                            if (payload.eventType === 'INSERT') {
                                setSuggestions(prev => [payload.new, ...prev]);
                            }

                            if (payload.eventType === 'UPDATE') {
                                setSuggestions(prev =>
                                    prev.map(s =>
                                        s.id === payload.new.id ? payload.new : s
                                    )
                                );
                            }
                        }
                    )
                    .subscribe();

                return () => {
                    supabase.removeChannel(channel);
                };
            }, [user]);

            return suggestions;
        }

        // --- GLOBAL HELPER: Robust Vault Detection ---
        function isInVault(item, libraryItems) {
            // 1. Direct IMDb ID match (most reliable)
            if (item.imdbID) {
                const directMatch = libraryItems.some(lib => lib.imdbID === item.imdbID);
                if (directMatch) return true;
            }

            // 2. Fallback: Fuzzy Title + Year match (for TMDB items missing IMDb IDs)
            // Normalize current item
            const normTitle = normalizeTitle(item.Title || item.title || '');
            const year = extractYear(item);

            if (!normTitle) return false;

            return libraryItems.some(lib => {
                const libTitle = normalizeTitle(lib.Title || '');
                const libYear = extractYear(lib);
                // Require exact normalized title match and exact year match if both exist
                return libTitle === normTitle && (year && libYear ? libYear == year : true);
            });
        }

        function resolveEpisodeState(episodeId, watchHistory) {
            const record = watchHistory?.[episodeId];
            if (!record) return { state: 'unwatched', progress: 0 };
            if (record.watched === true) return { state: 'watched', progress: 1 };
            if (typeof record.progress === 'number' && record.progress > 0) return { state: 'partial', progress: record.progress };
            return { state: 'unwatched', progress: 0 };
        }

        function calculateEpisodeProgress({ episodes, watchHistory }) {
            let watchedEpisodes = 0, lastWatched = null, nextToWatch = null, hasGaps = false, gapDetected = false;
            if (!episodes || !Array.isArray(episodes)) return null;
            for (const ep of episodes) {
                const state = resolveEpisodeState(ep.id, watchHistory);
                if (state.state === 'watched') {
                    watchedEpisodes++;
                    lastWatched = { episodeId: ep.id, season: ep.season, episode: ep.episode };
                } else {
                    if (watchedEpisodes > 0 && !gapDetected) { hasGaps = true; gapDetected = true; }
                    if (!nextToWatch) nextToWatch = { episodeId: ep.id, season: ep.season, episode: ep.episode };
                }
            }
            const totalEpisodes = episodes.length;
            const completionPercent = totalEpisodes > 0 ? Math.round((watchedEpisodes / totalEpisodes) * 100) : 0;
            return { watchedEpisodes, totalEpisodes, completionPercent, lastWatched, nextToWatch, isCompleted: watchedEpisodes === totalEpisodes, hasGaps };
        }

        function detectSeasonGaps({ episodes, watchHistory }) {
            const seasons = {};
            for (const ep of episodes) {
                const state = resolveEpisodeState(ep.id, watchHistory);
                if (!seasons[ep.season]) seasons[ep.season] = { season: ep.season, watched: 0, skipped: 0, total: 0 };
                seasons[ep.season].total++;
                if (state.state === 'watched') seasons[ep.season].watched++;
                else seasons[ep.season].skipped++;
            }
            return Object.values(seasons).filter(s => s.watched > 0 && s.skipped > 0).sort((a, b) => a.season - b.season);
        }

        function getResumeTarget({ episodes, watchHistory }) {
            if (!episodes || !Array.isArray(episodes)) return null;
            for (const ep of episodes) {
                const state = resolveEpisodeState(ep.id, watchHistory);
                if (state.state === 'partial') return { episodeId: ep.id, season: ep.season, episode: ep.episode, resumeFrom: state.progress };
                if (state.state === 'unwatched') return { episodeId: ep.id, season: ep.season, episode: ep.episode, resumeFrom: 0 };
            }
            return null;
        }

        function calculateSeasonProgress({ episodes, watchHistory }) {
            if (!episodes || !Array.isArray(episodes)) return [];
            const seasons = {};
            for (const ep of episodes) {
                if (!seasons[ep.season]) seasons[ep.season] = { season: ep.season, watched: 0, partial: 0, total: 0 };
                const state = resolveEpisodeState(ep.id, watchHistory);
                seasons[ep.season].total++;
                if (state.state === 'watched') seasons[ep.season].watched++;
                if (state.state === 'partial') seasons[ep.season].partial++;
            }
            return Object.values(seasons).map(s => ({ ...s, completionPercent: s.total ? Math.round((s.watched / s.total) * 100) : 0 }));
        }

        function extractUserRatings(item) {
            if (!item.userMeta?.ratings) return [];
            return Object.values(item.userMeta.ratings)
                .filter(r => typeof r.rating === 'number' && typeof r.minutesWatched === 'number')
                .map(r => ({ imdbID: item.imdbID, rating: r.rating, minutesWatched: r.minutesWatched }));
        }

        function ratingConfidence(minutesWatched, minMinutes = 20) {
            if (minutesWatched < minMinutes) return 0;
            return Math.min(1, Math.log1p(minutesWatched) / Math.log1p(300));
        }

        function timeWeight(minutesWatched) { return Math.log1p(minutesWatched); }

        function calculateWeightedRating(ratings, options = {}) {
            const { minMinutes = 20, maxMinutesCap = null } = options;
            let weightedSum = 0, totalWeight = 0, contributingItems = 0;
            const breakdown = [];
            for (const r of ratings) {
                if (typeof r.rating !== 'number' || r.rating < 1 || r.rating > 10 || typeof r.minutesWatched !== 'number' || r.minutesWatched <= 0) continue;
                let minutes = r.minutesWatched;
                if (maxMinutesCap) minutes = Math.min(minutes, maxMinutesCap);
                const confidence = ratingConfidence(minutes, minMinutes);
                if (confidence === 0) continue;
                const weight = timeWeight(minutes) * confidence;
                const contribution = r.rating * weight;
                weightedSum += contribution;
                totalWeight += weight;
                contributingItems++;
                breakdown.push({ imdbID: r.imdbID, rating: r.rating, minutesWatched: minutes, confidence: Number(confidence.toFixed(2)), weight: Number(weight.toFixed(2)), contribution: Number(contribution.toFixed(2)) });
            }
            if (totalWeight === 0) return { weightedRating: 0, contributingItems: 0, breakdown: [] };
            return { weightedRating: Number((weightedSum / totalWeight).toFixed(2)), contributingItems, breakdown };
        }

        function extractGenres(genres) {
            if (!genres) return [];
            if (Array.isArray(genres)) return genres.map(g => g.toLowerCase().trim()).filter(Boolean);
            if (typeof genres === 'string') return genres.split(',').map(g => g.toLowerCase().trim()).filter(Boolean);
            return [];
        }

        function recencyWeight(lastWatchedAt, halfLifeDays = 180) {
            if (!lastWatchedAt) return 1;
            const ageDays = (Date.now() - lastWatchedAt) / (1000 * 60 * 60 * 24);
            return Math.exp(-ageDays / halfLifeDays);
        }

        function calculateFractionalGenreDistribution(items, options = {}) {
            const { useRecency = false, recencyHalfLifeDays = 180 } = options;
            const distribution = {};
            let totalWeight = 0;
            for (const item of items) {
                const genres = extractGenres(item.genres);
                if (genres.length === 0) continue;
                const baseWeight = timeWeight(item.minutesWatched);
                if (baseWeight === 0) continue;
                const recency = useRecency ? recencyWeight(item.lastWatchedAt, recencyHalfLifeDays) : 1;
                const weight = baseWeight * recency;
                const fractional = weight / genres.length;
                totalWeight += weight;
                for (const genre of genres) {
                    if (!distribution[genre]) distribution[genre] = 0;
                    distribution[genre] += fractional;
                }
            }
            return { distribution, totalWeight };
        }

        function normalizeGenreDistribution(distribution) {
            const total = Object.values(distribution).reduce((sum, v) => sum + v, 0);
            if (total === 0) return {};
            const normalized = {};
            for (const [genre, value] of Object.entries(distribution)) {
                normalized[genre] = Number(((value / total) * 100).toFixed(2));
            }
            return normalized;
        }

        function getGenreProfile(items, options = {}) {
            const { distribution, totalWeight } = calculateFractionalGenreDistribution(items, options);
            return { raw: distribution, percent: normalizeGenreDistribution(distribution), totalWeight };
        }

        function extractGenreItems(items) {
            return items
                .filter(i => typeof i.minutesWatched === 'number' && i.minutesWatched > 0 && i.Genre)
                .map(i => ({ genres: i.Genre, minutesWatched: i.minutesWatched, lastWatchedAt: i.userMeta?.lastWatchedAt }));
        }

        function genreAffinityScore(item, preferredGenres) {
            const itemGenres = extractGenres(item.Genre);
            if (!itemGenres.length) return 0;
            return itemGenres.reduce((score, g) => score + (preferredGenres.includes(g) ? 1 : 0), 0);
        }

        function buildProgressMap(items) {
            const map = {};
            items.forEach(item => {
                if (!item.imdbID) return;
                const minutes = item.minutesWatched ?? item.userMeta?.minutesWatched ?? 0;
                map[item.imdbID] = {
                    watchedEpisodes: item.userMeta?.watchedEpisodes,
                    totalEpisodes: item.userMeta?.totalEpisodes,
                    isCompleted: item.userMeta?.status === 'watched',
                    minutesWatched: minutes
                };
            });
            return map;
        }

        function extractActorItems(items) {
            return items.filter(i => Array.isArray(i.meta?.cast) && i.meta.cast.length > 0 && (typeof i.minutesWatched === 'number' || typeof i.userMeta?.minutesWatched === 'number'));
        }

        function normalizeActor(name) { return name.toLowerCase().replace(/\s+/g, ' ').trim(); }

        function completionWeight(progress) {
            if (!progress) return 0;
            if (progress.isCompleted === true) return 1;
            if (typeof progress.watchedEpisodes === 'number' && typeof progress.totalEpisodes === 'number' && progress.totalEpisodes > 0) {
                const ratio = progress.watchedEpisodes / progress.totalEpisodes;
                return Math.pow(ratio, 0.7);
            }
            return 0;
        }

        function roleWeight(order) {
            if (order === undefined || order === null) return 1;
            if (order === 0) return 1.5;
            if (order <= 3) return 1.2;
            if (order <= 10) return 1;
            return 0.6;
        }

        function calculateActorPopularity({ items, progressMap }) {
            const actorScores = {};
            for (const item of items) {
                const progress = progressMap[item.imdbID];
                const cast = item.meta?.cast || item.cast || [];
                if (!progress || !Array.isArray(cast)) continue;
                const minutes = progress.minutesWatched ?? 0;
                if (minutes === 0) continue;
                const completion = completionWeight(progress);
                if (completion === 0) continue;
                const time = timeWeight(minutes);
                if (time === 0) continue;
                const itemWeight = completion * time;
                for (const actor of cast) {
                    const key = normalizeActor(actor.name);
                    const rWeight = roleWeight(actor.order);
                    if (!actorScores[key]) actorScores[key] = 0;
                    actorScores[key] += itemWeight * rWeight;
                }
            }
            return actorScores;
        }

        function normalizeActorPopularity(actorScores) {
            const total = Object.values(actorScores).reduce((sum, v) => sum + v, 0);
            if (total === 0) return {};
            const normalized = {};
            for (const [actor, score] of Object.entries(actorScores)) {
                normalized[actor] = Number(((score / total) * 100).toFixed(2));
            }
            return normalized;
        }

        function getActorPopularityProfile({ items, progressMap }) {
            const raw = calculateActorPopularity({ items, progressMap });
            return { raw, percent: normalizeActorPopularity(raw) };
        }

        function actorAffinityScore(item, favoriteActors) {
            if (!Array.isArray(item.meta?.cast)) return 0;
            return item.meta.cast.reduce((score, actor) => {
                const name = normalizeActor(actor.name);
                if (!favoriteActors.includes(name)) return score;
                if (actor.order === 0) return score + 2;
                if (actor.order <= 3) return score + 1;
                return score + 0.5;
            }, 0);
        }

        function normalizeQuery(query) {
            if (!query) return '';
            return query.toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9\s]/g, ' ').replace(/\b(the|a|an)\b/g, ' ').replace(/\s+/g, ' ').trim();
        }

        function canonicalizeQuery(query) { return normalizeQuery(query).split(' ').filter(Boolean).sort().join(' '); }

        function normalizeType(type) {
            if (!type) return '';
            const t = type.toLowerCase();
            if (t === 'tv' || t === 'series' || t === 'show') return 'series';
            if (t === 'movie' || t === 'film') return 'movie';
            if (t === 'anime') return 'anime';
            return t;
        }

        function normalizeYear(year) {
            if (!year) return '';
            const y = String(year).trim();
            return /^\d{4}$/.test(y) ? y : '';
        }

        function normalizeTitle(str) { return (str || '').toLowerCase().replace(/[^a-z0-9\s]/g, '').trim(); }
        function tokenize(title) { return normalizeTitle(title).split(/\s+/).filter(Boolean); }

        function tokenSimilarity(a, b) {
            const A = new Set(tokenize(a));
            const B = new Set(tokenize(b));
            if (A.size === 0 || B.size === 0) return 0;
            let intersection = 0;
            for (const t of A) if (B.has(t)) intersection++;
            return intersection / Math.max(A.size, B.size);
        }

        function extractYear(item) {
            return (
                item.Year || item.year || item.release_date?.slice(0, 4) || item.first_air_date?.slice(0, 4) || item.premiered?.slice(0, 4) || null
            );
        }

        function extractPopularity(item, index) {
            if (typeof item.popularity === 'number') return item.popularity;
            if (typeof item.imdbVotes === 'string') {
                return parseInt(item.imdbVotes.replace(/,/g, ''), 10) || 0;
            }
            return Math.max(0, 100 - index);
        }

        function extractVoteCount(item) {
            if (item.raw?.imdbVotes) {
                return parseInt(item.raw.imdbVotes.replace(/,/g, ''), 10) || 0;
            }
            if (typeof item.raw?.vote_count === 'number') {
                return item.raw.vote_count;
            }
            return 0;
        }

        function scoreCandidate({ item, query, targetYear, titleKey = 'title', index }) {
            let score = 0;
            const reasons = [];
            const queryNorm = normalizeTitle(query);
            const title = item[titleKey] || '';
            const titleNorm = normalizeTitle(title);
            const year = extractYear(item);

            if (titleNorm === queryNorm) { score += 50; reasons.push('exact-title'); }
            const similarity = tokenSimilarity(title, query);
            if (similarity > 0) {
                const fuzzyScore = Math.round(similarity * 35);
                score += fuzzyScore;
                reasons.push(`fuzzy(${fuzzyScore})`);
            }
            if (targetYear && year) {
                if (year == targetYear) { score += 25; reasons.push('exact-year'); }
                else if (Math.abs(year - targetYear) === 1) { score += 15; reasons.push('near-year'); }
            }
            const pop = extractPopularity(item, index);
            if (pop > 0) {
                const popScore = Math.min(10, Math.round(pop / 100));
                score += popScore;
                reasons.push(`popularity(${popScore})`);
            }
            if (item.source === 'tvmaze') score += 5;
            if (item.source === 'tmdb') { score += 5; reasons.push('source(tmdb)'); }
            return { item, score, reasons };
        }

        async function getExternalMapping(imdbID, supabase) {
            const { data } = await supabase.from('imdb_external_map').select('source, source_id').eq('imdb_id', imdbID).single();
            return data || null;
        }

        async function getRegistryEntry(source, sourceId, supabase) {
            const { data } = await supabase.from('asian_external_registry').select('*').eq('source', source).eq('source_id', sourceId).single();
            return data || null;
        }

        async function adminUpsertRegistry(entry, isAdmin, supabase) {
            if (!isAdmin) { console.warn("Registry override blocked: non-admin"); return; }
            await supabase.from('asian_external_registry').upsert({ ...entry, updated_at: new Date(), overridden_by: 'admin' });
        }

        async function adminPersistIMDbMapping(imdbID, source, sourceId, isAdmin, supabase) {
            if (!isAdmin) return;
            await supabase.from('imdb_external_map').upsert({ imdb_id: imdbID, source, source_id: sourceId, updated_at: new Date() });
        }

        async function fetchMDLDetail(id, apiKey) {
            return safeFetch(`https://${RAPID_HOST_MDL}/title/${id}`, { headers: { 'X-RapidAPI-Key': apiKey, 'X-RapidAPI-Host': RAPID_HOST_MDL } });
        }

        async function resolveMDLExternally(title, apiKey) {
            if (!apiKey) return null;
            const search = await searchMDL(title, apiKey);
            const found = search?.results?.[0];
            if (!found || found.error) return null;
            const detail = await fetchMDLDetail(found.id, apiKey);
            if (!detail || detail.error) return null;
            return { source_id: found.id, title: detail.title, rating: detail.score, votes: detail.votes, payload: detail };
        }

        async function resolveMALExternally(title) {
            const res = await searchJikan(title);
            if (!res || res.error) return null;
            const anime = res.data?.[0];
            if (!anime) return null;
            return { source_id: anime.mal_id, title: anime.title, rating: anime.score, votes: anime.scored_by, payload: anime };
        }

        async function resolveAsianRegistry({ imdbID, title, preferredSource, supabase, apiKeys, isAdmin }) {
            if (!imdbID || !title) return null;
            try {
                const mapping = await getExternalMapping(imdbID, supabase);
                if (mapping?.overridden_by === 'admin') {
                    const cached = await getRegistryEntry(mapping.source, mapping.source_id, supabase);
                    if (cached) return { ...cached.payload, _registry_source: 'cache' };
                }
                if (mapping && mapping.source === preferredSource) {
                    const cached = await getRegistryEntry(mapping.source, mapping.source_id, supabase);
                    if (cached) return { ...cached.payload, _registry_source: 'cache' };
                }
            } catch (e) { }

            let resolved = null;
            if (preferredSource === ASIAN_SOURCES.MDL) { resolved = await resolveMDLExternally(title, apiKeys.rapid); }
            if (preferredSource === ASIAN_SOURCES.MAL) { resolved = await resolveMALExternally(title); }
            if (!resolved) return null;

            try {
                if (isAdmin) {
                    await adminUpsertRegistry({ source: preferredSource, source_id: resolved.source_id, payload: resolved }, isAdmin, supabase);
                    await adminPersistIMDbMapping(imdbID, preferredSource, resolved.source_id, isAdmin, supabase);
                }
            } catch (e) { console.warn("Registry Persist Failed", e); }

            return { id: resolved.source_id, title: resolved.title, rating: resolved.rating, votes: resolved.votes, raw: resolved.payload, source: preferredSource, _registry_source: 'api' };
        }

        function containsAny(haystack, needles) { return needles.some(term => haystack.includes(term)); }

        function scoreAsianOrigin({ Country, Language, Genre }) {
            const country = normalizeOrigin(Country);
            const language = normalizeOrigin(Language);
            const genre = normalizeOrigin(Genre);
            const blob = `${country} ${language}`;
            let score = 0;
            const reasons = [];

            if (containsAny(country, EAST_SE_ASIA_COUNTRIES)) { score += 50; reasons.push('asian-country'); }
            if (containsAny(language, EAST_SE_ASIA_LANGUAGES)) { score += 40; reasons.push('asian-language'); }
            if (/drama|anime/.test(genre)) { score += 10; reasons.push('genre-hint'); }
            if (containsAny(country, WESTERN_COUNTRIES)) { score -= 60; reasons.push('western-country'); }
            if (containsAny(language, WESTERN_LANGUAGES)) { score -= 40; reasons.push('western-language'); }
            if (/animation/.test(genre)) {
                if (containsAny(blob, WESTERN_COUNTRIES) || containsAny(blob, WESTERN_LANGUAGES)) {
                    score -= 50;
                    reasons.push('western-animation-block');
                }
            }
            return { score, reasons };
        }

        function normalizeOrigin(str) { return (str || '').toLowerCase().replace(/[^a-z\s]/g, ' ').replace(/\s+/g, ' ').trim(); }

        function detectAsianOrigin(item, options = {}) {
            const { threshold = 50, debug = false } = options;
            const { score, reasons } = scoreAsianOrigin(item);
            const isAsian = score >= threshold;
            if (debug) return { isAsian, score, reasons };
            return isAsian;
        }

        function classifyForEnrichment(item) {
            return {
                isSeries: item.Type === 'series',
                isAnimation: /Animation/i.test(item.Genre || ''),
                isAsian: detectAsianOrigin(item)
            };
        }

        async function enrichAnime(item, ctx, supabase, isAdmin) {
            if (!ctx.isAnimation || item.meta?.anime) return null;
            const anime = await resolveAsianRegistry({ imdbID: item.imdbID, title: item.Title, preferredSource: ASIAN_SOURCES.MAL, supabase, apiKeys: {}, isAdmin });
            if (!anime) return null;
            return { anime: { malId: anime.id || anime.mal_id, score: anime.score, studios: anime.studios?.map(s => s.name) || [], confidence: 0.9 } };
        }

        async function enrichTVMaze(item, ctx) {
            if (!ctx.isSeries || item.meta?.tvmaze) return null;
            const cacheKey = `tvmaze_${item.imdbID}`;
            const cached = cacheGet(cacheKey);
            if (cached) return { ...cached, _fromCache: true };
            const show = await safeFetch(`https://api.tvmaze.com/lookup/shows?imdb=${item.imdbID}`);
            if (!show || show.error) return null;
            const [episodes, cast] = await Promise.all([
                safeFetch(`https://api.tvmaze.com/shows/${show.id}/episodes`),
                safeFetch(`https://api.tvmaze.com/shows/${show.id}/cast`)
            ]);
            const result = { tvmaze: { id: show.id, episodes: episodes.error ? [] : episodes, cast: cast.error ? [] : cast, confidence: 0.95 } };
            cacheSet(cacheKey, result);
            return { ...result, _fromCache: false };
        }

        async function resolveMDL(item, ctx, supabase, apiKeys, isAdmin) {
            if (!ctx.isAsian || item.meta?.asian) return null;
            const mdl = await resolveAsianRegistry({ imdbID: item.imdbID, title: item.Title, preferredSource: ASIAN_SOURCES.MDL, supabase, apiKeys, isAdmin });
            if (!mdl) return null;
            return { asian: { mdl: { id: mdl.id, title: mdl.title, rating: mdl.score || mdl.rating, votes: mdl.votes, url: `https://mydramalist.com/${mdl.id}`, confidence: 0.9 } } };
        }

        async function enrichTMDB(item, ctx, apiKeys) {
            if (!apiKeys.tmdb) return null;
            let tmdbId = item.tmdb?.id;
            let tmdbData = null;
            const cacheKey = `tmdb_enrich_${item.imdbID}`;
            const cached = cacheGet(cacheKey);
            if (cached) return { ...cached, _fromCache: true };

            if (!tmdbId) {
                const find = await safeFetch(`https://api.themoviedb.org/3/find/${item.imdbID}?api_key=${apiKeys.tmdb}&external_source=imdb_id`);
                if (find && !find.error) {
                    tmdbData = ctx.isSeries ? find?.tv_results?.[0] : find?.movie_results?.[0];
                    if (tmdbData) tmdbId = tmdbData.id;
                }
            }
            if (!tmdbId) return null;

            // FIX: Fetch details for BOTH Movies and Series (to get Revenue/Production)
            const [credits, details, images] = await Promise.all([
                safeFetch(`https://api.themoviedb.org/3/${ctx.isSeries ? 'tv' : 'movie'}/${tmdbId}/credits?api_key=${apiKeys.tmdb}`),
                safeFetch(`https://api.themoviedb.org/3/${ctx.isSeries ? 'tv' : 'movie'}/${tmdbId}?api_key=${apiKeys.tmdb}`), 
                safeFetch(`https://api.themoviedb.org/3/${ctx.isSeries ? 'tv' : 'movie'}/${tmdbId}/images?api_key=${apiKeys.tmdb}`)
            ]);

            const result = {
                tmdb: {
                    id: tmdbId,
                    cast: credits && !credits.error ? (credits.cast || []) : [],
                    director: credits && !credits.error ? (credits.crew?.filter(c => c.job === 'Director').map(d => d.name) || []) : [],
                    // Store raw details to backfill BoxOffice/Production later
                    details: details && !details.error ? details : null, 
                    seasons: ctx.isSeries && details && !details.error ? details.seasons : null,
                    credits: { images: { backdrops: images && !images.error ? (images.backdrops || []) : [] } },
                    confidence: 0.95
                }
            };
            cacheSet(cacheKey, result);
            return { ...result, _fromCache: false };
        }
       
        // --- NEW: Repair Function for Missing Basics ---
        async function repairBasics(item, apiKeys) {
            // Only run if we have an OMDb key and the item has an ID
            if (!apiKeys.omdb || !item.imdbID) return null;
            
            const isMissing = (val) => !val || val === "N/A" || val === "";
            
            // Check if essential fields are missing (Director, Writer, Rating, Plot)
            if (isMissing(item.Director) || isMissing(item.Writer) || isMissing(item.Plot) || isMissing(item.imdbRating)) {
                
                // Fetch fresh OMDb data
                const data = await safeFetch(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${item.imdbID}&plot=full`);
                
                if (data && data.Response === "True") {
                    return {
                        // Return standard fields to update at the root level
                        Director: data.Director,
                        Writer: data.Writer,
                        Plot: data.Plot,
                        imdbRating: data.imdbRating, // Updates the main rating
                        Rated: data.Rated,
                        Runtime: data.Runtime,
                        Released: data.Released,
                        Genre: data.Genre,
                        Actors: data.Actors,
                        Language: data.Language,
                        Country: data.Country,
                        Awards: data.Awards,
                        // Mark as a basic repair so we know how to merge it later
                        _basicsRepaired: true 
                    };
                }
            }
            return null;
        }

        // --- UPDATED: Main Enrichment Function ---
        async function enrichItem(item, apiKeys, supabase, isAdmin) {
            const ctx = classifyForEnrichment(item);
            const meta = { ...(item.meta || {}) };
            let tmdbData = { ...(item.tmdb || {}) };
            let rootUpdates = {}; // Store updates for top-level fields (Director, etc.)
            const provenance = [];
            let isInstant = false;

            const stages = [
                // 1. First Priority: Repair missing basics (Director, Ratings, etc.)
                () => repairBasics(item, apiKeys),
                // 2. Then fetch extras
                () => enrichAnime(item, ctx, supabase, isAdmin),
                () => enrichTVMaze(item, ctx),
                () => resolveMDL(item, ctx, supabase, apiKeys, isAdmin),
                () => enrichTMDB(item, ctx, apiKeys)
            ];

            const results = await Promise.allSettled(stages.map(s => s()));

            // ... inside enrichItem ...
            results.forEach(res => {
                if (res.status === 'fulfilled' && res.value) {
                    const result = res.value;

                    if (result._basicsRepaired) {
                        delete result._basicsRepaired;
                        Object.assign(rootUpdates, result);
                        provenance.push('omdb_repair');
                    } else {
                        if (result._fromCache) isInstant = true;
                        
                        // --- NEW: Map TMDB Details to Root Fields if missing ---
                        if (result.tmdb && result.tmdb.details) {
                            const d = result.tmdb.details;
                            
                            // Backfill Box Office
                            if ((!item.BoxOffice || item.BoxOffice === 'N/A') && d.revenue > 0) {
                                rootUpdates.BoxOffice = formatCurrency(d.revenue);
                            }
                            
                            // Backfill Production
                            if ((!item.Production || item.Production === 'N/A') && d.production_companies?.length > 0) {
                                rootUpdates.Production = d.production_companies.map(c => c.name).join(', ');
                            }
                            
                            // Backfill Runtime if missing
                            if ((!item.Runtime || item.Runtime === 'N/A') && d.runtime > 0) {
                                rootUpdates.Runtime = `${d.runtime} min`;
                            }

                            // Merge the rest of TMDB data
                            tmdbData = { ...tmdbData, ...result.tmdb };
                            delete result.tmdb; // Don't double merge
                        }
                        
                        if (result.tmdb) { 
                            tmdbData = { ...tmdbData, ...result.tmdb }; 
                            delete result.tmdb; 
                        }
                        
                        Object.assign(meta, result);
                        provenance.push(...Object.keys(result));
                    }
                } 
                // ... error handling ...
            });

            // If we found TMDB Cast, merge it intelligently
            if (tmdbData.cast) {
                const newCast = tmdbData.cast.map(c => ({ name: c.name, character: c.character, photo: c.profile_path ? `https://image.tmdb.org/t/p/w185${c.profile_path}` : null }));
                const combined = [...(meta.cast || []), ...newCast];
                const seen = new Set();
                meta.cast = combined.filter(a => {
                    const k = normalizeActor(a.name);
                    if (seen.has(k)) return false;
                    seen.add(k);
                    return true;
                });
            }

            // Return the item with Root updates merged at the top level, and Meta updates in .meta
            return { 
                ...item, 
                ...rootUpdates, // Apply Director, Writer, Ratings fixes here
                meta, 
                tmdb: tmdbData, 
                enrichmentSources: provenance, 
                enriched: true, 
                _fromCache: isInstant 
            };
        }

        // --- SEARCH API WRAPPERS & NORMALIZATION ---
        async function searchTMDB(query, year, type = 'movie', apiKey) {
            if (!apiKey) return null;
            const endpoint = type === 'series' ? 'search/tv' : 'search/movie';
            let url = `https://api.themoviedb.org/3/${endpoint}?api_key=${apiKey}&query=${encodeURIComponent(query)}`;
            if (year) { url += type === 'series' ? `&first_air_date_year=${year}` : `&year=${year}`; }
            return safeFetch(url);
        }

        async function searchTVMaze(query) {
            const url = `https://api.tvmaze.com/search/shows?q=${encodeURIComponent(query)}`;
            return safeFetch(url);
        }

        async function searchOMDB(query, year, type = 'movie', apiKey) {
            if (!apiKey) return null;
            let url = `https://www.omdbapi.com/?apikey=${apiKey}&s=${encodeURIComponent(query)}&type=${type === 'series' ? 'series' : 'movie'}`;
            if (year) url += `&y=${year}`;
            return safeFetch(url);
        }

        async function searchJikan(query) {
            const url = `https://api.jikan.moe/v4/anime?q=${encodeURIComponent(query)}&limit=5`;
            return safeFetch(url);
        }

        async function searchMDL(query, apiKey) {
            if (!apiKey) return null;
            return safeFetch(`https://${RAPID_HOST_MDL}/search/title?q=${encodeURIComponent(query)}`, { headers: { 'X-RapidAPI-Key': apiKey, 'X-RapidAPI-Host': RAPID_HOST_MDL } });
        }

        function normalizeCandidate(raw, source) {
            let type = 'movie';
            if (source === 'tvmaze' || source === 'jikan' || source === 'mdl') type = 'series';
            if (source === 'omdb' && raw.Type === 'series') type = 'series';
            if (source === 'tmdb' && (raw.media_type === 'tv' || raw.first_air_date)) type = 'series';

            return {
                source,
                title: raw.title || raw.name || raw.Title,
                year: raw.premiered?.slice(0, 4) || raw.release_date?.slice(0, 4) || raw.first_air_date?.slice(0, 4) || raw.Year || null,
                imdbID: raw.external_ids?.imdb_id || raw.externals?.imdb || raw.imdbID || null, // Updated to look for injected ID
                tmdbID: source === 'tmdb' ? raw.id : null,
                plot: raw.summary?.replace(/<[^>]+>/g, '') || raw.overview || raw.Plot || null,
                poster: raw.image?.original || (raw.poster_path ? `https://image.tmdb.org/t/p/w500${raw.poster_path}` : raw.Poster) || null,
                type: type,
                popularity: raw.popularity,
                imdbVotes: raw.imdbVotes,
                raw,
                _sourceMeta: { source, fetchedAt: Date.now() }
            };
        }

        // 2. Fix Clustering Logic (Soft Key Fallback)
        function reconcile(candidates) {
            const imdbMap = {};
            const softMap = {};
            const processed = new Set();

            // 1. Cluster by IMDb ID
            candidates.forEach((c, idx) => {
                if (c.imdbID) {
                    if (!imdbMap[c.imdbID]) imdbMap[c.imdbID] = [];
                    imdbMap[c.imdbID].push(c);
                    processed.add(idx);
                }
            });

            // 2. Cluster remaining by Soft Key (Title + Year + Type)
            candidates.forEach((c, idx) => {
                if (processed.has(idx)) return;
                const nTitle = normalizeTitle(c.title);
                const key = `${nTitle}|${c.year || 'NA'}|${c.type}`;
                if (!softMap[key]) softMap[key] = [];
                softMap[key].push(c);
            });

            return [...Object.values(imdbMap), ...Object.values(softMap)];
        }

        function mergeBest(cluster) {
            cluster.sort((a, b) => b.score - a.score);
            const pick = field => cluster.find(c => c[field])?.[field] || null;
            const primary = cluster[0];
            return {
                Title: pick('title'),
                Year: pick('year'),
                imdbID: pick('imdbID'),
                Type: primary.type,
                Plot: pick('plot'),
                Poster: pick('poster'),
                tmdb: primary.tmdbID ? { id: primary.tmdbID } : null,
                sourcesUsed: cluster.map(c => c.source),
                confidence: primary.score,
                _searchDebug: { score: primary.score, reasons: primary.reasons || [] },
                raw: primary.raw // Ensure raw data is passed for vote extraction
            };
        }

        async function smartSearch(query, apiKeys, type = 'all', year = null) {
            const q = query.trim();
            const wrappedPromises = [];
            if (type === 'all' || type === 'movie') wrappedPromises.push(searchTMDB(q, year, 'movie', apiKeys.tmdb).then(v => ({ v, s: 'tmdb' })));
            if (type === 'all' || type === 'series') wrappedPromises.push(searchTMDB(q, year, 'series', apiKeys.tmdb).then(v => ({ v, s: 'tmdb' })));
            if (type === 'all' || type === 'series') wrappedPromises.push(searchTVMaze(q).then(v => ({ v, s: 'tvmaze' })));
            if (type === 'all' || type === 'movie') wrappedPromises.push(searchOMDB(q, year, 'movie', apiKeys.omdb).then(v => ({ v, s: 'omdb' })));
            if (type === 'all' || type === 'series') wrappedPromises.push(searchOMDB(q, year, 'series', apiKeys.omdb).then(v => ({ v, s: 'omdb' })));
            if (type === 'all' || type === 'series') wrappedPromises.push(searchJikan(q).then(v => ({ v, s: 'jikan' })));
            if (type === 'all' || type === 'series') wrappedPromises.push(searchMDL(q, apiKeys.rapid).then(v => ({ v, s: 'mdl' })));

            const wrappedResults = await Promise.allSettled(wrappedPromises);
            const rawCandidates = [];

            // 1. Fix #1: Async TMDB ID Fetching inside search loop
            for (const res of wrappedResults) {
                if (res.status === 'fulfilled' && res.value?.v && !res.value.v.error) {
                    const val = res.value.v;
                    let list = [];
                    if (res.value.s === 'tmdb') {
                        list = val.results || [];
                        // Async fetch external IDs for TMDB results
                        if (apiKeys.tmdb) {
                            list = await Promise.all(list.map(async (item) => {
                                const t = item.media_type === 'tv' || item.first_air_date ? 'tv' : 'movie';
                                const ext = await safeFetch(`https://api.themoviedb.org/3/${t}/${item.id}/external_ids?api_key=${apiKeys.tmdb}`);
                                if (ext?.imdb_id) item.external_ids = { imdb_id: ext.imdb_id };
                                return item;
                            }));
                        }
                    }
                    else if (res.value.s === 'tvmaze') list = val.map(v => v.show) || [];
                    else if (res.value.s === 'omdb') list = val.Search || [];
                    else if (res.value.s === 'jikan') list = val.data || [];
                    else if (res.value.s === 'mdl') list = val.results || [];

                    list.forEach(item => rawCandidates.push(normalizeCandidate(item, res.value.s)));
                }
            }

            if (rawCandidates.length === 0) return { primary: [], more: [] };
            rawCandidates.forEach((c, index) => {
                const result = scoreCandidate({ item: c, query: q, targetYear: year, titleKey: 'title', index: index });
                c.score = result.score;
                c.reasons = result.reasons;
            });

            const clusters = reconcile(rawCandidates);
            const mergedResults = clusters.map(cluster => mergeBest(cluster));

            // --- ENHANCED RANKING & SPLITTING LOGIC ---
            mergedResults.forEach(item => {
                item.voteCount = extractVoteCount(item);
                item.hasPoster = !!item.Poster && item.Poster !== "N/A";
                // Elite ranking calculation: log(votes)*2 + confidence
                item.eliteScore = (Math.log(item.voteCount || 1) * 2) + item.confidence;
            });

            const main = mergedResults
                .filter(item => item.voteCount >= 1000 && item.hasPoster)
                .sort((a, b) => b.eliteScore - a.eliteScore); // Primary sorted by elite ranking

            const more = mergedResults
                .filter(item => item.voteCount < 1000 || !item.hasPoster)
                .sort((a, b) => b.voteCount - a.voteCount); // Secondary sorted by raw votes

            return {
                primary: main,
                more: more
            };
        }

        // ==========================================
        // SECTION 5: UI PRIMITIVES & COMPONENTS
        // ==========================================

        const VaultLogo = ({ size = 28, className = "", spokeCount = 6, animated = false, title = "Vault Logo" }) => {
            const center = 50; const outerR = 36; const midR = 28; const innerR = 20; const strokeOuter = 5; const strokeInner = 3;
            return (
                <svg width={size} height={size} viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" role="img" aria-label={title} className={className}>
                    <title>{title}</title>
                    {/* Side Lock Bar */}
                    <rect x="6" y="35" width="8" height="30" rx="1" fill="currentColor" />
                    <rect x="14" y="40" width="6" height="6" fill="currentColor" />
                    <rect x="14" y="54" width="6" height="6" fill="currentColor" />
                    {/* Outer Rings */}

                    <circle cx={center} cy={center} r={outerR} stroke="currentColor" strokeWidth={strokeOuter} />
                    <circle cx={center} cy={center} r={midR} stroke="currentColor" strokeWidth={strokeInner} strokeDasharray="1 14" strokeLinecap="round" opacity="0.8" />
                    <circle cx={center} cy={center} r={innerR} stroke="currentColor" strokeWidth={strokeInner} />
                    {/* Rotating Lock Wheel */}
                    <g
                        className={animated ? "origin-center animate-spin" : ""}
                        style={{ transformOrigin: "50px 50px" }}
                    >
                        {Array.from({ length: spokeCount }).map((_, i) => {
                            const deg = (360 / spokeCount) * i;
                            return (
                                <line key={i} x1="50" y1="40" x2="50" y2="28" stroke="currentColor" strokeWidth="4" strokeLinecap="round" transform={`rotate(${deg} 50 50)`} />
                            );
                        })}

                        <circle cx={center} cy={center} r="9" fill="currentColor" />
                        <ellipse cx={center} cy={center} rx="3.5" ry="6.5" className="fill-white dark:fill-vault-950" />
                    </g>
                </svg>
            );
        };
        const Icon = ({ name, size = 20, className = "" }) => {
            const icons = {
                search: <path d="M21 21l-4.35-4.35M11 19a8 8 0 100-16 8 8 0 000 16z" />,
                star: <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />,
                play: <path d="M5 3l14 9-14 9V3z" />,
                clock: <><circle cx="12" cy="12" r="10" /><path d="M12 6v6l4 2" /></>,
                grid: <><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></>,
                list: <><line x1="8" y1="6" x2="21" y2="6" /><line x1="8" y1="12" x2="21" y2="12" /><line x1="8" y1="18" x2="21" y2="18" /><line x1="3" y1="6" x2="3.01" y2="6" /><line x1="3" y1="12" x2="3.01" y2="12" /><line x1="3" y1="18" x2="3.01" y2="18" /></>,
                settings: <><circle cx="12" cy="12" r="3" /><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" /></>,
                close: <><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></>,
                user: <><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2" /><circle cx="12" cy="7" r="4" /></>,
                inbox: <><polyline points="22 12 16 12 14 15 10 15 8 12 2 12" /><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z" /></>,
                refresh: <><path d="M23 4v6h-6" /><path d="M1 20v-6h6" /><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15" /></>,
                trash: <><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></>,
                check: <polyline points="20 6 9 17 4 12" />,
                external: <><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></>,
                globe: <><circle cx="12" cy="12" r="10" /><line x1="2" y1="12" x2="22" y2="12" /><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" /></>,
                trending: <><polyline points="23 6 13.5 15.5 8.5 10.5 1 18" /><polyline points="17 6 23 6 23 12" /></>,
                filter: <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" />,
                database: <><ellipse cx="12" cy="5" rx="9" ry="3" /><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" /><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5" /></>,
                youtube: <><path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.33 29 29 0 0 0-.46-5.33z" /><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02" /></>,
                'alert-circle': <><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="12" /><line x1="12" y1="16" x2="12.01" y2="16" /></>,
                plus: <path d="M12 5v14M5 12h14" />,
            };
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name]}
                </svg>
            );
        };

        const GlassButton = ({
            children,
            onClick,
            active = false,
            className = "",
            icon,
            disabled = false
        }) => {
            return (
                <button
                    onClick={onClick}
                    disabled={disabled}
                    className={`
                relative flex items-center justify-center gap-2
                px-4 py-2 rounded-xl
                text-sm font-semibold tracking-wide
                transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
                backdrop-blur-xl
                overflow-hidden
                group
                ${disabled && "opacity-50 cursor-not-allowed"}

                ${active
                            ? `
                            bg-indigo-600/90 text-white
                            shadow-[0_8px_30px_rgba(99,102,241,0.45)]
                            ring-1 ring-indigo-400/40
                            scale-[1.03]
                          `
                            : `
                            bg-white/5 text-slate-400
                            border border-white/10
                            hover:bg-white/10
                            hover:text-white
                            hover:border-indigo-500/40
                            hover:shadow-[0_10px_40px_rgba(99,102,241,0.25)]
                            hover:-translate-y-0.5
                          `
                        }

                focus:outline-none
                focus-visible:ring-2
                focus-visible:ring-indigo-500/60
                focus-visible:ring-offset-2
                focus-visible:ring-offset-vault-950

                active:scale-95
                ${className}
            `}
                >
                    {/* Subtle animated glow layer */}
                    <span
                        className={`
                    absolute inset-0 opacity-0
                    bg-gradient-to-br from-indigo-500/20 via-purple-500/10 to-emerald-500/20
                    transition-opacity duration-500
                    group-hover:opacity-100
                    pointer-events-none
                `}
                    />

                    {icon && <Icon name={icon} size={16} className="relative z-10" />}
                    <span className="relative z-10">{children}</span>
                </button>
            );
        };


        const Badge = ({
            children,
            color = "indigo",
            className = "",
            glow = true
        }) => {
            const variants = {
                indigo: {
                    base: "bg-indigo-500/10 text-indigo-400 border-indigo-500/20",
                    glow: "group-hover:shadow-[0_0_20px_rgba(99,102,241,0.35)]"
                },
                green: {
                    base: "bg-emerald-500/10 text-emerald-400 border-emerald-500/20",
                    glow: "group-hover:shadow-[0_0_20px_rgba(16,185,129,0.35)]"
                },
                gold: {
                    base: "bg-amber-500/10 text-amber-400 border-amber-500/20",
                    glow: "group-hover:shadow-[0_0_20px_rgba(245,158,11,0.35)]"
                },
                red: {
                    base: "bg-rose-500/10 text-rose-400 border-rose-500/20",
                    glow: "group-hover:shadow-[0_0_20px_rgba(244,63,94,0.35)]"
                },
                slate: {
                    base: "bg-slate-500/10 text-slate-400 border-slate-500/20",
                    glow: "group-hover:shadow-[0_0_20px_rgba(148,163,184,0.25)]"
                }
            };

            const variant = variants[color] || variants.indigo;

            return (
                <span
                    className={`
                group relative inline-flex items-center
                px-3 py-1 rounded-full
                text-[10px] font-bold uppercase tracking-wider
                border backdrop-blur-md
                transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
                hover:scale-105
                ${variant.base}
                ${glow ? variant.glow : ""}
                ${className}
            `}
                >
                    {/* subtle gradient overlay */}
                    <span className="absolute inset-0 rounded-full bg-gradient-to-br from-white/5 to-transparent opacity-40 pointer-events-none" />
                    <span className="relative z-10">{children}</span>
                </span>
            );
        };


        const MediaCardPoster = ({
            item,
            isSeries,
            rating,
            onPlayTrailer,
            isAdmin,
            onAdminEdit,
            resumeTarget,
            onResume,
            onClick
        }) => (
            <div
            onClick={(e) => {
                    if (onClick) {
                        e.stopPropagation(); // Prevent double-firing on parent
                        onClick();
                                 }
                }}
                className="
            relative aspect-[2/3] overflow-hidden rounded-2xl
            bg-slate-900
            shadow-[0_15px_50px_rgba(0,0,0,0.7)]
            transition-all duration-700 ease-[cubic-bezier(0.16,1,0.3,1)]
            group
            cursor-pointer
            hover:-translate-y-3
            hover:shadow-[0_25px_80px_rgba(99,102,241,0.35)]
            hover:ring-2 hover:ring-indigo-500/40
            focus-within:ring-2 focus-within:ring-indigo-500/60
        "
            >
                {/* Glow Layer */}
                <div className="media-glow transition-opacity duration-700" />

                {/* Poster Image */}
                <img
                    src={getHighResPoster(item.Poster, 400)}
                    alt={item.Title}
                    width="400"
                    height="600"
                    loading="lazy"
                    className="
                h-full w-full object-cover
                opacity-85
                transition-all duration-1000 ease-out
                group-hover:scale-110
                group-hover:opacity-100
            "
                />

                {/* Light Sweep Effect */}
                <div className="absolute inset-0 pointer-events-none overflow-hidden">
                    <div className="
                absolute -inset-[200%]
                bg-gradient-to-r from-transparent via-white/10 to-transparent
                rotate-12
                translate-x-[-200%]
                group-hover:translate-x-[300%]
                transition-transform duration-1000 ease-out
            " />
                </div>

                {/* Cinematic Gradient Overlay */}
                <div className="
            absolute inset-0
            bg-gradient-to-t from-black/85 via-black/30 to-transparent
            opacity-70
            group-hover:opacity-90
            transition duration-500
        " />

                {/* Badges */}
                <MediaCardBadges item={item} />

                {/* Rating Badge */}
                <div className="absolute top-3 right-3 flex flex-col gap-2">
                    <div className="
                relative
                bg-black/60 backdrop-blur-xl
                text-white
                px-3 py-1.5
                rounded-xl
                text-xs font-bold
                flex items-center gap-1.5
                border border-white/10
                shadow-[0_8px_30px_rgba(0,0,0,0.6)]
                transition-all duration-300
                group-hover:shadow-[0_10px_40px_rgba(99,102,241,0.35)]
            ">
                        <Icon
                            name="star"
                            size={12}
                            className="text-amber-400 fill-amber-400 drop-shadow"
                        />
                        {rating || "N/A"}
                    </div>
                </div>

                {/* Hover Actions Layer */}
                <MediaCardHoverActions
                    item={item}
                    isSeries={isSeries}
                    onPlayTrailer={onPlayTrailer}
                    isAdmin={isAdmin}
                    onAdminEdit={onAdminEdit}
                    resumeTarget={resumeTarget}
                    onResume={onResume}
                    onClick={onClick}
                />
            </div>
        );


        const MediaCardBadges = ({ item }) => (
            <div className="absolute top-3 left-3 flex flex-col gap-2 z-20">

                {/* Watched Badge */}
                {item.userMeta?.status === "watched" && (
                    <div
                        className="
                    group relative
                    bg-emerald-500/90 text-white
                    backdrop-blur-xl
                    p-1.5 rounded-lg
                    border border-emerald-400/30
                    shadow-[0_8px_25px_rgba(16,185,129,0.4)]
                    transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
                    group-hover:shadow-[0_12px_40px_rgba(16,185,129,0.5)]
                "
                    >
                        <Icon name="check" size={14} />

                        {/* subtle glow overlay */}
                        <span className="absolute inset-0 rounded-lg bg-gradient-to-br from-white/10 to-transparent opacity-40 pointer-events-none" />
                    </div>
                )}
            </div>
        );


        const MediaCardHoverActions = ({
            item,
            isSeries,
            onPlayTrailer,
            isAdmin,
            onAdminEdit,
            resumeTarget,
            onResume,
            onClick
        }) => {

            const handleTrailer = useCallback((e) => {
                e.stopPropagation();
                onPlayTrailer(item);
            }, [item, onPlayTrailer]);

            const handleResume = useCallback((e) => {
                e.stopPropagation();
                onResume(item, resumeTarget);
            }, [item, resumeTarget, onResume]);
            
            const handleMainClick = useCallback((e) => {
                if (onClick) {
                    e.stopPropagation();
                    onClick();
                }
            }, [onClick]);
            return (
                <div
                    onClick={handleMainClick}
                    className="
                absolute inset-0
                z-40
                bg-gradient-to-t from-black/95 via-black/70 to-black/20
                opacity-0 group-hover:opacity-100
                transition-opacity duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
                flex flex-col justify-end
                p-4
                cursor-pointer
            "
                >

                    {/* Center Play Button */}
                    <div
                        className="
                    absolute top-1/2 left-1/2
                    -translate-x-1/2 -translate-y-1/2
                    scale-75 opacity-0
                    group-hover:scale-100 group-hover:opacity-100
                    transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
                "
                    >
                        <button
                            onClick={handleTrailer}
                            title="Watch Trailer"
                            className="
                        relative
                        bg-gradient-to-br from-indigo-500 to-purple-600
                        p-5 rounded-full
                        text-white
                        shadow-[0_15px_50px_rgba(99,102,241,0.5)]
                        transition-all duration-300
                        hover:scale-110
                        hover:shadow-[0_20px_70px_rgba(139,92,246,0.6)]
                        focus:outline-none
                        focus-visible:ring-2
                        focus-visible:ring-indigo-400/70
                    "
                        >
                            <Icon name="play" size={28} className="ml-1" />

                            {/* subtle glow layer */}
                            <span className="absolute inset-0 rounded-full bg-gradient-to-br from-white/20 to-transparent opacity-30 pointer-events-none" />
                        </button>
                    </div>

                    {/* Resume Button */}
                    {resumeTarget && (
                        <button
                            onClick={handleResume}
                            className="
                        mt-3 w-full
                        bg-indigo-600/90
                        backdrop-blur-md
                        text-white
                        text-xs font-semibold
                        py-2 rounded-xl
                        shadow-[0_8px_30px_rgba(99,102,241,0.4)]
                        transition-all duration-300
                        hover:bg-indigo-500
                        hover:shadow-[0_12px_40px_rgba(99,102,241,0.6)]
                        hover:-translate-y-0.5
                        focus:outline-none
                        focus-visible:ring-2
                        focus-visible:ring-indigo-400/70
                    "
                        >
                            Resume S{resumeTarget.season}  E{resumeTarget.episode}
                        </button>
                    )}

                    {/* Metadata */}
                    <div className="mt-3 space-y-1">
                        <p className="text-white text-xs font-medium line-clamp-2">
                            {item.Genre}
                        </p>
                        <p className="text-slate-400 text-[10px] uppercase tracking-widest">
                            {item.Year}  {isSeries ? "Series" : "Movie"}
                        </p>
                    </div>
                </div>
            );
        };


        const MediaCardInfo = ({ item, isSeries }) => {

            const mdlRating = Number.isFinite(item.meta?.asian?.mdl?.rating)
                ? item.meta.asian.mdl.rating.toFixed(1)
                : null;

            const malScore = Number.isFinite(item.meta?.anime?.score)
                ? item.meta.anime.score.toFixed(1)
                : null;

            const seasonCount =
                item.meta?.series?.seasons?.length ??
                item.totalSeasons ??
                null;

            return (
                <div className="px-1 space-y-2">

                    {/* Title */}
                    <h3
                        className="
                    font-bold text-sm text-white tracking-tight
                    transition-colors duration-500
                    ease-[cubic-bezier(0.16,1,0.3,1)]
                    group-hover:text-indigo-400
                "
                    >
                        {item.Title}
                    </h3>

                    {/* Meta Row */}
                    <div className="flex flex-wrap items-center gap-2">

                        {item.meta?.asian && (
                            <Badge color="green">Asian</Badge>
                        )}

                        {mdlRating && (
                            <Badge color="green">
                                MDL {mdlRating}
                            </Badge>
                        )}

                        {malScore && (
                            <Badge color="indigo">
                                MAL {malScore}
                            </Badge>
                        )}

                        {isSeries && seasonCount && (
                            <Badge color="slate">
                                {seasonCount} Season{seasonCount > 1 ? "s" : ""}
                            </Badge>
                        )}
                    </div>
                </div>
            );
        };

        const MediaCard = ({
            item,
            onClick,
            onAction,
            onPlayTrailer,
            onResume
        }) => {

            const isSeries = item.Type === "series";

            // Safer rating formatting
            const displayRating = Number.isFinite(item.imdbRating)
                ? item.imdbRating.toFixed(1)
                : "N/A";

            // Narrower memo dependencies
            const resumeTarget = useMemo(() => {
                if (
                    item.Type !== "series" ||
                    !item.meta?.tvmaze?.episodes ||
                    !item.userMeta?.watchHistory
                ) {
                    return null;
                }

                return getResumeTarget({
                    episodes: item.meta.tvmaze.episodes,
                    watchHistory: item.userMeta.watchHistory
                });

            }, [
                item.Type,
                item.meta?.tvmaze?.episodes,
                item.userMeta?.watchHistory
            ]);

            const handleKeyPress = (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    onClick?.();
                }
            };

            return (
                <div
                    onClick={onClick}
                    onKeyDown={handleKeyPress}
                    role="button"
                    tabIndex={0}
                    className="
                group relative flex flex-col gap-3
                animate-reveal
                transition-all duration-500
                ease-[cubic-bezier(0.16,1,0.3,1)]
                hover:z-20
                focus:outline-none
                focus-visible:ring-2
                focus-visible:ring-indigo-500/60
                focus-visible:ring-offset-2
                focus-visible:ring-offset-vault-950
            "
                >
                    <MediaCardPoster
                        item={item}
                        isSeries={isSeries}
                        rating={displayRating}
                        onPlayTrailer={onPlayTrailer}
                        resumeTarget={resumeTarget}
                        onResume={onResume}
                        onClick={onClick}
                    />

                    <MediaCardInfo
                        item={item}
                        isSeries={isSeries}
                    />
                </div>
            );
        };


        const ContentRail = ({
            title,
            items = [],
            onCardClick,
            onPlayTrailer,
            onResume,
            icon,
            emptyMessage
        }) => {

            if (!items.length) {
                return emptyMessage ? (
                    <section className="mb-10 animate-reveal">
                        <h2 className="text-lg font-black text-white mb-4 flex items-center gap-2">
                            {icon && <Icon name={icon} className="text-emerald-400" />}
                            {title}
                        </h2>
                        <p className="text-slate-500 text-sm">{emptyMessage}</p>
                    </section>
                ) : null;
            }

            return (
                <section className="mb-10 animate-reveal">

                    {/* Header */}
                    <h2 className="text-lg font-black text-white mb-4 flex items-center gap-2">
                        {icon && (
                            <Icon
                                name={icon}
                                className="text-emerald-400 drop-shadow-[0_0_10px_rgba(16,185,129,0.4)]"
                            />
                        )}
                        {title}
                    </h2>

                    {/* Scroll Container */}
                    <div className="relative">

                        {/* Left Fade */}
                        <div className="pointer-events-none absolute left-0 top-0 bottom-0 w-10 bg-gradient-to-r from-vault-950 to-transparent z-10" />

                        {/* Right Fade */}
                        <div className="pointer-events-none absolute right-0 top-0 bottom-0 w-10 bg-gradient-to-l from-vault-950 to-transparent z-10" />

                        <div
                            className="
                        flex gap-4 overflow-x-auto no-scrollbar pb-2
                        snap-x snap-mandatory
                        scroll-smooth
                        focus:outline-none
                    "
                            role="region"
                            aria-label={title}
                        >
                            {items.map((item) => (
                                <div
                                    key={item.imdbID || item.id}
                                    className="snap-start shrink-0 transition-transform duration-500 hover:scale-[1.02]"
                                >
                                    <MediaCard
                                        item={item}
                                        onClick={() => onCardClick?.(item)}
                                        onPlayTrailer={() => onPlayTrailer?.(item)}
                                        onResume={() => onResume?.(item)}
                                    />
                                </div>
                            ))}
                        </div>

                    </div>
                </section>
            );
        };


        const CacheHealthPanel = () => {
            const stats = useCacheStats();
            if (!stats) return null;

            const usagePercent = Math.round(
                (stats.totalEntries / stats.maxEntries) * 100
            );

            const healthColor =
                stats.expiredEntries > 0
                    ? "text-amber-400"
                    : "text-emerald-400";

            return (
                <div
                    className="
                relative p-5 rounded-2xl
                bg-white/5 backdrop-blur-xl
                border border-white/10
                shadow-[0_10px_40px_rgba(0,0,0,0.5)]
                mb-4
                transition-all duration-500
                hover:shadow-[0_20px_60px_rgba(99,102,241,0.2)]
            "
                >
                    {/* Subtle glow overlay */}
                    <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-indigo-500/5 to-transparent pointer-events-none" />

                    <h3 className="text-sm font-bold text-white mb-4 tracking-wide">
                        Cache Health
                    </h3>

                    <div className="grid grid-cols-3 gap-4 text-center relative z-10">

                        {/* Total Entries */}
                        <div className="space-y-1">
                            <p className="text-xl font-black text-white">
                                {stats.totalEntries}
                            </p>
                            <p className="text-xs text-slate-400 uppercase tracking-wider">
                                Entries
                            </p>
                        </div>

                        {/* Expired */}
                        <div className="space-y-1">
                            <p className={`text-xl font-black ${healthColor}`}>
                                {stats.expiredEntries}
                            </p>
                            <p className="text-xs text-slate-400 uppercase tracking-wider">
                                Expired
                            </p>
                        </div>

                        {/* Max */}
                        <div className="space-y-1">
                            <p className="text-xl font-black text-white">
                                {stats.maxEntries}
                            </p>
                            <p className="text-xs text-slate-400 uppercase tracking-wider">
                                Max
                            </p>
                        </div>
                    </div>

                    {/* Usage Bar */}
                    <div className="mt-5">
                        <div className="h-2 w-full bg-white/10 rounded-full overflow-hidden">
                            <div
                                className="h-full bg-indigo-500 transition-all duration-700"
                                style={{ width: `${usagePercent}%` }}
                            />
                        </div>
                        <p className="text-[10px] text-slate-400 mt-2 uppercase tracking-widest text-right">
                            {usagePercent}% Utilized
                        </p>
                    </div>
                </div>
            );
        };


        const SeasonHeatmap = ({ seasons = [], onSeasonClick }) => {
            if (!seasons.length) return null;

            return (
                <div className="mb-8">

                    <h3 className="text-sm font-bold text-slate-300 mb-4 tracking-wide">
                        Season Progress
                    </h3>

                    <div className="space-y-4">

                        {seasons.map((s) => {

                            const percent = Math.min(100, Math.max(0, s.completionPercent));

                            let colorClass = "bg-slate-500";
                            if (percent === 100) colorClass = "bg-emerald-500";
                            else if (percent >= 70) colorClass = "bg-indigo-500";
                            else if (percent >= 30) colorClass = "bg-amber-500";

                            return (
                                <div
                                    key={s.season}
                                    onClick={() => onSeasonClick?.(s.season)}
                                    role="button"
                                    tabIndex={0}
                                    onKeyDown={(e) => {
                                        if (e.key === "Enter" || e.key === " ") {
                                            e.preventDefault();
                                            onSeasonClick?.(s.season);
                                        }
                                    }}
                                    className="
                                group cursor-pointer
                                transition-all duration-500
                                ease-[cubic-bezier(0.16,1,0.3,1)]
                                hover:-translate-y-0.5
                            "
                                >

                                    {/* Header Row */}
                                    <div className="flex justify-between items-center mb-1 text-xs">
                                        <span className="font-semibold text-slate-300 group-hover:text-white transition-colors">
                                            Season {s.season}
                                        </span>
                                        <span className="text-slate-400">
                                            {s.watched}/{s.total}
                                        </span>
                                    </div>

                                    {/* Progress Track */}
                                    <div className="relative h-2 rounded-full bg-white/10 overflow-hidden">

                                        {/* Glow under fill */}
                                        <div
                                            className={`
                                        absolute inset-y-0 left-0
                                        ${colorClass}
                                        opacity-30 blur-sm
                                        transition-all duration-700
                                    `}
                                            style={{ width: `${percent}%` }}
                                        />

                                        {/* Fill */}
                                        <div
                                            className={`
                                        relative h-full rounded-full
                                        ${colorClass}
                                        transition-all duration-700
                                        ease-[cubic-bezier(0.16,1,0.3,1)]
                                    `}
                                            style={{ width: `${percent}%` }}
                                        />
                                    </div>

                                    {/* Partial Indicator */}
                                    {s.partial > 0 && (
                                        <p className="text-[10px] text-amber-400 mt-1 opacity-80 group-hover:opacity-100 transition-opacity">
                                            {s.partial} episode{s.partial > 1 ? "s" : ""} in progress
                                        </p>
                                    )}

                                </div>
                            );
                        })}

                    </div>
                </div>
            );
        };

        // --- STEP 3: STATUS BADGE COMPONENT ---
        const StatusBadge = ({ status, isInVault }) => {

            const STATUS_CONFIG = {
                approved: {
                    label: "Approved ",
                    base: "bg-emerald-500/20 text-emerald-400 border-emerald-500/30"
                },
                pending: {
                    label: "Pending",
                    base: "bg-amber-500/20 text-amber-400 border-amber-500/30"
                },
                rejected: {
                    label: "Rejected ",
                    base: "bg-rose-500/20 text-rose-400 border-rose-500/30"
                }
            };

            const config = STATUS_CONFIG[status];

            if (!config) return null;

            return (
                <div className="flex items-center gap-2">

                    {/* Main Status Badge */}
                    <span
                        className={`
                    px-3 py-1 rounded-full
                    text-xs font-semibold uppercase tracking-wider
                    border backdrop-blur-md
                    transition-all duration-300
                    ${config.base}
                `}
                    >
                        {config.label}
                    </span>

                    {/* Vault Indicator */}
                    {status === "approved" && isInVault && (
                        <span
                            className="
                        text-xs font-bold uppercase tracking-widest
                        text-indigo-400
                        opacity-80
                        transition-opacity duration-300
                        hover:opacity-100
                    "
                        >
                            In Vault
                        </span>
                    )}
                </div>
            );
        };


        // --- STEP 2 (Continued): USER SUGGESTED MEDIA PANEL ---
        const UserSuggestionsPanel = ({
            suggestions = [],
            libraryItems = []
        }) => {

            if (!suggestions.length) {
                return (
                    <div className="glass p-8 rounded-2xl text-center">
                        <p className="text-slate-400 text-sm">
                            You havent suggested any media yet.
                        </p>
                    </div>
                );
            }

            return (
                <div className="glass p-6 rounded-2xl space-y-6">

                    <h2 className="text-lg font-bold text-white tracking-tight">
                        My Suggested Media
                    </h2>

                    <div className="space-y-4">
                        {suggestions.map((s) => {

                            const isNowInVault = isInVault(
                                {
                                    imdbID: s.imdb_id,
                                    Title: s.title,
                                    Year: s.year
                                },
                                libraryItems
                            );

                            return (
                                <div
                                    key={s.id}
                                    className="
                                group relative flex items-center gap-4
                                bg-white/5 backdrop-blur-md
                                border border-white/10
                                p-3 rounded-xl
                                transition-all duration-500
                                ease-[cubic-bezier(0.16,1,0.3,1)]
                                hover:bg-white/10
                                hover:-translate-y-0.5
                                hover:shadow-[0_10px_40px_rgba(99,102,241,0.2)]
                            "
                                >

                                    {/* Poster */}
                                    <img
                                        src={s.poster || "https://via.placeholder.com/80x120"}
                                        alt={s.title}
                                        loading="lazy"
                                        className="
                                    w-16 h-24 object-cover rounded-lg
                                    shadow-[0_8px_25px_rgba(0,0,0,0.5)]
                                    transition-transform duration-500
                                    group-hover:scale-105
                                "
                                    />

                                    {/* Text Content */}
                                    <div className="flex-1 min-w-0">
                                        <div className="font-semibold text-white truncate">
                                            {s.title}
                                        </div>
                                        <div className="text-xs text-slate-400">
                                            {s.year}
                                        </div>
                                    </div>

                                    {/* Status */}
                                    <StatusBadge
                                        status={s.status}
                                        isInVault={isNowInVault}
                                    />
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };


        const AdminSuggestionsPanel = ({
            suggestions = [],
            onApprove,
            onReject
        }) => {

            if (!suggestions.length) {
                return (
                    <div className="glass p-8 rounded-2xl text-center">
                        <p className="text-slate-400 text-sm">
                            No pending suggestions.
                        </p>
                    </div>
                );
            }

            return (
                <div className="glass p-6 rounded-2xl space-y-6">

                    {/* Header */}
                    <div className="flex justify-between items-center">
                        <h2 className="text-lg font-bold text-white tracking-tight">
                            Pending Suggestions
                        </h2>

                        <span
                            className="
                        bg-indigo-600/90 text-white text-xs
                        px-3 py-1 rounded-full
                        shadow-[0_0_20px_rgba(99,102,241,0.4)]
                    "
                        >
                            {suggestions.length}
                        </span>
                    </div>

                    {/* Suggestions List */}
                    <div className="space-y-4">
                        {suggestions.map((s) => (
                            <div
                                key={s.id}
                                className="
                            group relative flex items-center gap-4
                            bg-white/5 backdrop-blur-md
                            border border-white/10
                            p-4 rounded-xl
                            transition-all duration-500
                            ease-[cubic-bezier(0.16,1,0.3,1)]
                            hover:bg-white/10
                            hover:-translate-y-0.5
                            hover:shadow-[0_15px_50px_rgba(99,102,241,0.2)]
                        "
                            >

                                {/* Poster */}
                                <img
                                    src={s.poster || "https://via.placeholder.com/80x120"}
                                    alt={s.title}
                                    loading="lazy"
                                    className="
                                w-16 h-24 object-cover rounded-lg
                                shadow-[0_8px_25px_rgba(0,0,0,0.5)]
                                transition-transform duration-500
                                group-hover:scale-105
                            "
                                />

                                {/* Content */}
                                <div className="flex-1 min-w-0">
                                    <div className="font-semibold text-white truncate">
                                        {s.title}
                                    </div>

                                    <div className="text-xs text-slate-400">
                                        {s.year}
                                    </div>

                                    <div className="text-[10px] text-slate-500 mt-1 uppercase tracking-wider">
                                        From: {s.suggested_by}
                                    </div>
                                </div>

                                {/* Actions */}
                                <div className="flex gap-2">

                                    <button
                                        onClick={() => onApprove?.(s)}
                                        className="
                                    bg-emerald-600/90 text-white
                                    px-3 py-1.5 rounded-lg
                                    text-xs font-bold
                                    shadow-[0_8px_25px_rgba(16,185,129,0.4)]
                                    transition-all duration-300
                                    hover:bg-emerald-500
                                    hover:shadow-[0_12px_40px_rgba(16,185,129,0.6)]
                                    hover:-translate-y-0.5
                                    focus:outline-none
                                    focus-visible:ring-2
                                    focus-visible:ring-emerald-400/70
                                "
                                    >
                                        Approve
                                    </button>

                                    <button
                                        onClick={() => onReject?.(s)}
                                        className="
                                    bg-rose-600/90 text-white
                                    px-3 py-1.5 rounded-lg
                                    text-xs font-bold
                                    shadow-[0_8px_25px_rgba(244,63,94,0.4)]
                                    transition-all duration-300
                                    hover:bg-rose-500
                                    hover:shadow-[0_12px_40px_rgba(244,63,94,0.6)]
                                    hover:-translate-y-0.5
                                    focus:outline-none
                                    focus-visible:ring-2
                                    focus-visible:ring-rose-400/70
                                "
                                    >
                                        Reject
                                    </button>

                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const ProfileStat = ({ label, value }) => (
            <div
                className="
            group relative glass rounded-2xl p-6 text-center
            transition-all duration-500
            ease-[cubic-bezier(0.16,1,0.3,1)]
            hover:-translate-y-2
            hover:shadow-[0_20px_60px_rgba(99,102,241,0.25)]
            hover:ring-1 hover:ring-indigo-500/40
        "
            >

                {/* Subtle Glow Overlay */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-indigo-500/5 to-emerald-500/5 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none" />

                {/* Value */}
                <div
                    className="
                relative text-3xl font-black
                tracking-tight mb-1 truncate
                text-transparent bg-clip-text
                bg-gradient-to-r from-indigo-400 to-emerald-400
                transition-transform duration-500
                group-hover:scale-105
            "
                >
                    {value}
                </div>

                {/* Label */}
                <div
                    className="
                text-xs uppercase tracking-widest
                text-slate-400 font-bold
                transition-colors duration-300
                group-hover:text-slate-300
            "
                >
                    {label}
                </div>

            </div>
        );


        const SectionDivider = () => (
            <div className="relative my-12 animate-reveal">
                <div className="h-px bg-gradient-to-r from-transparent via-white/10 to-transparent" />
                <div className="absolute inset-0 h-px bg-gradient-to-r from-transparent via-indigo-500/30 to-transparent blur-sm opacity-60" />
            </div>
        );
        const EmptyState = ({ message = "No data available." }) => (
            <div
                className="
            relative glass rounded-2xl p-10
            text-center flex flex-col items-center
            transition-all duration-500
            ease-[cubic-bezier(0.16,1,0.3,1)]
        "
            >

                {/* Subtle Glow */}
                <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-indigo-500/5 to-transparent pointer-events-none" />

                <Icon
                    name="inbox"
                    size={32}
                    className="
                mb-5 text-slate-500
                transition-transform duration-500
                group-hover:scale-110
            "
                />

                <p className="text-slate-400 font-medium text-sm">
                    {message}
                </p>
            </div>
        );


        const ProfileSection = ({ title, children }) => (
            <section
                className="
            mb-14 animate-reveal
            transition-all duration-500
            ease-[cubic-bezier(0.16,1,0.3,1)]
        "
            >
                <div className="flex items-center gap-3 mb-5">
                    <h2 className="text-lg font-black text-white tracking-tight">
                        {title}
                    </h2>

                    <div className="flex-1 h-px bg-gradient-to-r from-white/10 to-transparent" />
                </div>

                <div
                    className="
                relative glass rounded-xl p-6
                transition-all duration-500
                hover:shadow-[0_15px_50px_rgba(99,102,241,0.15)]
            "
                >
                    {children}
                </div>
            </section>
        );


        const GenreBars = ({ data = {} }) => {

            const entries = Object.entries(data)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            if (!entries.length) return <EmptyState />;

            return (
                <div className="space-y-4">

                    {entries.map(([genre, rawValue], index) => {

                        const value = Math.min(100, Math.max(0, rawValue));

                        return (
                            <div
                                key={genre}
                                className="
                            group relative
                            flex items-center justify-between
                            px-5 py-4 rounded-xl
                            bg-white/5 backdrop-blur-md
                            border border-white/10
                            transition-all duration-500
                            ease-[cubic-bezier(0.16,1,0.3,1)]
                            hover:bg-white/10
                            hover:-translate-y-1
                            hover:shadow-[0_10px_40px_rgba(99,102,241,0.2)]
                        "
                            >

                                <div className="flex-1">

                                    {/* Header Row */}
                                    <div className="flex justify-between items-center text-xs mb-2 font-bold tracking-wide">

                                        <span className="flex items-center capitalize">
                                            <span className="text-indigo-400 mr-3">
                                                #{index + 1}
                                            </span>
                                            <span className="text-slate-200 group-hover:text-white transition-colors duration-300">
                                                {genre}
                                            </span>
                                        </span>

                                        <span className="text-indigo-300">
                                            {value}%
                                        </span>

                                    </div>

                                    {/* Progress Track */}
                                    <div className="relative h-2 bg-black/20 rounded-full overflow-hidden">

                                        {/* Soft glow under bar */}
                                        <div
                                            className="
                                        absolute inset-y-0 left-0
                                        bg-indigo-500
                                        opacity-30 blur-sm
                                        transition-all duration-700
                                    "
                                            style={{ width: `${value}%` }}
                                        />

                                        {/* Main fill */}
                                        <div
                                            style={{ width: `${value}%` }}
                                            className="
                                        relative h-full rounded-full
                                        bg-gradient-to-r
                                        from-indigo-500 via-purple-500 to-emerald-500
                                        transition-all duration-700
                                        ease-[cubic-bezier(0.16,1,0.3,1)]
                                        shadow-[0_0_15px_rgba(99,102,241,0.4)]
                                    "
                                        />

                                    </div>

                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };


        const ActorList = ({ data = {} }) => {

            const entries = Object.entries(data)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            if (!entries.length) return <EmptyState />;

            return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">

                    {entries.map(([actor, rawValue], index) => {

                        const value = Math.min(100, Math.max(0, rawValue));

                        return (
                            <div
                                key={actor}
                                className="
                            group relative
                            flex justify-between items-center
                            px-5 py-4 rounded-xl
                            bg-white/5 backdrop-blur-md
                            border border-white/10
                            transition-all duration-500
                            ease-[cubic-bezier(0.16,1,0.3,1)]
                            hover:bg-white/10
                            hover:-translate-y-1
                            hover:shadow-[0_10px_40px_rgba(99,102,241,0.2)]
                        "
                            >

                                {/* Left Side */}
                                <div className="flex items-center min-w-0">

                                    <span
                                        className="
                                    text-xs font-bold text-indigo-400 mr-3
                                    transition-transform duration-300
                                    group-hover:scale-110
                                "
                                    >
                                        #{index + 1}
                                    </span>

                                    <span
                                        className="
                                    text-slate-300 font-medium truncate
                                    group-hover:text-white
                                    transition-colors duration-300
                                "
                                        title={actor}
                                    >
                                        {actor}
                                    </span>

                                </div>

                                {/* Right Value */}
                                <span
                                    className="
                                text-indigo-400 font-black text-sm
                                transition-transform duration-300
                                group-hover:scale-105
                            "
                                >
                                    {value}%
                                </span>

                            </div>
                        );
                    })}

                </div>
            );
        };

        const EditProfileModal = ({ user, onClose, onUpdated }) => {
            const [name, setName] = useState(user?.user_metadata?.name || "");
            const [dob, setDob] = useState(user?.user_metadata?.dob || "");
            const [sex, setSex] = useState(user?.user_metadata?.sex || "");
            const [rankMap, setRankMap] = useState({});
            const [topCharacters, setTopCharacters] = useState([]);
            const [saving, setSaving] = useState(false);
            const [animeAvatars, setAnimeAvatars] = useState([]);
            const [searchQuery, setSearchQuery] = useState("");

            const [selectedAvatar, setSelectedAvatar] = useState(
                user?.user_metadata?.avatar_url || null
            );
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                fetchTopCharacters();
            }, []);

            const fetchTopCharacters = async () => {
                try {
                    let all = [];
                    let ranks = {};
                    let counter = 1;

                    for (let page = 1; page <= 10; page++) {
                        const res = await fetch(
                            `https://api.jikan.moe/v4/top/characters?page=${page}`
                        );
                        const data = await res.json();

                        for (let char of data?.data || []) {
                            const formatted = {
                                id: char.mal_id,
                                name: char.name,
                                image: char.images?.jpg?.image_url
                            };

                            all.push(formatted);
                            ranks[char.mal_id] = counter;
                            counter++;
                        }
                    }

                    setTopCharacters(all);
                    setRankMap(ranks);
                    setAnimeAvatars(all); // show top 100 initially
                } catch (err) {
                    console.error(err);
                }
            };



            useEffect(() => {
                if (!searchQuery.trim()) {
                    setAnimeAvatars(topCharacters);
                    return;
                }

                const query = searchQuery.toLowerCase();

                //  STEP 1  Show Local Matches Instantly
                const localMatches = topCharacters.filter(c =>
                    c.name.toLowerCase().includes(query)
                );

                setAnimeAvatars(localMatches);

                //  STEP 2  Fetch API in Background
                const delay = setTimeout(() => {
                    fetchAndMerge(query, localMatches, rankMap);
                }, 400);

                return () => clearTimeout(delay);

            }, [searchQuery, topCharacters]);


            const fetchAndMerge = async (query, localMatches, currentRankMap) => {
                try {
                    setLoading(true);   //  START loading

                    const res = await fetch(
                        `https://api.jikan.moe/v4/characters?q=${encodeURIComponent(query)}`
                    );

                    const data = await res.json();

                    const apiResults = (data?.data || [])
                        .filter(char =>
                            (char.name || "").toLowerCase().includes(query)
                        )
                        .map(char => ({
                            id: char.mal_id,
                            name: char.name,
                            image: char.images?.jpg?.image_url
                        }));


                    const mergedMap = {};

                    localMatches.forEach(char => {
                        mergedMap[char.id] = char;
                    });

                    apiResults.forEach(char => {
                        if (!mergedMap[char.id]) {
                            mergedMap[char.id] = char;
                        }
                    });

                    const merged = Object.values(mergedMap);

                    merged.sort((a, b) => {
                        const rankA = currentRankMap[a.id] ?? Infinity;
                        const rankB = currentRankMap[b.id] ?? Infinity;
                        return rankA - rankB;
                    });

                    setAnimeAvatars(merged);

                } catch (err) {
                    console.error(err);
                } finally {
                    setLoading(false);  //  STOP loading (always runs)
                }
            };

            const handleRandomAvatar = () => {
                if (animeAvatars.length === 0) return;

                const random =
                    animeAvatars[Math.floor(Math.random() * animeAvatars.length)];

                setSelectedAvatar(random.image);
            };

            const handleSave = async () => {
                try {
                    setSaving(true);

                    await supabase.auth.updateUser({
                        data: {
                            name,
                            dob,
                            sex,
                            avatar_url: selectedAvatar
                        }
                    });

                    onUpdated();
                    onClose();

                } catch (err) {
                    console.error("Profile update failed:", err);
                } finally {
                    setSaving(false);
                }
            };


            return (

                <div
                    className="
            fixed inset-0
            bg-black/60 backdrop-blur-sm
            flex items-center justify-center
            z-[1000]
            px-4
            overflow-y-auto
        "
                >



                    <div className="glass w-full max-w-lg 
                mx-auto
                p-6 sm:p-8 
                rounded-3xl 
                space-y-6">


                        <h2 className="text-2xl font-bold text-white">Edit Profile</h2>

                        <input
                            type="text"
                            placeholder="Username"
                            value={name}
                            onChange={(e) => setName(e.target.value)}
                            className="w-full p-3 rounded-xl bg-white/5 border border-white/10 text-white"
                        />

                        <input
                            type="text"
                            placeholder="Date of Birth (dd/mm/yyyy)"
                            value={dob}
                            onChange={(e) => setDob(e.target.value)}
                            className="w-full p-3 rounded-xl bg-white/5 border border-white/10 text-white"
                            pattern="\d{2}/\d{2}/\d{4}"
                        />


                        <select
                            value={sex}
                            onChange={(e) => {
                                setSex(e.target.value);
                            }}
                            className="w-full p-3 rounded-xl bg-white/5 border border-white/10 text-white"
                        >
                            <option value="">Select Sex</option>
                            <option value="Male">Male</option>
                            <option value="Female">Female</option>
                        </select>

                        <div>

                            <div className="flex items-center justify-between mb-3">
                                <p className="text-sm text-slate-400">
                                    Choose Anime Avatar
                                </p>

                                <button
                                    onClick={handleRandomAvatar}
                                    className="text-xs text-indigo-400 hover:text-indigo-300"
                                >
                                    Random
                                </button>
                            </div>

                            {/* Search */}
                            <input
                                type="text"
                                placeholder="Search character..."
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                className="w-full mb-4 p-2 rounded-xl bg-white/5 border border-white/10 text-white text-sm"
                            />

                            {/* Scrollable Grid */}
                            <div
                                className="grid grid-cols-4 gap-3 max-h-60 overflow-y-auto pr-1"
                            >
                                {animeAvatars.map(char => (
                                    <div
                                        key={char.id}
                                        className="flex flex-col items-center"
                                    >

                                        <button
                                            onClick={() => setSelectedAvatar(char.image)}
                                            className={`
        relative rounded-xl overflow-hidden
        transition-all duration-300 ease-out
        transform
        ${selectedAvatar === char.image
                                                    ? "ring-2 ring-indigo-500 scale-105 shadow-[0_0_15px_rgba(99,102,241,0.6)]"
                                                    : "hover:scale-105 hover:ring-2 hover:ring-indigo-400 hover:shadow-[0_0_12px_rgba(99,102,241,0.4)]"
                                                }
    `}
                                        >

                                            <img
                                                src={char.image}
                                                alt={char.name}
                                                className="w-20 h-28 object-cover rounded-xl"
                                                loading="lazy"
                                            />
                                        </button>

                                        {/*  Name Below Image */}
                                        <div className="text-[11px] text-center text-slate-300 mt-2 break-words w-20 leading-tight">
                                            {char.name}
                                        </div>


                                    </div>
                                ))}



                                {loading && (
                                    <p className="col-span-4 text-center text-slate-400 text-sm py-2">
                                        Loading more...
                                    </p>
                                )}
                            </div>


                        </div>




                        <div className="flex justify-end gap-3">
                            <GlassButton onClick={onClose}>
                                Cancel
                            </GlassButton>

                            <GlassButton
                                onClick={handleSave}
                                disabled={saving}
                                active
                            >
                                {saving ? "Saving..." : "Save Changes"}
                            </GlassButton>
                        </div>
                    </div>
                </div>
            );
        };

        const ProfileView = ({
            user,
            libraryItems = [],
            onBack,
            adminSuggestions = [],
            onApproveSuggestion,
            onRejectSuggestion,
            userSuggestions = []
        }) => {

            const isAdmin = isAdminUser(user);
            const [showEdit, setShowEdit] = useState(false);
            const [loggingOut, setLoggingOut] = useState(false);

            const handleLogout = async () => {
                if (loggingOut) return;

                try {
                    setLoggingOut(true);
                    await supabase.auth.signOut();
                    window.location.reload();
                } catch (error) {
                    console.error("Logout failed:", error);
                } finally {
                    setLoggingOut(false);
                }
            };

            const progressMap = useMemo(
                () => buildProgressMap(libraryItems),
                [libraryItems]
            );

            const genreProfile = useMemo(() => {
                const items = extractGenreItems(libraryItems);
                return getGenreProfile(items, { useRecency: true });
            }, [libraryItems]);

            const actorProfile = useMemo(
                () => getActorPopularityProfile({ items: libraryItems, progressMap }),
                [libraryItems, progressMap]
            );

            const recentlyWatched = useMemo(() => {
                return [...libraryItems]
                    .sort(
                        (a, b) =>
                            (b.userMeta?.lastUpdated || 0) -
                            (a.userMeta?.lastUpdated || 0)
                    )
                    .slice(0, 4);
            }, [libraryItems]);

            const avatarInitial =
                (user?.email || user?.user_metadata?.name || "U")[0].toUpperCase();

            const totalGenresTracked = Object.keys(genreProfile.percent || {}).length;

            return (
                <div className="max-w-6xl mx-auto px-6 py-10 animate-reveal">

                    {/* HERO */}
                    <div className="profile-hero glass rounded-3xl p-8 mb-12 relative overflow-hidden">

                        <div className="absolute inset-0 bg-gradient-to-br from-indigo-500/5 to-transparent pointer-events-none" />

                        <div className="relative z-10 flex flex-col lg:flex-row lg:items-center justify-between gap-8">

                            {/* LEFT SECTION */}
                            <div className="flex items-center gap-6">

                                <div className="w-24 h-24 rounded-full overflow-hidden ring-4 ring-white/10 shadow-lg">
                                    {user?.user_metadata?.avatar_url ? (
                                        <img
                                            src={user.user_metadata.avatar_url}
                                            alt="Avatar"
                                            className="w-full h-full object-cover"
                                        />
                                    ) : (
                                        <div className="w-full h-full bg-gradient-to-br from-indigo-600 to-purple-600 flex items-center justify-center text-4xl font-black text-white">
                                            {avatarInitial}
                                        </div>
                                    )}
                                </div>

                                <div>
                                    <h1 className="text-3xl font-black text-white tracking-tight">
                                        {user.user_metadata?.name || "Vault User"}
                                    </h1>

                                    <p className="text-indigo-300 font-medium">
                                        {user.email}
                                    </p>

                                    <div className="mt-4 flex flex-wrap items-center gap-3 text-sm text-slate-400">
                                        <span>
                                            {libraryItems.length} Titles Watched
                                        </span>
                                        <span className="opacity-40"></span>
                                        <span>
                                            {totalGenresTracked} Genres Tracked
                                        </span>
                                    </div>

                                    {isAdmin && (
                                        <div className="mt-4">
                                            <Badge color="gold">Admin Access</Badge>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* RIGHT BUTTONS */}
                            <div className="flex items-center gap-3">

                                <GlassButton
                                    onClick={handleLogout}
                                    disabled={loggingOut}
                                    className="bg-red-500/10 hover:bg-red-500/20 text-red-400 border border-red-500/20"
                                >
                                    <Icon name={loggingOut ? "refresh" : "user"} size={16} />
                                    {loggingOut ? "Logging out..." : "Logout"}
                                </GlassButton>

                                <GlassButton onClick={onBack}>
                                    <Icon name="close" size={16} />
                                    Close Profile
                                </GlassButton>
                                <GlassButton onClick={() => setShowEdit(true)}>
                                    <Icon name="settings" size={16} />
                                    Edit Profile
                                </GlassButton>


                            </div>

                        </div>
                    </div>


                    {/* STATS */}
                    <section className="grid grid-cols-2 md:grid-cols-4 gap-5 mb-14">
                        <ProfileStat label="Titles Watched" value={libraryItems.length} />
                        <ProfileStat label="Genres Tracked" value={Object.keys(genreProfile.percent).length} />
                        <ProfileStat label="Actors Tracked" value={Object.keys(actorProfile.percent).length} />
                        <ProfileStat label="System Role" value={isAdmin ? "Admin" : "User"} />
                    </section>

                    {/* SUGGESTIONS */}
                    <section className="mb-14 animate-reveal">
                        {isAdmin ? (
                            <AdminSuggestionsPanel
                                suggestions={adminSuggestions}
                                onApprove={onApproveSuggestion}
                                onReject={onRejectSuggestion}
                            />
                        ) : (
                            <UserSuggestionsPanel
                                suggestions={userSuggestions}
                                libraryItems={libraryItems}
                            />
                        )}
                    </section>

                    <SectionDivider />

                    {/* ANALYTICS */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-10">
                        <ProfileSection title="Genre Affinity">
                            <GenreBars data={genreProfile.percent} />
                        </ProfileSection>

                        <ProfileSection title="Actor Affinity">
                            <ActorList data={actorProfile.percent} />
                        </ProfileSection>
                    </div>

                    <SectionDivider />

                    {/* RECENTLY ACTIVE */}
                    <section className="animate-reveal">
                        <h2 className="text-lg font-black text-white mb-6">
                            Recently Active
                        </h2>

                        {recentlyWatched.length === 0 ? (
                            <EmptyState message="No history found." />
                        ) : (
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-6">

                                {recentlyWatched.map((item) => (
                                    <div
                                        key={item.imdbID}
                                        className="
                                    group relative rounded-xl overflow-hidden
                                    aspect-[2/3]
                                    bg-slate-800
                                    transition-all duration-500
                                    ease-[cubic-bezier(0.16,1,0.3,1)]
                                    hover:-translate-y-2
                                    hover:shadow-[0_20px_60px_rgba(99,102,241,0.25)]
                                    cursor-pointer
                                "
                                    >
                                        <img
                                            src={getHighResPoster(item.Poster, 300)}
                                            alt={item.Title}
                                            width="300"
                                            height="450"
                                            loading="lazy"
                                            className="
                                        w-full h-full object-cover
                                        opacity-80
                                        transition-opacity duration-500
                                        group-hover:opacity-100
                                    "
                                        />

                                        <div className="
                                    absolute inset-0
                                    bg-gradient-to-t from-black/80 via-transparent to-transparent
                                    opacity-0 group-hover:opacity-100
                                    transition-opacity duration-300
                                    flex items-end p-4
                                ">
                                            <div>
                                                <p className="text-white font-bold text-sm">
                                                    {item.Title}
                                                </p>
                                                <p className="text-indigo-400 text-xs font-medium mt-1">
                                                    Recently Updated
                                                </p>
                                            </div>
                                        </div>

                                    </div>
                                ))}

                            </div>
                        )}
                    </section>

                    {showEdit && (
                        <EditProfileModal
                            user={user}
                            onClose={() => setShowEdit(false)}
                            onUpdated={() => window.location.reload()}
                        />
                    )}

                </div>
            );
        };


        const AdminSuggestionsModal = ({
            isOpen,
            onClose,
            suggestions = [],
            onApprove,
            onReject
        }) => {

            useEffect(() => {
                if (!isOpen) return;

                const handleKey = (e) => {
                    if (e.key === "Escape") onClose?.();
                };

                document.addEventListener("keydown", handleKey);
                document.body.style.overflow = "hidden";

                return () => {
                    document.removeEventListener("keydown", handleKey);
                    document.body.style.overflow = "";
                };
            }, [isOpen, onClose]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-[200] flex items-center justify-center p-4">

                    {/* Backdrop */}
                    <div
                        className="absolute inset-0 bg-black/90 backdrop-blur-sm transition-opacity duration-300"
                        onClick={onClose}
                    />

                    {/* Modal */}
                    <div
                        role="dialog"
                        aria-modal="true"
                        className="
                    relative w-full max-w-2xl
                    glass rounded-3xl p-8
                    animate-reveal
                    max-h-[80vh] flex flex-col
                    shadow-[0_30px_80px_rgba(0,0,0,0.7)]
                    border border-white/10
                "
                    >

                        {/* Subtle Glow Layer */}
                        <div className="absolute inset-0 rounded-3xl bg-gradient-to-br from-indigo-500/5 to-transparent pointer-events-none" />

                        {/* Header */}
                        <div className="relative z-10 flex justify-between items-center mb-6">

                            <h3 className="text-2xl font-black text-white tracking-tight">
                                Admin Dashboard
                            </h3>

                            <button
                                onClick={onClose}
                                className="
                            p-2 rounded-full
                            bg-white/5 backdrop-blur-md
                            border border-white/10
                            text-white
                            transition-all duration-300
                            hover:bg-white/10
                            hover:-translate-y-0.5
                            hover:shadow-[0_10px_40px_rgba(99,102,241,0.3)]
                        "
                            >
                                <Icon name="close" size={18} />
                            </button>
                        </div>

                        {/* Content */}
                        <div className="relative z-10 flex-1 overflow-y-auto space-y-4 custom-scrollbar pr-2">

                            {suggestions.length === 0 ? (
                                <EmptyState message="No pending suggestions" />
                            ) : (
                                suggestions.map((item) => (
                                    <div
                                        key={item.id}
                                        className="
                                    group flex items-center justify-between
                                    p-4 rounded-2xl
                                    bg-white/5 backdrop-blur-md
                                    border border-white/10
                                    transition-all duration-500
                                    ease-[cubic-bezier(0.16,1,0.3,1)]
                                    hover:bg-white/10
                                    hover:-translate-y-1
                                    hover:shadow-[0_15px_50px_rgba(99,102,241,0.2)]
                                "
                                    >

                                        {/* Info */}
                                        <div className="min-w-0">
                                            <p className="font-bold text-white truncate">
                                                {item.title}
                                            </p>

                                            <p className="text-xs text-slate-400 uppercase tracking-wider">
                                                {item.type}  {item.user_email}
                                            </p>
                                        </div>

                                        {/* Actions */}
                                        <div className="flex gap-2">

                                            <button
                                                onClick={() => onApprove?.(item)}
                                                className="
                                            p-2 rounded-xl
                                            bg-emerald-500/20 text-emerald-400
                                            transition-all duration-300
                                            hover:bg-emerald-500
                                            hover:text-white
                                            hover:shadow-[0_0_20px_rgba(16,185,129,0.5)]
                                        "
                                            >
                                                <Icon name="check" size={18} />
                                            </button>

                                            <button
                                                onClick={() => onReject?.(item)}
                                                className="
                                            p-2 rounded-xl
                                            bg-rose-500/20 text-rose-400
                                            transition-all duration-300
                                            hover:bg-rose-500
                                            hover:text-white
                                            hover:shadow-[0_0_20px_rgba(244,63,94,0.5)]
                                        "
                                            >
                                                <Icon name="trash" size={18} />
                                            </button>

                                        </div>

                                    </div>
                                ))
                            )}

                        </div>

                    </div>
                </div>
            );
        };


        const DetailModal = ({ item, onClose, onUpdateStatus, onRemove, isAdmin, watchHistory, topActors, onFixMapping }) => {
            if (!item) return null;

            const [activeTab, setActiveTab] = useState('overview');
            const backdrop = tmdbImg(item.tmdb?.credits?.images?.backdrops?.[0]?.file_path, "original") || getHighResPoster(item.Poster, 1000);

            const weightedRatingData = useMemo(() => {
                const ratings = extractUserRatings(item);
                if (ratings.length === 0) return null;
                return calculateWeightedRating(ratings, { minMinutes: 20, maxMinutesCap: 600 });
            }, [item]);

            const displayRating = weightedRatingData?.weightedRating ?? item.userMeta?.ratings?.overall ?? item.imdbRating ?? 'N/A';

            const ratingConfidenceLabel = useMemo(() => {
                if (!weightedRatingData) return null;
                const minutes = Math.max(...weightedRatingData.breakdown.map(b => b.minutesWatched));
                const confidence = ratingConfidence(minutes);
                if (confidence > 0.75) return 'High';
                if (confidence > 0.4) return 'Medium';
                return 'Low';
            }, [weightedRatingData]);

            const episodeProgress = useMemo(() => {
                const episodes = item.meta?.tvmaze?.episodes || item.meta?.series?.episodes || [];
                return calculateEpisodeProgress({ episodes, watchHistory });
            }, [item, watchHistory]);

            const seasonProgress = useMemo(() => {
                if (!item.meta?.tvmaze?.episodes || !item.userMeta?.watchHistory) return [];
                return calculateSeasonProgress({ episodes: item.meta.tvmaze.episodes, watchHistory: item.userMeta.watchHistory });
            }, [item]);

            const gapNudge = useMemo(() => {
                if (!episodeProgress || !episodeProgress.hasGaps) return null;
                if (episodeProgress.isCompleted) return null;
                if (episodeProgress.watchedEpisodes < 3) return null;
                const gaps = detectSeasonGaps({ episodes: item.meta?.tvmaze?.episodes || item.meta?.series?.episodes || [], watchHistory: watchHistory });
                if (gaps.length === 0) return null;
                const s = gaps[0];
                return { season: s.season, skipped: s.skipped, watched: s.watched };
            }, [episodeProgress, item, watchHistory]);

            const handleCatchUp = useCallback(() => {
                const episodes = item.meta?.tvmaze?.episodes || item.meta?.series?.episodes || [];
                if (!episodes.length || !watchHistory) return;
                const sortedEpisodes = [...episodes].sort((a, b) => a.season - b.season || a.episode - b.episode);
                const skippedTarget = sortedEpisodes.find(ep => resolveEpisodeState(ep.id, watchHistory).state === "skipped");
                if (skippedTarget) { onPlayEpisode?.(item, skippedTarget); return; }
                const unwatchedTarget = sortedEpisodes.find(ep => resolveEpisodeState(ep.id, watchHistory).state === "unwatched");
                if (unwatchedTarget) { onPlayEpisode?.(item, unwatchedTarget); }
            }, [item, watchHistory]);

            const scrollToSeason = (seasonNum) => {
                const el = document.getElementById(`season-${seasonNum}`);
                if (el) { el.scrollIntoView({ behavior: 'smooth', block: 'start' }); el.open = true; }
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 sm:p-6 lg:p-8 animate-fade-in">
                    <div className="absolute inset-0 bg-black/90 backdrop-blur-2xl" onClick={onClose}></div>
                    <div className="relative w-full max-w-6xl max-h-full glass rounded-[2rem] overflow-hidden flex flex-col lg:flex-row shadow-2xl border-white/10 animate-reveal">
                        
                        {/* Poster Side */}
                        <div className="relative w-full lg:w-[400px] h-64 lg:h-auto shrink-0 overflow-hidden">
                            <img src={getHighResPoster(item.Poster, 800)} alt={item.Title} loading="lazy" width="400" height="600" className="w-full h-full object-cover" />
                            <div className="absolute inset-0 bg-gradient-to-t from-vault-950 via-transparent lg:bg-gradient-to-r lg:from-transparent lg:to-vault-950"></div>
                            <button onClick={onClose} className="lg:hidden absolute top-4 right-4 bg-black/50 p-2 rounded-full text-white"><Icon name="close" /></button>
                        </div>

                        {/* Content Side */}
                        <div className="flex-1 flex flex-col overflow-hidden bg-vault-950">
                            <div className="p-8 pb-4 flex justify-between items-start">
                                <div>
                                    <div className="flex flex-wrap items-center gap-3 mb-2">
                                        <Badge color="gold">{item.Rated}</Badge>
                                        <Badge color="slate">{formatRuntime(item.Runtime)}</Badge>
                                        <span className="text-slate-400 text-sm font-medium">{item.Year}</span>
                                        {isAdmin && item._registry_source === 'cache' && <Badge color="slate">Registry: Cached</Badge>}
                                        {isAdmin && item._registry_source === 'api' && <Badge color="green">Registry: Fresh</Badge>}
                                    </div>
                                    <h1 className="text-3xl lg:text-5xl font-black text-white leading-tight">{item.Title}</h1>
                                    <div className="flex items-center gap-4 mt-2">
                                        <div className="text-2xl font-black text-white">{displayRating}</div>
                                        {weightedRatingData && (
                                            <div className="text-xs text-slate-400">Based on {weightedRatingData.contributingItems} viewing session{weightedRatingData.contributingItems > 1 ? 's' : ''}</div>
                                        )}
                                    </div>
                                    {topActors && topActors.some(a => item.meta?.cast?.some(c => normalizeActor(c.name) === a)) && (
                                        <div className="mt-3"><Badge color="gold">Features one of your favorite actors</Badge></div>
                                    )}
                                    <p className="text-indigo-400 font-bold mt-2 text-sm uppercase tracking-widest">{item.Genre}</p>
                                    {item.meta?.asian?.mdl && (
                                        <a href={item.meta.asian.mdl.url} target="_blank" rel="noreferrer" className="mt-2 text-xs text-emerald-400 flex items-center gap-1 font-bold hover:underline">View on MyDramaList <Icon name="external" size={12} /></a>
                                    )}
                                </div>
                                <div className="flex flex-col items-end gap-2">
                                    <button onClick={onClose} className="hidden lg:flex bg-white/5 hover:bg-white/10 p-3 rounded-full text-white transition-all"><Icon name="close" /></button>
                                    {isAdmin && (
                                        <button onClick={() => onFixMapping?.(item)}
                                            className="px-3 py-1.5 rounded-lg bg-indigo-500/20 hover:bg-indigo-500/30 text-xs text-indigo-300 font-bold transition-all">Fix External Mapping</button>
                                    )}
                                </div>
                            </div>

                            {gapNudge && (
                                <div className="mx-8 mb-6 p-4 rounded-2xl border border-amber-500/30 bg-amber-500/10 text-amber-300 flex items-start gap-3 animate-reveal">
                                    <Icon name="alert-circle" size={20} className="mt-0.5" />
                                    <div className="flex-1">
                                        <p className="font-semibold text-sm">You skipped {gapNudge.skipped} episode{gapNudge.skipped > 1 ? 's' : ''} in Season {gapNudge.season}</p>
                                        <p className="text-xs opacity-80 mt-1">Want to catch up before moving ahead?</p>
                                    </div>
                                    <button onClick={() => { setActiveTab('seasons'); }} className="text-xs font-semibold px-3 py-1.5 rounded-lg bg-amber-500/20 hover:bg-amber-500/30 transition">View episodes</button>
                                </div>
                            )}

                            <div className="px-8 flex gap-8 border-b border-white/5 overflow-x-auto no-scrollbar">
                                {['overview', 'details', 'cast', 'seasons'].map(tab => (
                                    (tab !== 'seasons' || item.Type === 'series') && (
                                        <button key={tab} onClick={() => setActiveTab(tab)} className={`py-4 text-sm font-bold uppercase tracking-widest transition-all border-b-2 ${activeTab === tab ? 'border-indigo-500 text-white' : 'border-transparent text-slate-500 hover:text-slate-300'}`}>{tab}</button>
                                    )
                                ))}
                            </div>

                            <div className="flex-1 p-8 overflow-y-auto custom-scrollbar">
                                {activeTab === 'overview' && (
                                    <div className="space-y-8 animate-reveal">
                                        {item.Awards && item.Awards !== "N/A" && (
                                            <div className="relative p-6 rounded-2xl bg-gradient-to-r from-amber-500/10 to-transparent border border-amber-500/20 flex items-start gap-4">
                                                <div className="p-3 bg-amber-500/20 rounded-full text-amber-400">
                                                    <Icon name="star" size={24} />
                                                </div>
                                                <div>
                                                    <h4 className="text-amber-400 font-black uppercase tracking-widest text-xs mb-1">Awards & Accolades</h4>
                                                    <p className="text-white font-bold text-lg leading-snug">{item.Awards}</p>
                                                </div>
                                            </div>
                                        )}
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                                            <div className="md:col-span-2 space-y-6">
                                                <div>
                                                    <h3 className="text-xs font-black uppercase tracking-[0.2em] text-indigo-400 mb-3">Synopsis</h3>
                                                    <p className="text-slate-300 text-lg leading-relaxed">{item.Plot}</p>
                                                </div>
                                                <div className="grid grid-cols-2 gap-4">
                                                    <div className="glass p-4 rounded-2xl"><p className="text-[10px] text-slate-500 uppercase font-black mb-1">Director</p><p className="text-white font-bold">{item.Director}</p></div>
                                                    <div className="glass p-4 rounded-2xl"><p className="text-[10px] text-slate-500 uppercase font-black mb-1">Writer</p><p className="text-white font-bold">{item.Writer}</p></div>
                                                </div>
                                            </div>
                                            <div className="space-y-4">
                                                <h3 className="text-xs font-black uppercase tracking-[0.2em] text-indigo-400 mb-3">Ratings</h3>
                                                <div className="space-y-2">
                                                    {Object.entries(item.meta?.ratingsExternal || {}).map(([key, val]) => val && (
                                                        <div key={key} className="flex items-center justify-between p-3 rounded-xl bg-white/5 border border-white/5">
                                                            <span className="text-xs font-bold text-slate-400 uppercase">{key}</span>
                                                            <span className="text-sm font-black text-white">{typeof val === 'object' ? val.rating : val}</span>
                                                        </div>
                                                    ))}
                                                    {item.meta?.asian?.mdl && (
                                                        <div className="flex items-center justify-between p-3 rounded-xl bg-teal-500/10 border border-teal-500/20">
                                                            <span className="text-xs font-bold text-teal-400 uppercase">MyDramaList</span>
                                                            <span className="text-sm font-black text-teal-400">{item.meta.asian.mdl.rating}</span>
                                                        </div>
                                                    )}
                                                </div>
                                                {weightedRatingData && (
                                                    <div className="mt-4 p-4 bg-white/5 rounded-xl border border-white/5">
                                                        <h4 className="text-xs font-bold text-slate-400 uppercase mb-3">Session Breakdown</h4>
                                                        <div className="flex items-baseline gap-2 mb-4">
                                                            <span className="text-4xl font-black text-gradient">{weightedRatingData.weightedRating}</span>
                                                            <span className="text-slate-400 text-sm">Weighted Score</span>
                                                            {ratingConfidenceLabel && (
                                                                <div className="ml-auto"><Badge color={ratingConfidenceLabel === "High" ? "green" : ratingConfidenceLabel === "Medium" ? "gold" : "red"}>{ratingConfidenceLabel} Confidence</Badge></div>
                                                            )}
                                                        </div>
                                                        <ul className="space-y-2 text-xs text-slate-300">
                                                            {weightedRatingData.breakdown.map((b, idx) => (
                                                                <li key={idx} className="flex justify-between items-center p-2 rounded bg-white/5">
                                                                    <span className="flex items-center gap-1"><Icon name="star" size={10} className="text-amber-400" /> {b.rating}</span>
                                                                    <span>{b.minutesWatched} min</span>
                                                                    <span className="text-slate-500">{b.confidence}</span>
                                                                </li>
                                                            ))}
                                                        </ul>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'details' && (
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-6 animate-reveal">
                                        {[
                                            { label: 'Language', value: item.Language },
                                            { label: 'Country', value: item.Country },
                                            { label: 'Released', value: item.Released },
                                            { label: 'Box Office', value: item.BoxOffice },
                                            { label: 'Production', value: item.Production },
                                        ].map(stat => (
                                            <div key={stat.label} className="space-y-1">
                                                <p className="text-[10px] text-slate-500 uppercase font-black">{stat.label}</p>
                                                <p className="text-white font-bold text-sm">{stat.value || 'N/A'}</p>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                {activeTab === 'cast' && (
                                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6 animate-reveal">
                                        {item.meta?.cast?.filter(person => person.photo).map(person => (
                                            <div key={person.name} className="flex flex-col items-center text-center gap-3 group">
                                                <div className="w-24 h-24 rounded-full overflow-hidden ring-2 ring-white/10 group-hover:ring-indigo-500/50 transition-all duration-300">
                                                    <img src={person.photo} alt={person.name} className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-500" />
                                                </div>
                                                <div>
                                                    <p className="text-white text-sm font-bold">{person.name}</p>
                                                    <p className="text-slate-500 text-[10px] uppercase font-bold tracking-wider">{person.character}</p>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                {activeTab === 'seasons' && item.meta?.series?.seasons && (
                                    <div className="space-y-4 animate-reveal">
                                        <SeasonHeatmap seasons={seasonProgress} onSeasonClick={(season) => { scrollToSeason(season); }} />
                                        {item.meta.series.seasons.map(season => (
                                            <details key={season.season} id={`season-${season.season}`} className="group glass rounded-2xl overflow-hidden transition-all duration-300">
                                                <summary className="flex items-center justify-between p-6 cursor-pointer hover:bg-white/5 list-none">
                                                    <div className="flex items-center gap-4">
                                                        <div className="w-12 h-12 bg-indigo-600 rounded-xl flex items-center justify-center font-black text-white">S{season.season}</div>
                                                        <div>
                                                            <h4 className="text-white font-bold">Season {season.season}</h4>
                                                            <p className="text-slate-500 text-xs font-medium">{season.episodes?.length || 0} Episodes  {season.airDate}</p>
                                                        </div>
                                                    </div>
                                                    <Icon name="play" size={16} className="text-slate-400 group-open:rotate-90 transition-transform" />
                                                </summary>
                                                <div className="px-6 pb-6 pt-2 divide-y divide-white/5">
                                                    {season.episodes?.map(ep => (
                                                        <div key={ep.episode} className="py-4 flex items-center justify-between group/ep">
                                                            <div className="flex gap-4">
                                                                <span className="text-indigo-400 font-mono text-sm">E{ep.episode}</span>
                                                                <div>
                                                                    <p className="text-white text-sm font-bold group-hover/ep:text-indigo-400 transition-colors">{ep.title}</p>
                                                                    <p className="text-slate-500 text-[10px] font-medium mt-0.5">{ep.airDate}</p>
                                                                </div>
                                                            </div>
                                                            {ep.watched && <Badge color="green">Watched</Badge>}
                                                        </div>
                                                    ))}
                                                </div>
                                            </details>
                                        ))}
                                    </div>
                                )}
                            </div>
                            <div className="p-8 pt-4 border-t border-white/5 flex gap-4 bg-vault-950/80 backdrop-blur-md">
                                <button onClick={() => onUpdateStatus('watched')} className={`flex-1 py-4 rounded-2xl font-black text-sm uppercase tracking-[0.2em] transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)] flex items-center justify-center gap-2 ${item.userMeta?.status === 'watched' ? 'bg-emerald-600 text-white shadow-[0_0_30px_rgba(16,185,129,0.4)]' : 'bg-white/5 text-slate-400 hover:text-white border border-white/5 hover:bg-white/10'}`}><Icon name="check" size={18} />Watched</button>
                                <button onClick={() => onUpdateStatus('watchlist')} className={`flex-1 py-4 rounded-2xl font-black text-sm uppercase tracking-[0.2em] transition-all flex items-center justify-center gap-2 ${item.userMeta?.status === 'watchlist' ? 'bg-indigo-600 text-white' : 'bg-white/5 text-slate-400 hover:text-white border border-white/5'}`}><Icon name="clock" size={18} />Watchlist</button>
                                <button onClick={() => onRemove(item.imdbID)} className="px-6 py-4 rounded-2xl bg-rose-500/10 text-rose-500 border border-rose-500/20 hover:bg-rose-500 hover:text-white transition-all flex items-center justify-center" title="Remove from Library"><Icon name="trash" size={20} /></button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const SearchOverlay = ({ isOpen, onClose, query, setQuery, results, onResultClick, isLoading, searchType, setSearchType, vault, isAdmin, onSuggest, onAdd }) => {
            if (!isOpen) return null;

            // Collect all library items for robust check
            const libraryItems = useMemo(() => [...Object.values(vault.watched), ...Object.values(vault.watchlist)], [vault]);

            const renderResultCard = (item, idx) => {
                const inVault = isInVault(item, libraryItems);

                return (
                    <div key={`${item.imdbID || item.id}-${item._sourceMeta?.source || 'unknown'}-${idx}`} onClick={() => onResultClick(item)} className="group relative p-6 rounded-2xl glass hover:border-indigo-500/40 transition-all duration-300 cursor-pointer flex gap-6 overflow-hidden hover:scale-[1.02]">
                        <div className="media-glow rounded-[2rem]"></div>
                        <div className="w-24 aspect-[2/3] rounded-xl overflow-hidden bg-slate-800 shrink-0 shadow-xl shadow-black/50 group-hover:shadow-indigo-500/30 transition-all duration-300 relative">
                            <img src={getHighResPoster(item.Poster, 200)} width="200" height="300" className="w-full h-full object-cover group-hover:scale-110 transition-transform duration-500" />
                            {item.confidence > 50 && <div className="absolute top-1 right-1 bg-green-500 text-white text-[9px] font-black px-1.5 py-0.5 rounded shadow">{Math.round(item.confidence)}% Match</div>}
                        </div>
                        <div className="flex-1 py-2 flex flex-col justify-center relative z-10">
                            <div className="flex items-start justify-between"><h4 className="text-xl font-black text-white group-hover:text-indigo-400 transition-colors duration-300 leading-tight line-clamp-2">{item.Title}</h4></div>
                            <p className="text-slate-500 font-bold uppercase tracking-widest text-[10px] mt-2">{item.Year}  {item.Type}</p>

                            {/* --- ACTION SECTION REPLACEMENT --- */}
                            {inVault ? (
                                <div className="mt-3 bg-emerald-600/20 text-emerald-400 px-4 py-2 rounded-xl text-sm font-semibold border border-emerald-500/30 text-center">
                                    Already in the Vault
                                </div>
                            ) : isAdmin ? (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onAdd(item);
                                    }}
                                    className="mt-3 w-full bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded-xl font-semibold transition shadow-lg shadow-indigo-600/20"
                                >
                                    Add to Library
                                </button>
                            ) : (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onSuggest(item);
                                    }}
                                    className="mt-3 w-full bg-amber-600/20 hover:bg-amber-600/30 text-amber-400 py-2 rounded-xl font-semibold border border-amber-500/30 transition"
                                >
                                    Suggest to Admin
                                </button>
                            )}

                            {item._searchDebug && (
                                <div className="mt-2 text-[10px] text-slate-400 space-y-0.5">{item._searchDebug.reasons.slice(0, 3).map(r => (<div key={r}> {humanizeReason(r)}</div>))}</div>
                            )}
                            <div className="mt-3 flex flex-wrap gap-2">{item.sourcesUsed?.slice(0, 3).map(s => (<span key={s} className="px-2 py-0.5 rounded bg-white/5 text-[9px] uppercase font-bold text-slate-400">{s}</span>))}</div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="fixed inset-0 z-[150] bg-vault-950/90 backdrop-blur-2xl animate-reveal p-4 lg:p-12 overflow-y-auto">
                    <div className="absolute inset-0 -z-10 bg-gradient-to-br from-indigo-500/10 via-transparent to-emerald-500/10"></div>
                    <div className="max-w-4xl mx-auto flex flex-col h-full">
                        <div className="flex flex-col gap-4 mb-12">
                            <div className="flex items-center gap-6">
                                <div className="flex-1 relative group">
                                    <Icon name="search" className="absolute left-6 top-1/2 -translate-y-1/2 text-slate-500 group-focus-within:text-indigo-500 transition-colors" size={24} />
                                    <input autoFocus type="text" placeholder="Search Movies, Shows, Anime, or Dramas..." value={query} onChange={(e) => setQuery(e.target.value)} className="w-full bg-white/5 border-2 border-white/10 focus:border-indigo-500/70 focus:ring-4 focus:ring-indigo-500/20 rounded-3xl py-6 pl-16 pr-8 text-2xl font-bold text-white outline-none transition-all duration-300 placeholder:text-slate-600 shadow-xl shadow-black/40" />
                                    {isLoading && <Icon name="refresh" className="absolute right-6 top-1/2 -translate-y-1/2 text-indigo-500 animate-spin" size={24} />}
                                </div>
                                <button onClick={onClose} className="p-4 rounded-full hover:bg-white/5 text-slate-400 hover:text-white transition-all"><Icon name="close" size={32} /></button>
                            </div>
                            <div className="flex gap-3 justify-center">
                                {['all', 'movie', 'series'].map(t => (
                                    <button key={t} onClick={() => setSearchType(t)} className={`px-6 py-2 rounded-xl font-bold uppercase tracking-wider text-xs transition-all duration-300 backdrop-blur-md${searchType === t ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-600/40 scale-[1.05]' : 'bg-white/5 text-slate-400 border border-white/10 hover:border-indigo-500/40 hover:text-white hover:bg-white/10'}`}>{t === 'all' ? 'All Sources' : t + 's'}</button>
                                ))}
                            </div>
                        </div>
                        <div className="flex-1 overflow-y-auto pr-2 no-scrollbar">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {results.primary && results.primary.map(renderResultCard)}
                            </div>

                            {results.more && results.more.length > 0 && (
                                <div className="mt-8">
                                    <h3 className="mb-6 text-sm text-slate-400 uppercase tracking-widest font-semibold border-b border-white/10 pb-3">More Results</h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {results.more.map(renderResultCard)}
                                    </div>
                                </div>
                            )}

                            {query.length > 2 && (!results.primary?.length && !results.more?.length) && !isLoading && (
                                <div className="col-span-full py-20 text-center animate-reveal">
                                    <h3 className="text-2xl font-black text-slate-500">No matches found</h3>
                                    <p className="text-slate-500 mt-2 font-medium">We checked TMDB, OMDb, TVMaze, Jikan & MDL.</p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- NEW TILE COMPONENTS ---

        const Tile = React.memo(
            React.forwardRef(
                (
                    {
                        as: Component = "div",
                        children,
                        className = "",
                        onClick,
                        interactive = !!onClick,
                        disabled = false,
                        ...props
                    },
                    ref
                ) => {
                    const baseClasses = `
        glass min-h-[220px] p-6 rounded-2xl
        transition-all duration-300 ease-[cubic-bezier(0.16,1,0.3,1)]
        will-change-transform
      `;

                    const interactiveClasses = interactive
                        ? `
          cursor-pointer
          hover:scale-[1.02]
          hover:shadow-[0_0_40px_rgba(99,102,241,0.25)]
          active:scale-[0.99]
          focus:outline-none
          focus-visible:ring-2
          focus-visible:ring-indigo-500/60
          focus-visible:ring-offset-2
          focus-visible:ring-offset-vault-950
        `
                        : "";

                    const disabledClasses = disabled
                        ? "opacity-50 cursor-not-allowed pointer-events-none"
                        : "";

                    return (
                        <Component
                            ref={ref}
                            onClick={disabled ? undefined : onClick}
                            tabIndex={interactive && !disabled ? 0 : undefined}
                            role={interactive ? "button" : undefined}
                            className={`${baseClasses} ${interactiveClasses} ${disabledClasses} ${className}`}
                            {...props}
                        >
                            {children}
                        </Component>
                    );
                }
            )
        );

        // --- STEP 2: CREATE HOMEPAGE COMPONENT ---
        const HomeTile = React.memo(
            ({
                title,
                subtitle,
                icon,
                onClick,
                gradient = "from-indigo-500 to-purple-600",
                disabled = false
            }) => {
                return (
                    <Tile
                        onClick={disabled ? undefined : onClick}
                        interactive={!disabled}
                        className={`
          relative group overflow-hidden
          transition-all duration-500 ease-[cubic-bezier(0.16,1,0.3,1)]
          ${disabled ? "opacity-50 cursor-not-allowed" : ""}
        `}
                    >
                        {/* Background gradient layer */}
                        <div
                            className={`absolute inset-0 opacity-20 bg-gradient-to-br ${gradient}`}
                        />

                        {/* Hover overlay */}
                        <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 bg-gradient-to-tr from-white/10 to-transparent" />

                        <div className="relative z-10 flex flex-col gap-5">
                            <div
                                className="
              w-12 h-12 rounded-xl
              bg-white/10
              flex items-center justify-center
              transition-all duration-300
              group-hover:scale-110
            "
                            >
                                <Icon name={icon} size={22} />
                            </div>

                            <div>
                                <h3 className="text-lg font-semibold text-white">
                                    {title}
                                </h3>
                                <p className="text-sm text-slate-400 mt-1">
                                    {subtitle}
                                </p>
                            </div>
                        </div>
                    </Tile>
                );
            }
        );


        const HomePage = React.memo(
            ({ setView, library = [], watchHistory = {}, onOpenSearch }) => {
                const stats = React.useMemo(() => {
                    let watched = 0;

                    for (const item of library) {
                        if (item.userMeta?.status === "watched") watched++;
                    }

                    return {
                        continueWatching: Object.keys(watchHistory).length,
                        watched,
                        total: library.length
                    };
                }, [library, watchHistory]);

                const tiles = [
                    {
                        title: "Movies",
                        subtitle: "Explore available movies",
                        icon: "play",
                        gradient: "from-indigo-500 to-purple-600",
                        onClick: () => setView(VIEWS.MOVIES)
                    },
                    {
                        title: "Series",
                        subtitle: "Explore available series",
                        icon: "grid",
                        gradient: "from-emerald-500 to-teal-600",
                        onClick: () => setView(VIEWS.SERIES)
                    },
                    {
                        title: "Analytics Dashboard",
                        subtitle: "View your watch statistics",
                        icon: "trending",
                        gradient: "from-amber-500 to-orange-600",
                        onClick: () => setView(VIEWS.PROFILE)
                    },
                    {
                        title: "Continue Watching",
                        subtitle: `${stats.continueWatching} items in progress`,
                        icon: "clock",
                        gradient: "from-sky-500 to-indigo-600",
                        onClick: () => setView(VIEWS.LIBRARY)
                    },
                    {
                        title: "Rewatch",
                        subtitle: `${stats.watched} completed titles`,
                        icon: "refresh",
                        gradient: "from-pink-500 to-rose-600",
                        onClick: () => setView(VIEWS.LIBRARY)
                    },
                    {
                        title: "Suggest to Admin",
                        subtitle: "Request a movie or series",
                        icon: "plus",
                        gradient: "from-violet-500 to-indigo-700",
                        onClick: onOpenSearch
                    }
                ];

                return (
                    <div className="p-8 max-w-7xl mx-auto space-y-12">
                        {/* Hero */}
                        <div className="profile-hero rounded-3xl glass p-12 relative overflow-hidden">
                            <h1 className="text-4xl font-bold text-gradient mb-3">
                                Welcome to The Vault
                            </h1>
                        </div>

                        {/* Tiles Grid */}
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {tiles.map((tile, index) => (
                                <HomeTile key={index} {...tile} />
                            ))}
                        </div>
                    </div>
                );
            }
        );
        // ==========================================
        // SECTION 6: MAIN APPLICATION COMPONENT
        // ==========================================
        // --- START OF MISSING COMPONENTS ---

        // 1. DashboardTile (Helper for the tiles)
        const DashboardTile = ({ title, value, icon, subtext, gradient, onClick }) => {
            return (
                <div 
                    onClick={onClick} 
                    className={`
                        relative overflow-hidden rounded-3xl p-6 glass group 
                        transition-all duration-300 hover:scale-[1.02] hover:shadow-2xl 
                        ${onClick ? 'cursor-pointer' : 'cursor-default'}
                    `}
                >
                    <div className={`absolute inset-0 opacity-10 bg-gradient-to-br ${gradient}`}></div>
                    <div className="relative z-10 flex flex-col justify-between h-full">
                        <div className="flex justify-between items-start mb-4">
                            <div className="p-3 rounded-2xl bg-white/5 text-white backdrop-blur-md">
                                <Icon name={icon} size={24} />
                            </div>
                            {onClick && <Icon name="external" size={16} className="text-slate-500 group-hover:text-white transition-colors" />}
                        </div>
                        <div>
                            <h4 className="text-3xl font-black text-white mb-1">{value}</h4>
                            <p className="text-sm font-bold text-slate-400 uppercase tracking-wider">{title}</p>
                            {subtext && <p className="text-xs text-slate-500 mt-2 font-medium">{subtext}</p>}
                        </div>
                    </div>
                </div>
            );
        };

        // 2. MoviesTile
        const MoviesTile = ({ library, setView }) => {
            // Safety check: ensure library is an array
            const safeLibrary = Array.isArray(library) ? library : [];
            const count = safeLibrary.filter(i => i.Type === 'movie').length;
            
            return (
                <DashboardTile 
                    title="Movies" 
                    value={count} 
                    icon="play" 
                    gradient="from-indigo-500 to-purple-600" 
                    onClick={() => setView('movies')} 
                />
            );
        };

        // 3. SeriesTile
        const SeriesTile = ({ library, setView }) => {
            const safeLibrary = Array.isArray(library) ? library : [];
            const count = safeLibrary.filter(i => i.Type === 'series').length;
            
            return (
                <DashboardTile 
                    title="Series" 
                    value={count} 
                    icon="grid" 
                    gradient="from-emerald-500 to-teal-600" 
                    onClick={() => setView('series')} 
                />
            );
        };

        // 4. ContinueTile
        const ContinueTile = ({ library }) => {
            const safeLibrary = Array.isArray(library) ? library : [];
            const count = safeLibrary.filter(i => 
                i.Type === 'series' && 
                i.userMeta?.watchHistory && 
                Object.keys(i.userMeta.watchHistory).length > 0 && 
                i.userMeta.status !== 'watched'
            ).length;
            
            return (
                <DashboardTile 
                    title="In Progress" 
                    value={count} 
                    icon="clock" 
                    gradient="from-amber-500 to-orange-600" 
                />
            );
        };

        // 5. RewatchTile
        const RewatchTile = ({ library }) => {
            const safeLibrary = Array.isArray(library) ? library : [];
            const count = safeLibrary.filter(i => i.userMeta?.status === 'watched').length;
            
            return (
                <DashboardTile 
                    title="Completed" 
                    value={count} 
                    icon="check" 
                    gradient="from-pink-500 to-rose-600" 
                />
            );
        };

        // 6. AnalyticsTile
        const AnalyticsTile = ({ library }) => {
            const safeLibrary = Array.isArray(library) ? library : [];
            const totalMinutes = safeLibrary.reduce((acc, item) => acc + (item.minutesWatched || 0), 0);
            const hours = Math.round(totalMinutes / 60);
            
            return (
                <DashboardTile 
                    title="Hours Watched" 
                    value={hours} 
                    icon="trending" 
                    gradient="from-cyan-500 to-blue-600" 
                />
            );
        };

        // 7. SuggestTile
        const SuggestTile = ({ user, supabase }) => {
            return (
                <div className="relative overflow-hidden rounded-3xl p-6 glass flex items-center justify-center group cursor-pointer transition-all hover:scale-[1.02] border-2 border-dashed border-white/10 hover:border-indigo-500/50">
                    <div className="text-center">
                        <div className="w-12 h-12 mx-auto bg-indigo-500/20 text-indigo-400 rounded-full flex items-center justify-center mb-3 group-hover:bg-indigo-500 group-hover:text-white transition-all">
                            <Icon name="plus" size={24} />
                        </div>
                        <h4 className="font-bold text-white">Suggest Content</h4>
                        <p className="text-xs text-slate-500 mt-1">Request new titles</p>
                    </div>
                </div>
            );
        };

        // --- END OF MISSING COMPONENTS ---
        function App() {
            const [session, setSession] = useState(null);
            const [vault, setVault] = useState({ watched: {}, watchlist: {} });
            const [apiKeys, setApiKeys] = useState(DEFAULT_KEYS);
            const [viewMode, setViewMode] = useState('grid');
            // --- STEP 3: SET DEFAULT VIEW TO HOME ---
            const [currentView, setCurrentView] = useState(VIEWS.HOME);
            const [isAdmin, setIsAdmin] = useState(false);

            useEffect(() => {
                const initAdmin = async () => {
                    const { data } = await supabase.auth.getUser();
                    setIsAdmin(isAdminUser(data?.user));
                };
                initAdmin();
            }, []);

            // --- USE REALTIME HOOKS ---
            const library = useRealtimeLibrary(); // The global list
            const adminSuggestions = useAdminSuggestions(session?.user);
            const userSuggestions = useUserSuggestions(session?.user);

            // --- MERGE LOGIC: Global Library + User Status ---
            const allVaultItems = useMemo(() => {
                // If library is populated, use it as base. Otherwise fallback to old vault logic (but prefer library)
                if (library.length > 0) {
                    return library.map(item => {
                        const userItem = vault.watched[item.imdbID] || vault.watchlist[item.imdbID];
                        // Merge the enriched data (in item.data) with top-level columns and user status
                        return {
                            ...item.data,
                            ...item,
                            userMeta: userItem?.userMeta || { status: null },
                            _inLibrary: true
                        };
                    });
                }
                // Fallback for transition
                return [...Object.values(vault.watched), ...Object.values(vault.watchlist)];
            }, [library, vault]);

            const handleResume = (item, resume) => {
                const intent = { imdbID: item.imdbID, episodeId: resume.episodeId, season: resume.season, episode: resume.episode, resumeFrom: resume.resumeFrom };
                console.log("Resume Intent:", intent);
                alert(`Resuming ${item.Title} S${resume.season}E${resume.episode} at ${Math.round(resume.resumeFrom * 100)}%`);
            };

            const continueWatching = useMemo(() => {
                return allVaultItems.map(item => {
                    if (item.Type !== 'series' || !item.meta?.tvmaze?.episodes || !item.userMeta?.watchHistory) return null;
                    const resume = getResumeTarget({ episodes: item.meta.tvmaze.episodes, watchHistory: item.userMeta.watchHistory });
                    if (!resume) return null;
                    return { item, resume };
                }).filter(Boolean);
            }, [allVaultItems]);

            const genreInputs = useMemo(() => {
                return allVaultItems.map(item => {
                    let minutes = 0;
                    if (item.Type === 'movie') {
                        const runtime = parseInt(item.Runtime) || 0;
                        if (item.userMeta?.status === 'watched') minutes = runtime || 100;
                    } else if (item.Type === 'series') {
                        const progress = calculateEpisodeProgress({ episodes: item.meta?.tvmaze?.episodes || [], watchHistory: item.userMeta?.watchHistory });
                        minutes = (progress?.watchedEpisodes || 0) * 45;
                    }
                    return { ...item, minutesWatched: minutes };
                });
            }, [allVaultItems]);

            const genreProfile = useMemo(() => {
                const genreItems = extractGenreItems(genreInputs);
                if (genreItems.length === 0) return null;
                return getGenreProfile(genreItems, { useRecency: true, recencyHalfLifeDays: 180 });
            }, [genreInputs]);

            const actorProfile = useMemo(() => {
                const actorItems = extractActorItems(genreInputs);
                if (actorItems.length === 0) return null;
                const progressMap = buildProgressMap(actorItems);
                return getActorPopularityProfile({ items: actorItems, progressMap });
            }, [genreInputs]);

            const asianContent = useMemo(() => { return allVaultItems.filter(i => i.meta?.asian); }, [allVaultItems]);
            const asianDrama = useMemo(() => { return asianContent.filter(i => /drama/i.test(i.Genre || '')); }, [asianContent]);
            const anime = useMemo(() => { return allVaultItems.filter(i => i.meta?.anime); }, [allVaultItems]);

            const topActors = useMemo(() => {
                if (!actorProfile?.percent) return [];
                return Object.entries(actorProfile.percent).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([actor]) => actor);
            }, [actorProfile]);

            const actorDrivenRecs = useMemo(() => {
                return allVaultItems
                    .filter(i => i.userMeta?.status !== 'watched')
                    .map(i => ({ item: i, score: actorAffinityScore(i, topActors) }))
                    .filter(r => r.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .map(r => r.item);
            }, [allVaultItems, topActors]);

            const topGenres = useMemo(() => {
                if (!genreProfile?.percent) return [];
                return Object.entries(genreProfile.percent).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([g]) => g);
            }, [genreProfile]);

            const recommended = useMemo(() => {
                if (!topGenres.length) return [];
                return allVaultItems
                    .filter(i => i.userMeta?.status !== 'watched')
                    .map(i => {
                        let score = genreAffinityScore(i, topGenres);
                        if (i.meta?.asian?.mdl?.rating >= 8.5) { score += 1.5; }
                        return { item: i, score };
                    })
                    .filter(r => r.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .map(r => r.item)
                    .slice(0, 5);
            }, [allVaultItems, topGenres]);

            const exploreOutside = useMemo(() => {
                if (!topGenres.length) return [];
                return allVaultItems
                    .filter(i => {
                        const itemGenres = extractGenres(i.Genre);
                        return !itemGenres.some(g => topGenres.includes(g));
                    })
                    .slice(0, 5);
            }, [allVaultItems, topGenres]);

            const approveSuggestion = async (item) => {
                if (!isAdmin) return;
                await supabase.from('content_suggestions').update({ status: 'approved', updated_at: new Date() }).eq('id', item.id);
            };

            const rejectSuggestion = async (item) => {
                if (!isAdmin) return;
                await supabase.from('content_suggestions').update({ status: 'rejected', updated_at: new Date() }).eq('id', item.id);
            };

            // --- STEP 3: ADMIN ADD HANDLER ---
            async function handleAdminAdd(item) {
                const enriched = await enrichItem(item, DEFAULT_KEYS, supabase, true);

                const { error } = await supabase
                    .from('library')
                    .upsert({
                        imdbID: enriched.imdbID,
                        Title: enriched.Title,
                        Year: enriched.Year,
                        Poster: enriched.Poster,
                        Type: enriched.Type,
                        data: enriched
                    });

                if (error) {
                    console.error("Insert failed:", error);
                    alert("Failed to add to Global Library");
                } else {
                    alert("Added to Global Library!");
                    setIsSearchOpen(false);
                }
            }

            const handleApproveSuggestion = async (suggestion) => {
                if (!isAdmin) return;

                // 1. Map suggestion data to Vault Item format
                const vaultItemBase = {
                    Title: suggestion.title,
                    Year: suggestion.year,
                    imdbID: suggestion.imdb_id, // Match DB column name
                    Poster: suggestion.poster,
                    Type: 'movie',
                    userMeta: { status: 'watchlist', lastUpdated: Date.now() }
                };

                // 2. Call the robust Admin Add
                await handleAdminAdd(vaultItemBase);

                // 3. Mark suggestion as approved
                await supabase
                    .from('suggestions')
                    .update({ status: 'approved' })
                    .eq('id', suggestion.id);
            };

            const handleRejectSuggestion = async (suggestion) => {
                if (!isAdmin) return;
                await supabase
                    .from('suggestions')
                    .update({ status: 'rejected' })
                    .eq('id', suggestion.id);
            };

            // --- New Handler: Suggestion ---
            const handleSuggestToAdmin = async (item) => {
                if (!session?.user) return alert("Please sign in to make suggestions.");

                const { error } = await supabase.from('suggestions').insert({
                    title: item.Title,
                    imdb_id: item.imdbID,
                    year: item.Year,
                    poster: item.Poster,
                    suggested_by: session.user.id,
                    status: 'pending'
                });

                if (error) {
                    alert("Error sending suggestion: " + error.message);
                } else {
                    alert("Suggestion sent to Admin!");
                    setIsSearchOpen(false);
                }
            };

            function adminClearCache() {
                if (!isAdmin) return;
                clearAllCache();
                console.info("Admin cache cleared");
            }

            function adminDebugSnapshot() {
                if (!isAdmin) return;
                console.table({ user: 'admin', cacheEntries: getCacheStats?.()?.totalEntries, time: new Date().toISOString() });
            }

            const [isSearchOpen, setIsSearchOpen] = useState(false);
            const [searchQuery, setSearchQuery] = useState('');
            // --- UPDATED STATE: Handle structured results ---
            const [searchResults, setSearchResults] = useState({ primary: [], more: [] });
            const [isSearchLoading, setIsSearchLoading] = useState(false);
            const [searchType, setSearchType] = useState('all');
            const [activeFilter, setActiveFilter] = useState('all');

            const [selectedItem, setSelectedItem] = useState(null);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isAdminSuggestionsOpen, setIsAdminSuggestionsOpen] = useState(false);
            const [adminSuggestionsData, setAdminSuggestions] = useState([]);

            const [isRefreshing, setIsRefreshing] = useState(false);
            const [refreshProgress, setRefreshProgress] = useState(0);

            const fetchOmdb = async (imdbID) => {
                const res = await fetch(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${imdbID}&plot=full`);
                return await res.json();
            };

            const fetchSearch = async (query) => {
                if (!query || query.length < 3) return;
                setIsSearchLoading(true);
                try {
                    // --- UPDATED LOGIC: Handle structured return ---
                    const results = await smartSearch(query, apiKeys, searchType);

                    const processList = (list) => list.map(item => ({
                        ...item,
                        // Use global helper instead of simple ID check
                        inVault: isInVault(item, allVaultItems)
                    }));

                    setSearchResults({
                        primary: processList(results.primary),
                        more: processList(results.more)
                    });
                } catch (e) { console.error(e); }
                setIsSearchLoading(false);
            };

            const fetchTrailer = async (item) => {
                let tmdbId = item.tmdb?.id;
                const type = item.Type === 'series' ? 'tv' : 'movie';

                if (!tmdbId) {
                    try {
                        const findRes = await fetch(`https://api.themoviedb.org/3/find/${item.imdbID}?api_key=${apiKeys.tmdb}&external_source=imdb_id`);
                        const findData = await findRes.json();
                        const media = item.Type === 'movie' ? findData.movie_results?.[0] : findData.tv_results?.[0];
                        if (media) tmdbId = media.id;
                    } catch (e) { }
                }

                if (!tmdbId) {
                    alert("Could not find trailer for this title.");
                    return null;
                }

                try {
                    const res = await fetch(`https://api.themoviedb.org/3/${type}/${tmdbId}/videos?api_key=${apiKeys.tmdb}`);
                    const data = await res.json();
                    const trailer = data.results?.find(v => v.type === "Trailer" && v.site === "YouTube")
                        || data.results?.find(v => v.type === "Teaser" && v.site === "YouTube")
                        || data.results?.find(v => v.site === "YouTube");

                    if (!trailer) {
                        alert("No YouTube trailer available.");
                        return null;
                    }
                    return trailer.key;
                } catch (e) {
                    alert("Error fetching trailer.");
                    return null;
                }
            }

            const handlePlayTrailer = async (item) => {
                const videoId = await fetchTrailer(item);
                if (videoId) {
                    window.open(`https://www.youtube.com/watch?v=${videoId}`, '_blank');
                }
            };

            const updateVaultItem = (id, updatedItem) => {
                setVault(prev => {
                    const status = updatedItem.userMeta?.status || 'watchlist';
                    const newVault = { ...prev };
                    delete newVault.watched[id];
                    delete newVault.watchlist[id];
                    newVault[status][id] = updatedItem;
                    return newVault;
                });
            };

            const enrich = async (item) => {
                // --- FIX: Check for "N/A" or missing data before skipping ---
                const hasMissingData = 
                    !item.Director || item.Director === "N/A" || 
                    !item.Writer || item.Writer === "N/A" || 
                    !item.Plot || item.Plot === "N/A";

                // Only skip if the item is enriched AND has no missing data
                if (!hasMissingData && item.enriched && item.enrichmentSources?.length > 0) {
                    return item;
                }

                const enrichedItem = await enrichItem(item, apiKeys, supabase, isAdmin);
                
                if (enrichedItem) {
                    updateVaultItem(item.imdbID, enrichedItem);
                    if (selectedItem?.imdbID === item.imdbID) {
                        setSelectedItem(enrichedItem);
                    }
                    if (session) {
                        const currentStatus = item.userMeta?.status || 'watchlist';
                        const updatedUserMeta = { ...enrichedItem, userMeta: { ...enrichedItem.userMeta, status: currentStatus, lastUpdated: Date.now() } };
                        supabase.from('vault_items').upsert({ user_id: session.user.id, imdb_id: item.imdbID, user_meta: updatedUserMeta, updated_at: new Date() });
                    }
                }
                return enrichedItem;
            };

            const toggleStatus = (item, newStatus) => {
                const updated = { ...item, userMeta: { ...item.userMeta, status: newStatus, lastUpdated: Date.now() } };
                updateVaultItem(item.imdbID, updated);
                setSelectedItem(updated);
                if (session) {
                    supabase.from('vault_items').upsert({ user_id: session.user.id, imdb_id: item.imdbID, user_meta: updated, updated_at: new Date() });
                }
            };

            const addToVault = async (imdbID) => {
                const data = await fetchOmdb(imdbID);
                if (!data || data.Response === "False") return;
                let item = { ...data, userMeta: { status: 'watchlist', lastUpdated: Date.now() }, meta: { ratingsExternal: { imdb: data.imdbRating } } };
                updateVaultItem(imdbID, item);
                setIsSearchOpen(false);
                setSelectedItem(item);
                await enrich(item);
            };

            const removeFromVault = async (imdbID) => {
                if (!confirm("Are you sure you want to delete this from your library?")) return;
                setVault(prev => {
                    const next = { watched: { ...prev.watched }, watchlist: { ...prev.watchlist } };
                    delete next.watched[imdbID];
                    delete next.watchlist[imdbID];
                    return next;
                });
                setSelectedItem(null);
                if (session) {
                    await supabase.from('vault_items').delete().eq('user_id', session.user.id).eq('imdb_id', imdbID);
                }
            };

            const refreshLibrary = async () => {
                if (isRefreshing) return;
                setIsRefreshing(true);
                setRefreshProgress(0);
                const allItems = [...Object.values(vault.watched), ...Object.values(vault.watchlist)];
                let processed = 0;
                for (const item of allItems) {
                    try {
                        const freshBase = await fetchOmdb(item.imdbID);
                        if (freshBase && freshBase.Response === 'True') {
                            const merged = { ...freshBase, userMeta: item.userMeta, meta: item.meta || {}, tmdb: null, enriched: false };
                            await enrich(merged);
                        }
                    } catch (e) { console.error("Refresh failed for", item.Title, e); }
                    processed++;
                    setRefreshProgress(Math.round((processed / allItems.length) * 100));
                    await new Promise(r => setTimeout(r, 250));
                }
                setIsRefreshing(false);
                alert("Library updated successfully!");
            };

            const handleExport = () => {
                const dataStr = JSON.stringify(vault, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', `vault_backup_${new Date().toISOString().slice(0, 10)}.json`);
                linkElement.click();
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.watched || data.watchlist) { setVault(data); alert("Vault imported successfully! (Local only)"); }
                        else { alert("Invalid vault format"); }
                    } catch (err) { alert("Error reading file"); }
                };
                reader.readAsText(file);
            };

            useEffect(() => {
                const timer = setTimeout(() => fetchSearch(searchQuery), 500);
                return () => clearTimeout(timer);
            }, [searchQuery, searchType]);

            useEffect(() => {
                supabase.auth.getSession().then(({ data }) => setSession(data.session));
                supabase.auth.onAuthStateChange((_event, session) => setSession(session));
            }, []);

            useEffect(() => {
                if (!session) return;
                supabase.from('vault_items').select('*').then(({ data }) => {
                    if (data) {
                        const newVault = { watched: {}, watchlist: {} };
                        data.forEach(row => {
                            const item = row.user_meta;
                            newVault[item.userMeta.status][item.imdbID] = item;
                        });
                        setVault(newVault);
                    }
                });
            }, [session]);

            useEffect(() => {
                if (selectedItem) {
                    const freshItem = vault.watched[selectedItem.imdbID] || vault.watchlist[selectedItem.imdbID];
                    if (freshItem && freshItem !== selectedItem) { setSelectedItem(freshItem); }
                }
            }, [vault, selectedItem]);

            const filteredItems = useMemo(() => {
                const all = allVaultItems;
                return all.filter(item => {
                    // --- NEW VIEW MODE SUPPORT ---
                    if (currentView === VIEWS.MOVIES) return item.Type === 'movie';
                    if (currentView === VIEWS.SERIES) return item.Type === 'series';

                    if (activeFilter === 'all') return true;
                    if (activeFilter === 'movies') return item.Type === 'movie';
                    if (activeFilter === 'shows') return item.Type === 'series';
                    return true;
                }).sort((a, b) => (b.userMeta?.lastUpdated || 0) - (a.userMeta?.lastUpdated || 0));
            }, [allVaultItems, activeFilter, currentView]);

            return (
                <div className="min-h-screen bg-vault-950 flex flex-col">
                    <nav className="sticky top-0 z-50 glass border-b border-white/5 px-6 h-20 flex items-center justify-between">
                        {/* Logo Group - Clicking this still takes you Home */}
                        <div className="flex items-center gap-8">
                            <div className="flex items-center gap-3 group cursor-pointer" onClick={() => { setCurrentView(VIEWS.HOME); setActiveFilter('all'); }}>
                                <div className="group-hover:scale-110 transition-transform flex items-center justify-center"><VaultLogo size={44} className="text-indigo-500" /></div>
                                <div className="flex flex-col"><span className="text-xl font-black text-white uppercase tracking-tighter leading-none">The Vault</span></div>
                            </div>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="h-10 w-[1px] bg-white/5 mx-2"></div>
                            {session ? (
                                <div className="flex items-center gap-3">
                                    <button onClick={() => setIsSettingsOpen(true)} className="p-2.5 bg-white/5 rounded-xl text-slate-400 hover:text-white transition-all"><Icon name="settings" /></button>
                                    <button onClick={() => setCurrentView(VIEWS.PROFILE)} className={`w-10 h-10 rounded-xl flex items-center justify-center font-bold text-white transition ${currentView === VIEWS.PROFILE ? 'bg-indigo-600 shadow-lg shadow-indigo-500/40 scale-105' : 'bg-gradient-to-br from-indigo-500 to-purple-600 hover:scale-105 shadow-lg shadow-indigo-500/30'}`}>{session.user.email?.[0]?.toUpperCase()}</button>
                                </div>
                            ) : (
                                <GlassButton onClick={() => setIsSettingsOpen(true)} active icon="user">Sign In</GlassButton>
                            )}
                        </div>
                    </nav>

                    <main className="flex-1 relative z-10 px-6 md:px-10 max-w-[1400px] mx-auto w-full py-12">
                        {/* --- STEP 4: RENDER HOMEPAGE IN VIEW SWITCH --- */}
                        {currentView === VIEWS.PROFILE && session ? (
                            <ProfileView
                                user={session.user}
                                libraryItems={allVaultItems}
                                onBack={() => setCurrentView(VIEWS.HOME)}
                                adminSuggestions={adminSuggestions}
                                onApproveSuggestion={handleApproveSuggestion}
                                onRejectSuggestion={handleRejectSuggestion}
                                userSuggestions={userSuggestions}
                            />
                        ) : currentView === VIEWS.HOME ? (
                            <HomePage
                                setView={setCurrentView}
                                library={allVaultItems}
                                watchHistory={vault.watched}
                                onOpenSearch={() => setIsSearchOpen(true)}
                            />
                        ) : (
                            <>
                                {currentView === VIEWS.LIBRARY && activeFilter === 'all' && (
                                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 mb-16 animate-reveal">
                                        <MoviesTile library={allVaultItems} setView={setCurrentView} />
                                        <SeriesTile library={allVaultItems} setView={setCurrentView} />
                                        <ContinueTile library={allVaultItems} />
                                        <RewatchTile library={allVaultItems} />
                                        <SuggestTile user={session?.user} supabase={supabase} />
                                        <AnalyticsTile library={genreInputs} />
                                    </div>
                                )}

                                <ContentRail title="Continue Watching" icon="play" items={continueWatching.map(cw => cw.item)} onCardClick={(item) => handleResume(item, continueWatching.find(cw => cw.item.imdbID === item.imdbID).resume)} />
                                {asianDrama.length > 0 && <ContentRail title="Asian Dramas" icon="globe" items={asianDrama} onCardClick={(item) => { setSelectedItem(item); enrich(item); }} />}
                                {anime.length > 0 && <ContentRail title="Anime" icon="star" items={anime} onCardClick={(item) => { setSelectedItem(item); enrich(item); }} />}
                                {genreProfile?.totalWeight > 50 && (
                                    <>
                                        <ContentRail title="Actor Spotlight" icon="user" items={actorDrivenRecs} onCardClick={(item) => { setSelectedItem(item); enrich(item); }} />
                                        <ContentRail title="Recommended for You" icon="star" items={recommended} onCardClick={(item) => { setSelectedItem(item); enrich(item); }} />
                                        <ContentRail title="Outside Comfort Zone" icon="globe" items={exploreOutside} onCardClick={(item) => { setSelectedItem(item); enrich(item); }} />
                                    </>
                                )}
                                {filteredItems.length > 0 && activeFilter === 'all' && currentView === VIEWS.LIBRARY && (
                                    <section className="mb-16 animate-reveal">
                                        <div className="relative h-[500px] w-full rounded-[3rem] overflow-hidden group shadow-2xl">
                                            <img src={tmdbImg(filteredItems[0].tmdb?.credits?.images?.backdrops?.[0]?.file_path, "original") || getHighResPoster(filteredItems[0].Poster, 1000)} className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-[2s]" />
                                            <div className="absolute inset-0 bg-gradient-to-t from-vault-950 via-vault-950/40 to-transparent"></div>
                                            <div className="absolute bottom-12 left-12 right-12 flex flex-col lg:flex-row lg:items-end justify-between gap-8">
                                                <div className="max-w-2xl">
                                                    <div className="flex items-center gap-3 mb-4">
                                                        <Badge color="gold">Spotlight</Badge>
                                                        <Badge color="indigo">{filteredItems[0].Year}</Badge>
                                                        <span className="text-white/60 text-sm font-bold tracking-widest uppercase">{filteredItems[0].Genre}</span>
                                                    </div>
                                                    <h2 className="text-5xl lg:text-7xl font-black text-white tracking-tight mb-4">{filteredItems[0].Title}</h2>
                                                    <p className="text-slate-400 text-lg line-clamp-3 mb-8">{filteredItems[0].Plot}</p>
                                                    <div className="flex gap-4">
                                                        <button onClick={() => setSelectedItem(filteredItems[0])} className="px-8 py-4 bg-white text-black font-black uppercase tracking-widest rounded-2xl hover:bg-indigo-500 hover:text-white transition-all shadow-xl shadow-white/10">View Details</button>
                                                        <button onClick={() => handlePlayTrailer(filteredItems[0])} className="px-8 py-4 bg-white/10 backdrop-blur-md text-white border border-white/10 font-black uppercase tracking-widest rounded-2xl hover:bg-white/20 transition-all flex items-center gap-2"><Icon name="play" size={20} /> Watch Trailer</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </section>
                                )}
                                <section className="space-y-8">
                                    <div className="flex items-center justify-between">
                                        <h3 className="text-2xl font-black text-white flex items-center gap-3">Your Library<span className="px-2 py-0.5 rounded-md bg-white/5 text-slate-500 text-xs font-bold uppercase">{filteredItems.length} Items</span></h3>
                                        <div className="flex items-center gap-3">
                                            <GlassButton active={viewMode === 'grid'} onClick={() => setViewMode('grid')} icon="grid">Grid</GlassButton>
                                            <GlassButton active={viewMode === 'timeline'} onClick={() => setViewMode('timeline')} icon="list">Timeline</GlassButton>
                                        </div>
                                    </div>
                                    {filteredItems.length === 0 ? (
                                        <div className="py-40 flex flex-col items-center text-center">
                                            <div className="w-24 h-24 rounded-[2.5rem] bg-white/5 flex items-center justify-center text-slate-700 mb-6"><Icon name="database" size={48} /></div>
                                            <h4 className="text-2xl font-black text-slate-400 uppercase tracking-widest">Vault is Empty</h4>
                                            <p className="text-slate-600 mt-2 font-medium">Search for movies or shows to start your collection.</p>
                                            {/* --- SEARCH BUTTON ONLY ADDS IF ADMIN --- */}
                                            <button onClick={() => setIsSearchOpen(true)} className="mt-8 px-6 py-3 bg-indigo-600/10 text-indigo-400 border border-indigo-500/20 rounded-xl font-bold hover:bg-indigo-600 hover:text-white transition-all">{isAdmin ? "Add First Title" : "Suggest First Title"}</button>
                                        </div>
                                    ) : (
                                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-8 gap-y-12">
                                            {filteredItems.map(item => (
                                                <MediaCard key={item.imdbID || item.id} item={item} isAdmin={isAdmin} onClick={() => { setSelectedItem(item); enrich(item); }} onPlayTrailer={handlePlayTrailer} onAdminEdit={(i) => console.log("Edit", i)} onResume={handleResume} />
                                            ))}
                                        </div>
                                    )}
                                </section>
                            </>
                        )}
                    </main>

                    <DetailModal item={selectedItem} onClose={() => setSelectedItem(null)} onUpdateStatus={toggleStatus} onRemove={removeFromVault} isAdmin={isAdmin} watchHistory={vault.watched} topActors={topActors} />
                    <SearchOverlay
                        isOpen={isSearchOpen}
                        onClose={() => setIsSearchOpen(false)}
                        query={searchQuery}
                        setQuery={setSearchQuery}
                        results={searchResults}
                        onResultClick={(item) => isInVault(item, allVaultItems) ? setSelectedItem(vault.watched[item.imdbID] || vault.watchlist[item.imdbID]) : null}
                        isLoading={isSearchLoading}
                        searchType={searchType}
                        setSearchType={setSearchType}
                        // --- New Props for Actions ---
                        vault={vault}
                        isAdmin={isAdmin}
                        onSuggest={handleSuggestToAdmin}
                        onAdd={handleAdminAdd}
                    />
                    <AdminSuggestionsModal isOpen={isAdminSuggestionsOpen} onClose={() => setIsAdminSuggestionsOpen(false)} suggestions={adminSuggestionsData} onApprove={approveSuggestion} onReject={rejectSuggestion} />

                    {isSettingsOpen && (
                        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4">
                            <div className="absolute inset-0 bg-black/80 backdrop-blur-lg" onClick={() => setIsSettingsOpen(false)}></div>
                            <div className="relative w-full max-w-md glass rounded-[2.5rem] p-10 animate-reveal">
                                <div className="flex flex-col items-center text-center mb-10">
                                    <div className="mb-6"><VaultLogo size={64} className="text-indigo-500" /></div>
                                    <h3 className="text-3xl font-black text-white">Vault Access</h3>
                                    <p className="text-slate-500 font-medium mt-2">Manage your collection across devices</p>
                                </div>
                                {session ? (
                                    <div className="space-y-4">
                                        {isAdmin && <CacheHealthPanel />}
                                        <div className="p-6 rounded-3xl bg-white/5 border border-white/5 space-y-4">
                                            <div className="flex items-center justify-between">
                                                <div><p className="text-sm font-bold text-white">Library Maintenance</p><p className="text-xs text-slate-500">Update metadata for all items</p></div>
                                                <button onClick={refreshLibrary} disabled={isRefreshing} className="px-4 py-2 bg-indigo-600 rounded-xl text-white text-xs font-bold disabled:opacity-50">{isRefreshing ? `${refreshProgress}%` : 'Refresh All'}</button>
                                            </div>
                                            {isRefreshing && (<div className="h-1 w-full bg-slate-800 rounded-full overflow-hidden"><div className="h-full bg-indigo-500 transition-all duration-300" style={{ width: `${refreshProgress}%` }}></div></div>)}
                                        </div>
                                        <div className="p-4 rounded-2xl bg-white/5 border border-white/5 space-y-3">
                                            <h4 className="text-sm font-bold text-white uppercase tracking-wider">API Configuration</h4>
                                            <input type="text" placeholder="OMDb API Key" value={apiKeys.omdb} onChange={(e) => setApiKeys({ ...apiKeys, omdb: e.target.value })} className="w-full bg-black/50 border border-white/10 rounded-xl px-4 py-2 text-sm text-white focus:border-indigo-500 outline-none" />
                                            <input type="text" placeholder="TMDB API Key" value={apiKeys.tmdb} onChange={(e) => setApiKeys({ ...apiKeys, tmdb: e.target.value })} className="w-full bg-black/50 border border-white/10 rounded-xl px-4 py-2 text-sm text-white focus:border-indigo-500 outline-none" />
                                            <input type="text" placeholder="RapidAPI Key (MDL)" value={apiKeys.rapid} onChange={(e) => setApiKeys({ ...apiKeys, rapid: e.target.value })} className="w-full bg-black/50 border border-white/10 rounded-xl px-4 py-2 text-sm text-white focus:border-indigo-500 outline-none" />
                                            {isAdmin && <button onClick={adminClearCache} className="w-full px-4 py-2 rounded-xl bg-rose-500/20 text-rose-400 hover:bg-rose-500 hover:text-white transition-all text-xs font-bold uppercase tracking-wider">Clear Cache</button>}
                                        </div>
                                        <div className="flex gap-3">
                                            <button onClick={handleExport} className="flex-1 py-3 bg-white/5 border border-white/10 rounded-xl text-sm font-bold hover:bg-white/10 transition-all">Export JSON</button>
                                            <label className="flex-1 py-3 bg-white/5 border border-white/10 rounded-xl text-sm font-bold hover:bg-white/10 transition-all text-center cursor-pointer">Import JSON<input type="file" onChange={handleImport} className="hidden" accept=".json" /></label>
                                        </div>
                                        {isAdmin && <button onClick={() => { setIsSettingsOpen(false); setIsAdminSuggestionsOpen(true); }} className="w-full py-3 bg-indigo-500/10 text-indigo-400 border border-indigo-500/20 rounded-xl text-sm font-bold hover:bg-indigo-500 hover:text-white transition-all">Open Admin Dashboard</button>}
                                        <div className="p-6 rounded-3xl bg-white/5 border border-white/5"><p className="text-[10px] text-slate-500 font-black uppercase tracking-widest mb-1">Signed in as</p><p className="text-white font-bold">{session.user.email}</p></div>
                                        <button onClick={() => supabase.auth.signOut()} className="w-full py-5 bg-rose-500/10 text-rose-500 border border-rose-500/20 rounded-2xl font-black uppercase tracking-widest hover:bg-rose-500 hover:text-white transition-all">Sign Out</button>
                                    </div>
                                ) : (
                                    <form onSubmit={async (e) => {
                                        e.preventDefault();
                                        const email = e.target.email.value;
                                        const password = e.target.password.value;
                                        const { error } = await supabase.auth.signInWithPassword({ email, password });
                                        if (error) alert(error.message);
                                        else setIsSettingsOpen(false);
                                    }} className="space-y-4">
                                        <input type="email" name="email" placeholder="Email Address" className="w-full bg-white/5 border border-white/5 focus:border-indigo-500 rounded-2xl p-4 text-white outline-none" required />
                                        <input type="password" name="password" placeholder="Password" className="w-full bg-white/5 border border-white/5 focus:border-indigo-500 rounded-2xl p-4 text-white outline-none" required />
                                        <button type="submit" className="w-full py-5 bg-indigo-600 text-white rounded-2xl font-black uppercase tracking-widest shadow-xl shadow-indigo-600/30 hover:-translate-y-1 transition-all">Unlock Vault</button>
                                    </form>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>