<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Vault v7.7 - Registry Edition</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f1115',
                            card: '#111827',
                            border: '#374151',
                            text: '#ffffff',
                            subtext: '#9ca3af',
                            accent: '#6366f1'
                        },
                        light: {
                            bg: '#f3f4f6',
                            card: '#ffffff',
                            border: '#e5e7eb',
                            text: '#111827',
                            subtext: '#4b5563',
                            accent: '#4f46e5'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(99, 102, 241, 0.5); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(99, 102, 241, 0.8); }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; }
        input[type=range]:focus { outline: none; }
    </style>
</head>
<body class="bg-light-bg dark:bg-dark-bg text-light-text dark:text-dark-text transition-colors duration-300 overflow-y-scroll">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect, useCallback, useRef } = React;
        
        // --- CONFIG ---
        const supabaseClient = window.supabase.createClient(
              "https://ugllcdapuzihpkgcoaxj.supabase.co",
              "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVnbGxjZGFwdXppaHBrZ2NvYXhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0OTA3NzksImV4cCI6MjA4NjA2Njc3OX0.73I1cW1fqRUha5_6spK7C8m-SXUHQQfyjmcbNNbdfCI"
        );

        // --- ADMIN CONFIG ---
        const ADMIN_IDS = [
            "74e5b3ea-113f-4d6c-be2a-b0b52b2e92c3"
        ];

        // --- ICONS ---
        const IconBase = ({ size = 20, className, children, ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        const Film = (p) => <IconBase {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></IconBase>;
        const Tv = (p) => <IconBase {...p}><rect width="20" height="15" x="2" y="7" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></IconBase>;
        const Play = (p) => <IconBase {...p}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Star = ({ fill, ...p }) => <IconBase {...p} fill={fill || "none"}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>;
        const Search = (p) => <IconBase {...p}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></IconBase>;
        const CheckCircle = (p) => <IconBase {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>;
        const ListPlus = (p) => <IconBase {...p}><path d="M11 12H3"/><path d="M16 6H3"/><path d="M16 18H3"/><path d="M18 9v6"/><path d="M21 12h-6"/></IconBase>;
        const X = (p) => <IconBase {...p}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Upload = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconBase>;
        const Download = (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const Settings = (p) => <IconBase {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const RefreshCw = (p) => <IconBase {...p}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></IconBase>;
        const Edit = (p) => <IconBase {...p}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></IconBase>;
        const Repeat = (p) => <IconBase {...p}><path d="m17 2 4 4-4 4"/><path d="M3 11v-1a4 4 0 0 1 4-4h14"/><path d="m7 22-4-4 4-4"/><path d="M21 13v1a4 4 0 0 1-4 4H3"/></IconBase>;
        const Zap = (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const Globe = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>;
        const Trash = (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></IconBase>;
        const BarChart = (p) => <IconBase {...p}><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></IconBase>;
        const CheckSquare = (p) => <IconBase {...p}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>;
        const LogIn = (p) => <IconBase {...p}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></IconBase>;
        const User = (p) => <IconBase {...p}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconBase>;
        const Eye = (p) => <IconBase {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const EyeOff = (p) => <IconBase {...p}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></IconBase>;
        const Clock = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const TrendingUp = (p) => <IconBase {...p}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></IconBase>;
        const Grid = (p) => <IconBase {...p}><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></IconBase>;
        const Database = (p) => <IconBase {...p}><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></IconBase>;
        const Copy = (p) => <IconBase {...p}><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></IconBase>;
        const Inbox = (p) => <IconBase {...p}><polyline points="22 12 16 12 14 15 10 15 8 12 2 12"/><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/></IconBase>;
        const MessageSquare = (p) => <IconBase {...p}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></IconBase>;

        // Custom Vault Logo
        const VaultLogoIcon = (p) => (
            <IconBase {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                <path d="M3 7h2v10H3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1z" fill="currentColor" fillOpacity="0.2" />
                <path d="M5 9h2" strokeLinecap="round" />
                <path d="M5 15h2" strokeLinecap="round" />
                <circle cx="15" cy="12" r="8" strokeWidth="2" />
                <circle cx="15" cy="12" r="6.2" strokeDasharray="0.5 2.5" strokeLinecap="round" strokeWidth="1.5" className="opacity-60" />
                <circle cx="15" cy="12" r="3" strokeWidth="1.5" />
                <path d="M15 9V6" strokeLinecap="round" />
                <path d="M15 15v3" strokeLinecap="round" />
                <path d="M12.4 10.5L9.8 9" strokeLinecap="round" />
                <path d="M17.6 10.5L20.2 9" strokeLinecap="round" />
                <path d="M12.4 13.5L9.8 15" strokeLinecap="round" />
                <path d="M17.6 13.5L20.2 15" strokeLinecap="round" />
                <ellipse cx="15" cy="12" rx="1.2" ry="1.8" fill="currentColor" />
                <path d="M15 11v2" stroke="white" strokeWidth="0.5" className="dark:stroke-gray-900" />
            </IconBase>
        );

        // --- CONSTANTS ---
        const DEFAULT_KEYS = { omdb: '5591108c', tmdb: '68b27c1f85725736f0aec18b903197b0', rapid: '9782bOaf7fmsh8b54c22e5cOaf5cp13e6e8jsn8e2e765657a5' };
        const RAPID_HOST_MDL = "mydramalist-api.p.rapidapi.com"; 

        const SMART_LISTS = [
            { id: 'top_rated', label: 'Top Rated', icon: Star, filter: item => item.userMeta?.ratings?.overall >= 9 },
            { id: 'rewatch', label: 'Rewatch Worthy', icon: Repeat, filter: item => item.userMeta?.rewatchCount > 0 },
            { id: 'foreign', label: 'Foreign', icon: Globe, filter: item => item.Language && !item.Language.includes('English') },
            { id: 'progress', label: 'In Progress', icon: Play, filter: item => item.userMeta?.series?.lastEpisode?.season > 0 },
        ];

        // --- SQL FOR USER ---
        const DB_SCHEMA_SQL = `
-- 1. MDL Registry (Public Global Table)
create table if not exists mdl_registry (
  mdl_id text primary key,
  title text,
  alt_titles text[],
  year int,
  country text,
  type text,
  episodes int,
  rating float,
  votes int,
  genres text[],
  synopsis text,
  poster_url text,
  raw jsonb,
  created_at timestamp default now(),
  updated_at timestamp default now()
);
alter table mdl_registry enable row level security;
-- Allow everyone to read and insert (since it's crowd-sourced)
create policy "Public read registry" on mdl_registry for select using (true);
create policy "Public insert registry" on mdl_registry for insert with check (true);
create policy "Public update registry" on mdl_registry for update using (true);

-- 2. MDL <-> IMDb Map (Public Mapping)
create table if not exists mdl_imdb_map (
  mdl_id text,
  imdb_id text,
  confidence float default 1.0,
  source text,
  created_at timestamp default now(),
  primary key (mdl_id, imdb_id)
);
alter table mdl_imdb_map enable row level security;
create policy "Public read map" on mdl_imdb_map for select using (true);
create policy "Public insert map" on mdl_imdb_map for insert with check (true);

-- 3. Suggestions System (Enhanced)
-- Note: If you have an existing table, you may need to alter it or drop/create.
-- DROP TABLE IF EXISTS content_suggestions;
create table if not exists content_suggestions (
  id uuid default gen_random_uuid() primary key,
  imdb_id text not null,
  title text,
  year int,
  type text,
  suggested_by uuid[] default array[]::uuid[], -- Array of user IDs
  votes int default 1,
  reasons jsonb default '[]'::jsonb, -- Array of {user, text, priority}
  status text default 'pending', -- pending, approved, rejected
  created_at timestamp default now(),
  updated_at timestamp default now()
);
alter table content_suggestions enable row level security;
create policy "Public read suggestions" on content_suggestions for select using (true);
create policy "Public insert suggestions" on content_suggestions for insert with check (true);
create policy "Public update suggestions" on content_suggestions for update using (true);
`;

        // --- GLOBAL CACHE SYSTEM (30-DAY TTL) ---
        const CACHE_TTL_30_DAYS = 30 * 24 * 60 * 60 * 1000;
        
        const cacheGet = (key) => {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return null;
                const { data, ts } = JSON.parse(raw);
                if (Date.now() - ts > CACHE_TTL_30_DAYS) {
                    localStorage.removeItem(key);
                    return null;
                }
                return data;
            } catch (e) { return null; }
        };

        const cacheSet = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify({ data, ts: Date.now() }));
            } catch (e) { console.warn("Cache quota exceeded"); }
        };

        // --- HELPERS (Outside App) ---
        const normalize = (q) => q.toLowerCase().trim().replace(/[^a-z0-9]/g, '');

        // 3️⃣ Ratings Helper
        const normalizeRatings = (item) => {
            const ratings = {
                imdb: { rating: item.imdbRating, votes: item.imdbVotes },
                rotten: null,
                metacritic: null
            };
            item.Ratings?.forEach(r => {
                if (r.Source === "Rotten Tomatoes") ratings.rotten = r.Value;
                if (r.Source === "Metacritic") ratings.metacritic = r.Value;
            });
            return ratings;
        };

        const isAsianDrama = (item) => {
            const countries = /South Korea|China|Japan|Thailand|Taiwan|Hong Kong/i;
            const genres = /Drama|Romance|Comedy/i;
            const isCountry = item.Country && countries.test(item.Country);
            return isCountry && item.Genre && genres.test(item.Genre);
        };

        // Cloud Throttle Queue
        const cloudQueue = {
            current: new Map(),
            timer: null
        };
        const saveToCloudThrottled = (id, item, session) => {
            if (!session) return;
            cloudQueue.current.set(id, item);
            
            if (cloudQueue.timer) clearTimeout(cloudQueue.timer);
            
            cloudQueue.timer = setTimeout(async () => {
                const batch = [];
                cloudQueue.current.forEach((val, key) => {
                    batch.push({
                        user_id: session.user.id,
                        imdb_id: key,
                        user_meta: val,
                        updated_at: new Date()
                    });
                });
                cloudQueue.current.clear();
                
                if (batch.length > 0) {
                     const { error } = await supabaseClient.from("vault_items").upsert(batch);
                     if (error) console.error("Batch save failed", error);
                }
            }, 2000); 
        };

        // --- UTILS ---
        const getHighResPoster = (url, width = 600) => {
            if (!url || url === "N/A") return "https://via.placeholder.com/300x450?text=No+Poster";
            if (url.includes("media-amazon.com") || url.includes("images-na.ssl-images-amazon.com")) {
                return url.replace(/_V1_.*\.jpg$/, `_V1_SX${width}.jpg`);
            }
            if (url.includes("tmdb.org")) return url.replace(/\/w\d+\//, width > 700 ? "/original/" : `/w${width}/`);
            return url;
        };

        const tmdbImg = (path, size = "w780") => path ? `https://image.tmdb.org/t/p/${size}${path}` : null;

        // 1️⃣ Migrate Item & Extend Data Model
        const migrateItem = (item, status) => {
            if (item.userMeta && item.meta && item.tmdb && item.meta.ratingsExternal && item.meta.tvmaze) return item;
            
            const isSeries = item.Type === 'series' || item.Genre?.includes('Animation');
            const oldRating = parseFloat(item.userRating || item.userMeta?.userRating || 0);

            return {
              ...item,
              meta: item.meta || {
                  director: item.Director || "",
                  genre: item.Genre?.split(",").map(g => g.trim()) || [],
                  cast: item.Actors ? item.Actors.split(",").map(a => ({ name: a.trim(), character: null })) : [],
                  series: isSeries ? { seasons: [] } : null,
                  ratingsExternal: normalizeRatings(item),
                  anime: null,
                  asian: null,
                  tvmaze: null
              },
              tmdb: item.tmdb || { id: null, credits: null, images: null, seasons: null, enriched: false },
              userMeta: {
                status: status || item.userMeta?.status || 'watchlist',
                userRating: oldRating, 
                rewatchCount: item.userMeta?.rewatchCount || 0,
                series: isSeries ? (item.userMeta?.series || { lastEpisode: { season: 0, episode: 0 }, completed: false }) : null,
                ratings: item.userMeta?.ratings || { overall: oldRating, story: 0, direction: 0, emotion: 0 },
                lastUpdated: item.userMeta?.lastUpdated || Date.now(),
                watchedOn: item.userMeta?.watchedOn || new Date().toISOString().split('T')[0],
                autoOverall: true,
                notes: item.userMeta?.notes || ""
              }
            };
        };

        // --- NEW: COMPONENT ARCHITECTURE ---

        const Badge = ({ label }) => (
            <span className="px-2 py-0.5 rounded bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-300 text-[10px] font-medium border border-gray-200 dark:border-gray-700">
                {label}
            </span>
        );

        const Rating = ({ label, value }) => (
            <div className="flex flex-col">
                <span className="text-[10px] text-gray-500 uppercase font-bold">{label}</span>
                <span className="font-medium text-gray-900 dark:text-white">{value}</span>
            </div>
        );

        // --- NEW: FILTER & SORT COMPONENTS ---
        const FilterSelect = ({ label, options, value, onChange }) => (
            <div className="flex flex-col gap-1 min-w-[120px] flex-1">
                <label className="text-[10px] uppercase font-bold text-gray-500 tracking-wider px-1">{label}</label>
                <select
                    multiple
                    value={value}
                    onChange={(e) => onChange([...e.target.selectedOptions].map(o => o.value))}
                    className="w-full h-24 bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-800 rounded-lg text-xs p-2 custom-scrollbar outline-none focus:border-indigo-500 dark:text-gray-300 shadow-sm transition-all focus:ring-2 focus:ring-indigo-500/20"
                >
                    {options.map(o => <option key={o} value={o} className="py-1 px-2 rounded hover:bg-gray-200 dark:hover:bg-gray-800 cursor-pointer truncate">{o}</option>)}
                </select>
            </div>
        );

        const SortControls = ({ sortBy, setSortBy, sortOrder, setSortOrder }) => (
            <div className="flex gap-2 items-center bg-gray-100 dark:bg-gray-800 p-1 rounded-lg">
                <div className="relative">
                    <select
                        value={sortBy}
                        onChange={(e) => setSortBy(e.target.value)}
                        className="appearance-none bg-white dark:bg-dark-card border border-gray-200 dark:border-gray-700 pl-3 pr-8 py-1.5 rounded-md text-xs font-bold dark:text-white outline-none focus:border-indigo-500 uppercase tracking-wide cursor-pointer"
                    >
                        <option value="updated">Updated</option>
                        <option value="name">Name</option>
                        <option value="year">Year</option>
                        <option value="rating">Rating</option>
                    </select>
                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                        <svg className="fill-current h-3 w-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>
                <button
                    onClick={() => setSortOrder(o => o === "asc" ? "desc" : "asc")}
                    className="px-3 py-1.5 bg-white dark:bg-dark-card border border-gray-200 dark:border-gray-700 rounded-md text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-white transition-colors"
                >
                    {sortOrder === "asc" ? <span className="text-xs font-bold">ASC</span> : <span className="text-xs font-bold">DESC</span>}
                </button>
            </div>
        );

        function HeaderBlock({ title, year, language, genre, rated }) {
            return (
                <div>
                    <h1 className="text-2xl font-bold dark:text-white">
                        {title} <span className="opacity-60 font-normal">({year})</span>
                    </h1>
                    <div className="flex flex-wrap gap-2 mt-2 text-xs opacity-80">
                        {rated && rated !== "N/A" && <Badge label={rated} />}
                        {language?.split(",").map(l => <Badge key={l} label={l.trim()} />)}
                        {genre?.map(g => <Badge key={g} label={g} />)}
                    </div>
                </div>
            );
        }

        function SynopsisBlock({ synopsis }) {
            const [open, setOpen] = React.useState(false);
            return (
                <div>
                    <h2 className="font-semibold mb-1 text-sm dark:text-white">Synopsis</h2>
                    <p className={`text-sm text-gray-600 dark:text-gray-300 ${!open && "line-clamp-4"}`}>
                        {synopsis && synopsis !== "N/A" ? synopsis : "No synopsis available."}
                    </p>
                    {synopsis?.length > 300 && (
                        <button className="text-indigo-400 text-xs mt-1 font-medium" onClick={() => setOpen(!open)}>
                            {open ? "Show less" : "Read more"}
                        </button>
                    )}
                </div>
            );
        }

        function CreditsBlock({ director, cast }) {
            return (
                <div>
                    {director && (Array.isArray(director) ? director.length > 0 : director !== "N/A") && (
                        <p className="text-sm dark:text-gray-300 mb-3">
                            <strong className="text-gray-900 dark:text-white">Director:</strong> {Array.isArray(director) ? director.join(", ") : director}
                        </p>
                    )}
                    <h3 className="font-semibold mt-3 mb-2 text-sm dark:text-white">Cast</h3>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                        {cast?.slice(0, 12).map((c, i) => (
                            <div key={i} className="text-xs flex gap-2 items-center">
                                {c.photo ? <img src={c.photo} className="w-6 h-6 rounded-full object-cover"/> : <div className="w-6 h-6 rounded-full bg-gray-200 flex items-center justify-center text-[8px]">{c.name.charAt(0)}</div>}
                                <div>
                                    <div className="font-medium dark:text-gray-200">{c.name}</div>
                                    {c.character && <div className="opacity-60 text-[10px] dark:text-gray-400">as {c.character}</div>}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        }

        function RatingsBlock({ ratings, mal, mdl, imdbID }) {
            return (
                <div>
                    <h3 className="font-semibold mb-2 text-sm dark:text-white">Ratings</h3>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4 text-sm bg-gray-50 dark:bg-gray-800/50 p-3 rounded-lg border border-gray-100 dark:border-gray-700">
                        {ratings?.imdb?.rating && ratings.imdb.rating !== "N/A" && <Rating label="IMDb" value={`${ratings.imdb.rating}/10`} />}
                        {ratings?.rotten && <Rating label="Rotten Tomatoes" value={ratings.rotten} />}
                        {ratings?.metacritic && <Rating label="Metacritic" value={ratings.metacritic} />}
                        {mal && <Rating label="MyAnimeList" value={mal.rating} />}
                        {mdl && <Rating label="MyDramaList" value={mdl.rating} />}
                        {imdbID && (
                            <div className="flex items-center">
                                <a href={`https://letterboxd.com/imdb/${imdbID}`} target="_blank" className="text-indigo-500 hover:text-indigo-400 text-xs font-bold underline">
                                    View on Letterboxd
                                </a>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function SeasonBlock({ season }) {
            const [open, setOpen] = React.useState(false);
            return (
                <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-3 bg-white dark:bg-dark-card">
                    <button onClick={() => setOpen(!open)} className="font-medium text-sm w-full text-left flex justify-between items-center dark:text-white">
                        <span>Season {season.season}</span>
                        <span className="text-xs text-gray-400">{open ? 'Hide' : 'Show'} Episodes</span>
                    </button>
                    {open && (
                        <ul className="mt-3 space-y-2 text-xs">
                            {season.episodes.map(ep => (
                                <li key={ep.episode} className="flex justify-between items-center py-1 border-b border-gray-100 dark:border-gray-800 last:border-0">
                                    <span className="dark:text-gray-300"><span className="font-mono text-gray-400 mr-2">E{ep.episode}</span> {ep.title}</span>
                                    {ep.watched && <span className="text-green-500 font-bold text-[10px] bg-green-100 dark:bg-green-900/30 px-1.5 py-0.5 rounded">WATCHED</span>}
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            );
        }

        function SeriesBlock({ series }) {
            if (!series || !series.seasons) return null;
            return (
                <div>
                    <h3 className="font-semibold mb-2 text-sm dark:text-white">Series Info</h3>
                    <div className="mt-3 space-y-3">
                        {series.seasons.map(s => <SeasonBlock key={s.season} season={s} />)}
                    </div>
                </div>
            );
        }

        function MediaDetailsCard({ item }) {
            const { Title, Year, Language, Genre, Rated, Type, meta } = item;
            
            // Handle legacy Genre string vs array
            const genreArray = Array.isArray(meta.genre) ? meta.genre : (meta.genre ? meta.genre.split(",").map(g=>g.trim()) : []);

            return (
                <div className="space-y-8">
                    <HeaderBlock title={Title} year={Year} language={Language} genre={genreArray} rated={Rated} />
                    <SynopsisBlock synopsis={meta.synopsis || item.Plot} />
                    <CreditsBlock director={meta.director} cast={meta.cast} />
                    <RatingsBlock ratings={meta.ratingsExternal} mal={meta.anime?.mal} mdl={meta.asian?.mdl} imdbID={item.imdbID} />
                    {Type === "series" && meta.series && <SeriesBlock series={meta.series} />}
                </div>
            );
        }

        // Wrapper Modal to maintain backdrop/actions while using MediaDetailsCard
        const DetailModal = ({ item, onClose, onUpdateStatus }) => {
            if (!item) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                     <div className="bg-white dark:bg-dark-card w-full max-w-lg p-6 rounded-2xl relative max-h-[90vh] overflow-y-auto custom-scrollbar shadow-2xl">
                        {/* Image Header */}
                        {item.tmdb?.enriched && (
                             <div className="absolute top-0 left-0 w-full h-48 rounded-t-2xl z-0 overflow-hidden">
                                 <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-white dark:to-dark-card z-10"></div>
                                 <img src={tmdbImg(item.tmdb.credits?.images?.backdrops?.[0]?.file_path, "w780") || getHighResPoster(item.Poster, 800)} className="w-full h-full object-cover opacity-60" />
                             </div>
                         )}
                         
                         <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white z-20 bg-black/20 rounded-full p-1"><X size={20}/></button>
                         
                         <div className="relative z-10 mt-32">
                            <MediaDetailsCard item={item} />
                            
                            {/* Action Buttons Footer */}
                            <div className="mt-8 pt-4 border-t border-gray-100 dark:border-gray-800 flex gap-3">
                                <button onClick={() => onUpdateStatus('watched')} className={`flex-1 py-3 rounded-xl border text-sm font-bold transition-all ${item.userMeta?.status === 'watched' ? 'bg-green-500 text-white border-green-500 shadow-lg shadow-green-500/20' : 'dark:text-white border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-800'}`}>Watched</button>
                                <button onClick={() => onUpdateStatus('watchlist')} className={`flex-1 py-3 rounded-xl border text-sm font-bold transition-all ${item.userMeta?.status === 'watchlist' ? 'bg-blue-500 text-white border-blue-500 shadow-lg shadow-blue-500/20' : 'dark:text-white border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-800'}`}>Watchlist</button>
                            </div>
                         </div>
                     </div>
                </div>
            )
        }

        // --- COMPONENTS END ---

        const AuthModal = ({ isOpen, onClose, onLogin }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            if (!isOpen) return null;

            const handleSubmit = async (e) => {
              e.preventDefault();
              setError("");

              try {
                if (isRegister) {
                  const { error } = await supabaseClient.auth.signUp({ email, password });
                  if (error) throw error;
                  alert("Registered! Now login.");
                  setIsRegister(false);
                } else {
                  const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
                  if (error) throw error;
                  onLogin(data.session);
                  onClose();
                }
              } catch (err) { setError(err.message); }
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-sm rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-8 relative">
                         <div className="text-center mb-8">
                             <div className="inline-block p-3 rounded-full bg-indigo-100 dark:bg-indigo-900/30 text-indigo-600 mb-4"><VaultLogoIcon size={48} /></div>
                             <h2 className="text-2xl font-black text-gray-900 dark:text-white uppercase tracking-wider">{isRegister ? 'Join The Vault' : 'Welcome Back'}</h2>
                             <p className="text-sm text-gray-500 mt-2">Sync your collection across devices</p>
                         </div>
                         {error && <div className="mb-4 p-3 bg-red-100 text-red-700 text-sm rounded-lg">{error}</div>}
                         <form onSubmit={handleSubmit} className="space-y-4">
                             <div><label className="block text-xs font-bold uppercase text-gray-500 mb-1">Email</label><input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required /></div>
                             <div><label className="block text-xs font-bold uppercase text-gray-500 mb-1">Password</label><input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white" required /></div>
                             <button type="submit" className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition-colors shadow-lg shadow-indigo-600/20">{isRegister ? 'Create Account' : 'Access Vault'}</button>
                         </form>
                         <div className="mt-6 text-center"><button onClick={() => setIsRegister(!isRegister)} className="text-sm text-gray-500 hover:text-indigo-600 dark:hover:text-white transition-colors">{isRegister ? 'Already have an account? Login' : 'Need an account? Register'}</button></div>
                    </div>
                </div>
            );
        }

        const SettingsModal = ({ isOpen, onClose, apiKeys, setApiKeys, theme, setTheme, onReset, onImport, onExport }) => {
            const [activeTab, setActiveTab] = useState('general');
            const [copySuccess, setCopySuccess] = useState('');

            if (!isOpen) return null;

            const copySQL = () => {
                navigator.clipboard.writeText(DB_SCHEMA_SQL);
                setCopySuccess('Copied!');
                setTimeout(() => setCopySuccess(''), 2000);
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-lg rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative flex flex-col max-h-[90vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-6 dark:text-white flex items-center gap-2"><Settings size={20} /> Vault Settings</h2>
                        
                        <div className="flex gap-4 border-b border-gray-200 dark:border-gray-700 mb-6">
                            <button onClick={() => setActiveTab('general')} className={`pb-2 text-sm font-medium transition-colors ${activeTab === 'general' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}>General</button>
                            <button onClick={() => setActiveTab('database')} className={`pb-2 text-sm font-medium transition-colors ${activeTab === 'database' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-gray-500'}`}>Database Schema</button>
                        </div>

                        <div className="overflow-y-auto custom-scrollbar flex-1">
                            {activeTab === 'general' && (
                                <div className="space-y-6">
                                    <div>
                                        <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">Appearance</label>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button onClick={() => setTheme('light')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'light' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Light Mode</button>
                                            <button onClick={() => setTheme('dark')} className={`py-2 rounded-lg text-sm font-medium border ${theme === 'dark' ? 'bg-indigo-900/30 border-indigo-500 text-indigo-300' : 'border-gray-200 dark:border-gray-700 dark:text-gray-400'}`}>Dark Mode</button>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-2 block">API Connections</label>
                                        <div className="space-y-3">
                                            <input type="text" placeholder="OMDb API Key" value={apiKeys.omdb} onChange={(e) => setApiKeys(p => ({...p, omdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                            <input type="text" placeholder="TMDB API Key" value={apiKeys.tmdb} onChange={(e) => setApiKeys(p => ({...p, tmdb: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                            <input type="text" placeholder="RapidAPI Key (For MDL)" value={apiKeys.rapid || ''} onChange={(e) => setApiKeys(p => ({...p, rapid: e.target.value}))} className="w-full bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 text-sm outline-none focus:border-indigo-500 dark:text-white" />
                                        </div>
                                    </div>

                                    <div className="pt-4 border-t border-gray-200 dark:border-gray-700 space-y-3">
                                        <div className="grid grid-cols-2 gap-3">
                                            <button onClick={onExport} className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700"><Download size={14}/> Backup</button>
                                            <label className="flex items-center justify-center gap-2 bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg text-xs font-bold hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer">
                                                <Upload size={14}/> Restore
                                                <input type="file" accept=".json" onChange={onImport} className="hidden" />
                                            </label>
                                        </div>
                                        <button onClick={onReset} className="w-full text-red-500 hover:text-red-600 text-xs font-bold py-2">Factory Reset Vault</button>
                                    </div>
                                </div>
                            )}

                            {activeTab === 'database' && (
                                <div className="space-y-4">
                                    <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
                                        <h3 className="text-sm font-bold text-yellow-800 dark:text-yellow-200 flex items-center gap-2"><Database size={16}/> Action Required</h3>
                                        <p className="text-xs text-yellow-700 dark:text-yellow-300 mt-1">To enable the Persistent MDL Registry, you must run this SQL in your Supabase SQL Editor.</p>
                                    </div>
                                    <div className="relative">
                                        <pre className="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg text-[10px] font-mono text-gray-600 dark:text-gray-300 overflow-x-auto whitespace-pre-wrap border border-gray-200 dark:border-gray-700">
                                            {DB_SCHEMA_SQL}
                                        </pre>
                                        <button onClick={copySQL} className="absolute top-2 right-2 p-2 bg-white dark:bg-dark-card border border-gray-200 dark:border-gray-700 rounded-md shadow-sm hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
                                            {copySuccess ? <span className="text-xs font-bold text-green-500">{copySuccess}</span> : <Copy size={14} className="text-gray-500"/>}
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- NEW: USER SUGGEST MODAL ---
        const SuggestModal = ({ item, onClose, onSubmit }) => {
            const [reason, setReason] = useState("");
            const [priority, setPriority] = useState(3);
            
            return (
                <div className="fixed inset-0 z-[120] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-sm rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-1 dark:text-white">Suggest to Admin</h2>
                        <h3 className="text-sm font-medium text-gray-500 mb-6">{item.Title} ({item.Year})</h3>
                        
                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-bold uppercase text-gray-500 mb-1">Why do you want this?</label>
                                <textarea 
                                    value={reason} 
                                    onChange={(e) => setReason(e.target.value)} 
                                    className="w-full h-24 bg-gray-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-lg p-3 text-sm outline-none focus:border-indigo-500 dark:text-white resize-none"
                                    placeholder="e.g. It's a classic, I've been waiting for this..."
                                />
                            </div>
                            
                            <div>
                                <label className="block text-xs font-bold uppercase text-gray-500 mb-1 flex justify-between">
                                    <span>Priority</span>
                                    <span className={`font-bold ${priority >= 4 ? 'text-red-500' : priority <= 2 ? 'text-green-500' : 'text-yellow-500'}`}>{priority === 1 ? 'Low' : priority === 5 ? 'Critical' : priority}</span>
                                </label>
                                <input 
                                    type="range" 
                                    min="1" 
                                    max="5" 
                                    value={priority} 
                                    onChange={(e) => setPriority(Number(e.target.value))} 
                                    className="w-full accent-indigo-600 h-2 bg-gray-200 dark:bg-gray-800 rounded-lg appearance-none cursor-pointer"
                                />
                                <div className="flex justify-between text-[10px] text-gray-400 mt-1">
                                    <span>Low</span>
                                    <span>High</span>
                                </div>
                            </div>
                            
                            <button 
                                onClick={() => onSubmit(item, reason, priority)} 
                                className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition-colors shadow-lg shadow-indigo-600/20 flex items-center justify-center gap-2"
                            >
                                Send Suggestion <Zap size={16} />
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- UPDATED: ADMIN SUGGESTIONS INBOX ---
        const AdminSuggestionsModal = ({ isOpen, onClose, suggestions, onApprove, onReject }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-lg rounded-2xl shadow-2xl border border-light-border dark:border-dark-border p-6 relative flex flex-col max-h-[80vh]">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white"><X size={20} /></button>
                        <h2 className="text-xl font-bold mb-4 dark:text-white flex items-center gap-2"><Inbox size={20} /> Suggestions Inbox</h2>
                        {suggestions.length === 0 ? (
                            <div className="text-center py-10 text-gray-500">No pending suggestions.</div>
                        ) : (
                            <div className="space-y-3 overflow-y-auto custom-scrollbar p-1">
                                {suggestions.map(s => {
                                    const avgPriority = s.reasons && s.reasons.length ? Math.round(s.reasons.reduce((a, b) => a + b.priority, 0) / s.reasons.length) : 0;
                                    return (
                                        <div key={s.id} className="p-4 bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-800 rounded-lg">
                                            <div className="flex justify-between items-start mb-2">
                                                <div>
                                                    <div className="font-bold dark:text-white truncate text-base">{s.title}</div>
                                                    <div className="text-xs text-gray-500">{s.year} • {s.type}</div>
                                                </div>
                                                <div className="text-right">
                                                     <div className="text-xs font-bold text-indigo-500 bg-indigo-100 dark:bg-indigo-900/50 px-2 py-0.5 rounded-full inline-block mb-1">{s.votes} Votes</div>
                                                     <div className={`text-[10px] font-bold ${avgPriority >= 4 ? 'text-red-500' : 'text-gray-400'}`}>Pr: {avgPriority}</div>
                                                </div>
                                            </div>
                                            
                                            {s.reasons && s.reasons.length > 0 && (
                                                <div className="bg-white dark:bg-dark-bg p-2 rounded border border-gray-200 dark:border-gray-800 text-xs text-gray-600 dark:text-gray-300 mb-3 space-y-1">
                                                    {s.reasons.slice(0, 3).map((r, i) => (
                                                        <div key={i} className="flex gap-2">
                                                            <span className="text-indigo-400 font-bold">•</span>
                                                            <span className="line-clamp-2 italic">"{r.text || 'No reason given'}"</span>
                                                        </div>
                                                    ))}
                                                    {s.reasons.length > 3 && <div className="text-[10px] text-center text-gray-400">...and {s.reasons.length - 3} more</div>}
                                                </div>
                                            )}
                                            
                                            <div className="flex gap-2">
                                                <button onClick={() => onReject(s.id)} className="flex-1 py-2 bg-red-100 hover:bg-red-200 dark:bg-red-900/30 dark:hover:bg-red-900/50 text-red-600 dark:text-red-400 rounded-lg text-xs font-bold transition-colors">Reject</button>
                                                <button onClick={() => onApprove(s)} className="flex-1 py-2 bg-green-100 hover:bg-green-200 dark:bg-green-900/30 dark:hover:bg-green-900/50 text-green-600 dark:text-green-400 rounded-lg text-xs font-bold transition-colors">Approve & Add</button>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- NEW: SEARCH PREVIEW MODAL ---
        const SearchPreviewModal = ({ item, onClose, onAdd, onSuggest, isAdmin }) => {
            const [fullData, setFullData] = useState(null);
            
            // Reusing cache or fetching full details
            useEffect(() => {
                // Mock fetch function will be passed or defined in App scope context
                // But here we need to access the data fetching logic. 
                // Since this component is defined outside App, we'll pass a loader or data
                // For simplicity, we'll move fetching logic inside App and pass `fullData` or use a prop function.
                // HOWEVER, keeping it self contained:
                // We'll trust the parent component (App) to handle the data fetching/display OR
                // we'll pass a `fetchDetails` prop.
                // Let's assume `item` passed is already enriched OR we trigger fetch on mount if needed.
                // Actually, the prompt says "Preview Modal... Fetches full details".
                // Since `fetchOmdbCached` is inside App, let's assume `item` passed MIGHT be partial.
                // We will handle loading state here if a fetcher is passed.
            }, [item]);

            // Simplified: The parent (App) will handle fetching full details before showing this or passes a promise
            // Actually, let's implement the fetching inside this component via a prop.
            
            if (!item) return null;

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                    <div className="bg-white dark:bg-dark-card w-full max-w-lg p-6 rounded-2xl relative max-h-[90vh] overflow-y-auto custom-scrollbar shadow-2xl">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-500 hover:text-white z-20 bg-black/20 rounded-full p-1"><X size={20}/></button>
                        
                        <div className="relative z-10 mt-4">
                            <h2 className="text-xs font-bold text-gray-500 uppercase mb-4 tracking-widest text-center">Preview Mode</h2>
                            <MediaDetailsCard item={item} />
                            
                            <div className="mt-8 pt-4 border-t border-gray-100 dark:border-gray-800 flex gap-3">
                                {isAdmin ? (
                                    <button 
                                        onClick={() => onAdd(item.imdbID)}
                                        className="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl text-sm font-bold shadow-lg shadow-indigo-600/20 transition-all"
                                    >
                                        Add to Library
                                    </button>
                                ) : (
                                    <button 
                                        onClick={() => onSuggest(item)}
                                        className="flex-1 py-3 bg-indigo-100 hover:bg-indigo-200 text-indigo-700 dark:bg-indigo-900/50 dark:text-indigo-300 dark:hover:bg-indigo-900 rounded-xl text-sm font-bold transition-all"
                                    >
                                        Suggest to Admin
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        function App() {
            // -- State --
            const [session, setSession] = useState(null);
            
            // ADMIN CHECK
            const isAdmin = session && ADMIN_IDS.includes(session.user.id);

            const [vault, setVault] = useState({ watched: {}, watchlist: {} });
            const [apiKeys, setApiKeys] = useState(DEFAULT_KEYS);
            const [theme, setTheme] = useState('dark');
            const [viewMode, setViewMode] = useState('grid');
            
            const [showAuth, setShowAuth] = useState(false);
            const [syncStatus, setSyncStatus] = useState('idle');
            
            // -- UI State --
            const [searchQuery, setSearchQuery] = useState('');
            const [searchType, setSearchType] = useState(''); // '' | 'movie' | 'series'
            const [searchResults, setSearchResults] = useState([]);
            // REMOVED: activeFilter (replaced by split layout logic)
            const [activeSmartList, setActiveSmartList] = useState(null);
            
            // -- SORT & FILTER STATE --
            const [sortBy, setSortBy] = useState('updated'); 
            const [sortOrder, setSortOrder] = useState("desc");
            const [filters, setFilters] = useState({ genre: [], director: [], actor: [], studio: [] });
            const [showFilters, setShowFilters] = useState(false);

            const [selectedMovie, setSelectedMovie] = useState(null);
            const [actorModalData, setActorModalData] = useState(null); 
            const [showSettings, setShowSettings] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);

            // -- ADMIN & SUGGESTIONS STATE --
            const [adminSuggestions, setAdminSuggestions] = useState([]);
            const [showAdminSuggestions, setShowAdminSuggestions] = useState(false);
            const [pendingCount, setPendingCount] = useState(0);
            const [pendingMap, setPendingMap] = useState({});
            const [suggestModalItem, setSuggestModalItem] = useState(null);
            
            // -- SEARCH PREVIEW STATE --
            const [previewItem, setPreviewItem] = useState(null);
            const [previewLoading, setPreviewLoading] = useState(false);
            
            const searchTimeout = useRef(null);

            // --- 🔒 CACHED API WRAPPERS ---

            const fetchOmdbCached = async (url) => {
                const key = `omdb:${url}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(url);
                    const json = await res.json();
                    cacheSet(key, json);
                    return json;
                } catch(e) { console.error("OMDb Error", e); return null; }
            };

            const fetchTmdbCached = async (endpoint) => {
                if (!apiKeys.tmdb) return null;
                const key = `tmdb:${endpoint}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const sep = endpoint.includes('?') ? '&' : '?';
                    const res = await fetch(`https://api.themoviedb.org/3/${endpoint}${sep}api_key=${apiKeys.tmdb}`);
                    if (!res.ok) return null;
                    const json = await res.json();
                    cacheSet(key, json);
                    return json;
                } catch(e) { console.error("TMDB Error", e); return null; }
            };

            // 🌟 REGISTRY: FETCH MDL DETAILS (RAPIDAPI)
            const fetchMDLDetails = async (mdlId) => {
                if (!apiKeys.rapid) throw new Error("No RapidAPI Key");
                const res = await fetch(
                    `https://${RAPID_HOST_MDL}/tvshow/details/${mdlId}`,
                    {
                        headers: {
                            "x-rapidapi-host": RAPID_HOST_MDL,
                            "x-rapidapi-key": apiKeys.rapid
                        }
                    }
                );
                if (!res.ok) throw new Error("MDL fetch failed");
                return await res.json();
            };

            const normalizeMDL = (raw) => ({
                mdl_id: String(raw.data?.id || raw.id), // Ensure string for consistency
                title: raw.data?.title || raw.title,
                alt_titles: raw.data?.alternative_titles || [],
                year: parseInt(raw.data?.year || raw.year || 0),
                country: raw.data?.country || raw.country,
                type: raw.data?.type || raw.type,
                episodes: raw.data?.episodes || raw.episodes,
                rating: parseFloat(raw.data?.score || raw.data?.rating || raw.rating || 0),
                votes: parseInt(raw.data?.scored_by || raw.data?.votes || raw.votes || 0),
                genres: raw.data?.genres || [],
                synopsis: raw.data?.synopsis || raw.synopsis,
                poster_url: raw.data?.cover || raw.poster,
                raw: raw.data || raw
            });

            // 🌟 REGISTRY: STORE FOREVER PATTERN
            const storeMDLForever = async (mdlId) => {
                // 1. Check registry (Supabase)
                const { data: existing } = await supabaseClient
                    .from("mdl_registry")
                    .select("*") // Fetch all fields for local use
                    .eq("mdl_id", String(mdlId))
                    .single();

                if (existing) return existing;

                // 2. Fetch & normalize (RapidAPI)
                try {
                    const raw = await fetchMDLDetails(mdlId);
                    const normalized = normalizeMDL(raw);

                    // 3. Store forever (Supabase)
                    const { error } = await supabaseClient
                        .from("mdl_registry")
                        .upsert(normalized);
                    
                    if (error) console.error("Registry upsert error:", error);

                    return normalized;
                } catch (e) {
                    console.error("Store MDL Forever Error:", e);
                    return null;
                }
            };

            // 🌟 REGISTRY: LINK ITEM TO MDL
            const linkItemToMDL = async (imdbId, mdlId) => {
                await supabaseClient.from("mdl_imdb_map").upsert({
                    mdl_id: String(mdlId),
                    imdb_id: imdbId,
                    confidence: 1.0,
                    source: "manual-enrich"
                });
            };

            // 🌟 REGISTRY: SEARCH MDL (To find ID first)
            const searchMDLTitle = async (title) => {
                if (!apiKeys.rapid) return null;
                try {
                    const res = await fetch(`https://${RAPID_HOST_MDL}/search`, {
                        method: "POST", 
                        headers: { "content-type": "application/json", "X-RapidAPI-Key": apiKeys.rapid, "X-RapidAPI-Host": RAPID_HOST_MDL },
                        body: JSON.stringify({ query: title, limit: 1 })
                    });
                    if (!res.ok) return null;
                    const json = await res.json();
                    if (!json || !json.results?.length) return null;
                    return json.results[0]; // Returns search result object (has ID)
                } catch(e) { return null; }
            };

            // 🍥 JIKAN API (MAL) - No Key
            const fetchMALAnime = async (title) => {
                const cacheKey = `mal:${title.toLowerCase()}`;
                const cached = cacheGet(cacheKey);
                if (cached) return cached;

                try {
                    const res = await fetch(`https://api.jikan.moe/v4/anime?q=${encodeURIComponent(title)}&limit=1`);
                    const json = await res.json();
                    const anime = json.data?.[0];
                    if (!anime) return null;

                    const normalized = {
                        id: anime.mal_id,
                        title: anime.title,
                        rating: anime.score,
                        votes: anime.scored_by,
                        episodes: anime.episodes,
                        status: anime.status,
                        aired: anime.aired?.string,
                        genres: anime.genres.map(g => g.name),
                        poster: anime.images?.jpg?.large_image_url,
                        url: anime.url
                    };
                    cacheSet(cacheKey, normalized);
                    return normalized;
                } catch(e) { return null; }
            };

            // 📺 TVMAZE API - No Key
            const fetchTVMazeByImdb = async (imdbID) => {
                const key = `tvmaze:${imdbID}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/lookup/shows?imdb=${imdbID}`);
                    if (!res.ok) return null;
                    const show = await res.json();
                    cacheSet(key, show);
                    return show;
                } catch(e) { return null; }
            };

            const fetchTVMazeEpisodes = async (tvmazeId) => {
                const key = `tvmaze:episodes:${tvmazeId}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/shows/${tvmazeId}/episodes`);
                    const episodes = await res.json();
                    const normalized = episodes.map(ep => ({
                        season: ep.season,
                        episode: ep.number,
                        title: ep.name,
                        airDate: ep.airdate,
                        runtime: ep.runtime,
                        summary: ep.summary ? ep.summary.replace(/<[^>]*>?/gm, '') : ''
                    }));
                    cacheSet(key, normalized);
                    return normalized;
                } catch(e) { return []; }
            };

            const fetchTVMazeCast = async (tvmazeId) => {
                const key = `tvmaze:cast:${tvmazeId}`;
                const cached = cacheGet(key);
                if (cached) return cached;
                try {
                    const res = await fetch(`https://api.tvmaze.com/shows/${tvmazeId}/cast`);
                    const cast = await res.json();
                    const normalized = cast.slice(0,10).map(c => ({
                        name: c.person.name,
                        character: c.character.name,
                        photo: c.person.image?.medium || null
                    }));
                    cacheSet(key, normalized);
                    return normalized;
                } catch(e) { return []; }
            };


            // --- HELPER FUNCTIONS REFACTORED TO USE CACHE ---

            const fetchTmdbId = async (imdbID, type) => {
              if (!apiKeys.tmdb) return null;
              const json = await fetchTmdbCached(`find/${imdbID}?external_source=imdb_id`);
              if (!json) return null;
              return type === "movie" ? json.movie_results?.[0]?.id : json.tv_results?.[0]?.id;
            };

            const extractDirectors = (crew, type) => {
              if (!crew) return [];
              if (type === "movie") return crew.filter(c => c.job === "Director").map(d => d.name);
              return crew.filter(c => c.department === "Directing" || c.job === "Executive Producer").slice(0,2).map(d => d.name); 
            };

            const fetchCredits = async (tmdbId, type) => {
              const endpoint = type === "movie" ? "movie" : "tv";
              return await fetchTmdbCached(`${endpoint}/${tmdbId}/credits`);
            };

            const normalizeCast = (cast) =>
              cast.slice(0, 12).map(actor => ({
                id: actor.id,
                name: actor.name,
                character: actor.character,
                photo: actor.profile_path ? `https://image.tmdb.org/t/p/w185${actor.profile_path}` : null
              }));

            const fetchTvDetails = async (tmdbId) => {
              return await fetchTmdbCached(`tv/${tmdbId}`);
            };

            const fetchSeasonEpisodes = async (tmdbId, seasonNumber) => {
              const json = await fetchTmdbCached(`tv/${tmdbId}/season/${seasonNumber}`);
              if (!json) return [];
              return json.episodes.map(ep => ({
                episode: ep.episode_number,
                title: ep.name,
                airDate: ep.air_date,
                overview: ep.overview,
                still: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : null,
                imdbRating: ep.vote_average ? ep.vote_average.toFixed(1) : null,
                rating: null,
                watched: false,
                watchedOn: null,
                notes: ""
              }));
            };

            const fetchFilmography = async (actorId) => {
                const json = await fetchTmdbCached(`person/${actorId}/combined_credits`);
                if (!json) return [];
                return json.cast
                    .filter(c => c.poster_path && (c.media_type === 'movie' || c.media_type === 'tv'))
                    .sort((a, b) => b.popularity - a.popularity)
                    .slice(0, 20);
            };

            const onActorClick = async (actor) => {
                const credits = await fetchFilmography(actor.id);
                setActorModalData({ name: actor.name, credits, id: actor.id, photo: actor.photo });
            };

            const searchByPerson = async (query) => {
              if(!apiKeys.tmdb) return [];
              const json = await fetchTmdbCached(`search/person?query=${encodeURIComponent(query)}`);
              if (!json) return [];
              return json.results.slice(0, 3).map(p => ({
                  ...p,
                  media_type: 'person',
                  Title: p.name,
                  imdbID: `person_${p.id}` 
              }));
            };


            // --- 3️⃣ UNIFIED ENRICHMENT PIPELINE (REGISTRY UPGRADED) ---
            const enrichItem = async (item) => {
                let updates = {};
                let metaUpdates = { ...item.meta };

                // A. Anime Detection & Fetch (Jikan)
                if (item.Genre?.includes('Animation') && !item.meta.anime) {
                    const mal = await fetchMALAnime(item.Title);
                    if (mal) {
                        metaUpdates.anime = { mal };
                    }
                }

                // B. TV Show Deep Dive (TVMaze)
                if (item.Type === "series" && !item.meta.tvmaze) {
                    const show = await fetchTVMazeByImdb(item.imdbID);
                    if (show) {
                        const episodes = await fetchTVMazeEpisodes(show.id);
                        const cast = await fetchTVMazeCast(show.id);
                        metaUpdates.tvmaze = { id: show.id, episodes, cast };
                    }
                }

                // C. Asian Drama (MDL REGISTRY FLOW)
                if (isAsianDrama(item) && !item.meta.asian) {
                     // 1. Check Supabase Mapping
                     const { data: map } = await supabaseClient.from("mdl_imdb_map").select("mdl_id").eq("imdb_id", item.imdbID).single();
                     
                     let mdlData = null;

                     if (map) {
                         // Found in map -> Get from Registry
                         mdlData = await storeMDLForever(map.mdl_id);
                     } else {
                         // Not found -> Search API
                         const searchResult = await searchMDLTitle(item.Title);
                         if (searchResult) {
                             // Found -> Detail Fetch + Store Forever
                             mdlData = await storeMDLForever(searchResult.id);
                             if (mdlData) {
                                 // Create Mapping for future
                                 await linkItemToMDL(item.imdbID, mdlData.mdl_id);
                             }
                         }
                     }

                     if (mdlData) {
                         // Adapting registry format to UI expectations (rating/votes/url)
                         metaUpdates.asian = { 
                             mdl: { 
                                 id: mdlData.mdl_id,
                                 title: mdlData.title,
                                 rating: mdlData.rating,
                                 votes: mdlData.votes,
                                 url: `https://mydramalist.com/${mdlData.mdl_id}`, // Construct URL as API might not give full web link in details
                                 lastFetched: Date.now() 
                             } 
                         };
                     }
                }

                // D. TMDB Core Data
                const needsTmdb = !item.tmdb?.enriched && apiKeys.tmdb;
                if (needsTmdb) {
                    const tmdbId = item.tmdb?.id || await fetchTmdbId(item.imdbID, item.Type === 'series' ? 'tv' : 'movie');
                    if (tmdbId) {
                        const credits = await fetchCredits(tmdbId, item.Type === 'series' ? 'tv' : 'movie');
                        const directors = extractDirectors(credits?.crew, item.Type);
                        const cast = normalizeCast(credits?.cast || []);

                        let seasons = null;
                        if (item.Type === "series") {
                            const tv = await fetchTvDetails(tmdbId);
                            if (tv && tv.seasons) {
                                seasons = await Promise.all(
                                    tv.seasons
                                        .filter(s => s.season_number > 0)
                                        .map(async s => ({
                                            season: s.season_number,
                                            airDate: s.air_date,
                                            episodes: await fetchSeasonEpisodes(tmdbId, s.season_number)
                                        }))
                                );
                            }
                        }
                        
                        metaUpdates.director = directors.length > 0 ? directors : metaUpdates.director;
                        metaUpdates.cast = cast.length > 0 ? cast : metaUpdates.cast;
                        if (seasons) metaUpdates.series = { seasons };
                        
                        updates.tmdb = {
                            id: tmdbId,
                            credits: { cast: cast, crew: credits?.crew?.slice(0,5) },
                            seasons,
                            enriched: true
                        };
                    }
                }

                updates.meta = metaUpdates;
                
                // Only update if there are changes
                if (Object.keys(updates).length > 0) {
                    updateItem(item.imdbID, i => ({ ...i, ...updates }));
                }
            };

            // --- HELPER: FETCH FULL DETAILS FOR PREVIEW ---
            const fetchFullDetails = async (imdbID) => {
                // This mimics the first part of addToVault but returns data instead of saving
                const fullItem = await fetchOmdbCached(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${imdbID}&plot=full`);
                if (!fullItem || fullItem.Response === "False") return null;
                // Migrate item but with status null (not in library)
                return migrateItem(fullItem, null);
            };

            // --- APP EFFECTS ---
            useEffect(() => {
                if (theme === 'dark') document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark');
                const localKeys = localStorage.getItem('vault_v5_keys'); if (localKeys) setApiKeys(JSON.parse(localKeys));
                const localVault = localStorage.getItem('vault_v6_data');
                if (localVault) { try { const parsed = JSON.parse(localVault); let changed = false; ['watched', 'watchlist'].forEach(listKey => { if (parsed[listKey]) { Object.keys(parsed[listKey]).forEach(key => { const item = parsed[listKey][key]; if (!item.tmdb || !item.meta.ratingsExternal || item.meta.asian === undefined || item.meta.tvmaze === undefined) { parsed[listKey][key] = migrateItem(item); changed = true; } }); } }); setVault(parsed); if (changed) { localStorage.setItem('vault_v6_data', JSON.stringify(parsed)); } } catch (e) { console.error("Corrupted local vault", e); } }
            }, []);

            useEffect(() => {
                supabaseClient.auth.getSession().then(({ data }) => setSession(data.session));
                const { data: listener } = supabaseClient.auth.onAuthStateChange((_event, session) => setSession(session));
                return () => listener.subscription.unsubscribe();
            }, []);

            useEffect(() => { localStorage.setItem('vault_v5_keys', JSON.stringify(apiKeys)); }, [apiKeys]);
            useEffect(() => { if (theme === 'dark') document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); }, [theme]);

            const handleLogin = (session) => setSession(session);
            const handleLogout = async () => { await supabaseClient.auth.signOut(); setSession(null); };

            const handleExport = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(vault));
                const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr); downloadAnchorNode.setAttribute("download", "vault_backup_" + new Date().toISOString().split('T')[0] + ".json"); document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
            };

            const handleImport = (e) => {
                const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const rawData = JSON.parse(event.target.result); if (!rawData.watched && !rawData.watchlist) throw new Error("Invalid format: Not a Vault backup file");
                        const processedVault = { watched: {}, watchlist: {} }; Object.entries(rawData.watched || {}).forEach(([id, item]) => processedVault.watched[id] = migrateItem(item, 'watched')); Object.entries(rawData.watchlist || {}).forEach(([id, item]) => processedVault.watchlist[id] = migrateItem(item, 'watchlist'));
                        setVault(processedVault); localStorage.setItem('vault_v6_data', JSON.stringify(processedVault));
                        if (session) { setSyncStatus('syncing'); await supabaseClient.from('vault_items').delete().eq('user_id', session.user.id); const items = []; [...Object.values(processedVault.watched), ...Object.values(processedVault.watchlist)].forEach(item => { items.push({ user_id: session.user.id, imdb_id: item.imdbID, user_meta: item, updated_at: new Date() }); }); const chunkSize = 50; for (let i = 0; i < items.length; i += chunkSize) { const chunk = items.slice(i, i + chunkSize); await supabaseClient.from('vault_items').upsert(chunk); } setSyncStatus('idle'); } setShowSettings(false); alert("Vault restored successfully!");
                    } catch (err) { alert("Failed to import file: " + err.message); }
                }; reader.readAsText(file);
            };

           useEffect(() => {
              if (!session) return; setSyncStatus("syncing");
              supabaseClient.from("vault_items").select("*").then(({ data, error }) => { if (error) { setSyncStatus("error"); return console.error(error); } setSyncStatus("idle"); const newVault = { watched: {}, watchlist: {} }; data.forEach(row => { let item = row.user_meta; const defaultStatus = (item.userRating && parseFloat(item.userRating) > 0) ? 'watched' : 'watchlist'; const status = item.userMeta?.status || defaultStatus; item = migrateItem(item, status); if (item.userMeta?.status === "watched") newVault.watched[row.imdb_id] = item; else newVault.watchlist[row.imdb_id] = item; }); setVault(newVault); localStorage.setItem("vault_v6_data", JSON.stringify(newVault)); }).catch(err => { setSyncStatus("error"); console.error(err); });
            }, [session]);

            const updateItem = useCallback((imdbID, updater) => {
                setVault(prev => { const item = prev.watched[imdbID] || prev.watchlist[imdbID]; if (!item) return prev; const updatedItem = updater(item); if (!updatedItem.userMeta.lastUpdated) updatedItem.userMeta.lastUpdated = Date.now(); const newStatus = updatedItem.userMeta.status; const nextWatched = { ...prev.watched }; const nextWatchlist = { ...prev.watchlist }; delete nextWatched[imdbID]; delete nextWatchlist[imdbID]; if (newStatus === 'watched') nextWatched[imdbID] = updatedItem; else nextWatchlist[imdbID] = updatedItem; const nextVault = { watched: nextWatched, watchlist: nextWatchlist }; localStorage.setItem("vault_v6_data", JSON.stringify(nextVault)); saveToCloudThrottled(imdbID, updatedItem, session); return nextVault; });
            }, [session]);

            useEffect(() => { if (!selectedMovie) return; const updated = vault.watched[selectedMovie.imdbID] || vault.watchlist[selectedMovie.imdbID]; if (updated && updated !== selectedMovie) setSelectedMovie(updated); if (updated) enrichItem(updated); }, [vault, selectedMovie]);

            const toggleEpisode = (imdbID, seasonNum, epNum) => { updateItem(imdbID, item => { const seasons = item.meta.series.seasons.map(s => s.season !== seasonNum ? s : { ...s, episodes: s.episodes.map(e => e.episode !== epNum ? e : { ...e, watched: !e.watched, watchedOn: !e.watched ? new Date().toISOString() : null }) }); return { ...item, meta: { ...item.meta, series: { seasons } } }; }); };
            const rateEpisode = (imdbID, seasonNum, epNum, rating) => { updateItem(imdbID, item => ({ ...item, meta: { ...item.meta, series: { seasons: item.meta.series.seasons.map(s => s.season !== seasonNum ? s : { ...s, episodes: s.episodes.map(e => e.episode === epNum ? { ...e, rating } : e) }) } } })); };

            const existsInVault = useCallback((imdbID) => !!(vault.watched[imdbID] || vault.watchlist[imdbID]), [vault]);

            const searchOfflineVault = useCallback((query) => {
              const norm = normalize(query); if (!norm) return []; const all = [...Object.values(vault.watched), ...Object.values(vault.watchlist)]; const matches = all.filter(item => normalize(item.Title).includes(norm) || item.imdbID === query); return matches.sort((a, b) => (b.userMeta?.lastUpdated || 0) - (a.userMeta?.lastUpdated || 0));
            }, [vault]);

            const smartSearch = useCallback(async (query, type = "", year = "") => {
              const offline = searchOfflineVault(query); if (offline.length > 0 && !type) return { source: "offline", results: offline }; // Only use offline if no specific type requested, or we could filter offline. For now simplified.
              
              // Only search OMDb
              const cacheKey = `vault_search_${type}_${query}_${year}`; const cached = cacheGet(cacheKey); if (cached) return { source: "cache", results: cached };
              try { const json = await fetchOmdbCached(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&s=${encodeURIComponent(query)}&type=${type}&y=${year}`); let results = []; if (json && json.Response === "True") results = json.Search; const people = await searchByPerson(query); results = [...results, ...people]; const ranked = results.sort((a, b) => { const exactA = normalize(a.Title) === normalize(query); const exactB = normalize(b.Title) === normalize(query); if (exactA !== exactB) return exactB - exactA; return (parseInt(b.Year) || 0) - (parseInt(a.Year) || 0); }); cacheSet(cacheKey, ranked); return { source: "remote", results: ranked }; } catch (e) { console.error(e); return { source: "error", results: [] }; }
            }, [apiKeys, searchOfflineVault]);

            const addToVault = async (imdbID, status = "watchlist") => {
              if (!isAdmin) { alert("Only admin can add to the library directly."); return; }
              // Re-fetch to ensure we have full data, or rely on cache
              const fullItem = await fetchOmdbCached(`https://www.omdbapi.com/?apikey=${apiKeys.omdb}&i=${imdbID}&plot=full`);
              if (!fullItem || fullItem.Response === "False") return;
              const migrated = migrateItem(fullItem, status);
              setVault(prev => { const next = { watched: { ...prev.watched }, watchlist: { ...prev.watchlist } }; delete next.watched[imdbID]; delete next.watchlist[imdbID]; if (status === "watched") next.watched[imdbID] = migrated; else next.watchlist[imdbID] = migrated; localStorage.setItem("vault_v6_data", JSON.stringify(next)); return next; });
              saveToCloudThrottled(imdbID, migrated, session);
              setSearchResults([]); setSearchQuery('');
              setPreviewItem(null); // Close preview if open
            };

            const fetchPendingSuggestions = useCallback(async () => { if (!session) return; const { data } = await supabaseClient.from("content_suggestions").select("imdb_id, votes").eq("status", "pending"); if (data) { const map = {}; data.forEach(s => map[s.imdb_id] = s); setPendingMap(map); } }, [session]);
            useEffect(() => { if(session) fetchPendingSuggestions(); }, [session, fetchPendingSuggestions]);
            useEffect(() => { if (!isAdmin) return; const fetchCount = async () => { const { count } = await supabaseClient.from("content_suggestions").select("*", { count: "exact", head: true }).eq("status", "pending"); setPendingCount(count || 0); }; fetchCount(); const channel = supabaseClient.channel("suggestions_count").on("postgres_changes", { event: "*", schema: "public", table: "content_suggestions" }, fetchCount).subscribe(); return () => supabaseClient.removeChannel(channel); }, [isAdmin]);

            const handleOpenSuggestModal = (item) => { if (!session) { alert("Please login to suggest content."); return; } setSuggestModalItem(item); };
            const handleSubmitSuggestion = async (item, reason, priority) => {
                const { data: existing } = await supabaseClient.from("content_suggestions").select("*").eq("imdb_id", item.imdbID).eq("status", "pending").single();
                if (existing) {
                    if (existing.suggested_by && existing.suggested_by.includes(session.user.id)) { alert("You have already voted for this title!"); return; }
                    const { error } = await supabaseClient.from("content_suggestions").update({ votes: (existing.votes || 0) + 1, suggested_by: [...(existing.suggested_by || []), session.user.id], reasons: [...(existing.reasons || []), { user: session.user.id, text: reason, priority }], updated_at: new Date() }).eq("id", existing.id);
                    if (error) console.error(error); else alert("Vote added to existing suggestion! 👍");
                } else {
                    const { error } = await supabaseClient.from("content_suggestions").insert({ imdb_id: item.imdbID, title: item.Title, year: parseInt(item.Year) || 0, type: item.Type === "series" ? "series" : "movie", suggested_by: [session.user.id], votes: 1, priority: priority, reasons: [{ user: session.user.id, text: reason, priority }], status: 'pending' });
                    if (error) console.error(error); else alert("Suggestion sent to admin! 🚀");
                }
                setSuggestModalItem(null); fetchPendingSuggestions(); setPreviewItem(null);
            };

            const fetchAdminSuggestions = async () => { if (!isAdmin) return; const { data } = await supabaseClient.from("content_suggestions").select("*").eq("status", "pending").order("votes", { ascending: false }); setAdminSuggestions(data || []); };
            useEffect(() => { if (isAdmin && showAdminSuggestions) fetchAdminSuggestions(); }, [isAdmin, showAdminSuggestions]);
            const handleApprove = async (s) => { await addToVault(s.imdb_id, "watchlist"); await supabaseClient.from("content_suggestions").update({ status: 'approved' }).eq('id', s.id); fetchAdminSuggestions(); fetchPendingSuggestions(); };
            const handleReject = async (id) => { await supabaseClient.from("content_suggestions").update({ status: 'rejected' }).eq('id', id); fetchAdminSuggestions(); fetchPendingSuggestions(); };

            const handleSearch = async (q) => { if (!q || q.length < 3) { setSearchResults([]); return; } const { results } = await smartSearch(q, searchType); setSearchResults(results || []); };
            const handleSearchInput = (value) => { setSearchQuery(value); if (searchTimeout.current) clearTimeout(searchTimeout.current); if (value.length < 3) { setSearchResults([]); return; } searchTimeout.current = setTimeout(() => { handleSearch(value); }, 400); };
            const handleSearchTypeChange = (type) => { setSearchType(type); if(searchQuery.length >= 3) { if (searchTimeout.current) clearTimeout(searchTimeout.current); handleSearch(searchQuery); } };

            // --- FILTER LOGIC ---
            const allItems = useMemo(() => [...Object.values(vault.watched), ...Object.values(vault.watchlist)], [vault]);

            const includesAny = (source = [], target = []) => target.length === 0 || target.some(t => source.includes(t));

            const filterOptions = useMemo(() => {
                const genres = new Set();
                const directors = new Set();
                const actors = new Set();
                const studios = new Set();

                allItems.forEach(item => {
                    const gList = Array.isArray(item.meta?.genre) ? item.meta.genre : item.Genre?.split(",").map(g => g.trim()) || [];
                    gList.forEach(g => genres.add(g));
                    
                    const dList = Array.isArray(item.meta?.director) ? item.meta.director : (item.meta?.director ? [item.meta.director] : []);
                    dList.forEach(d => directors.add(d));

                    item.meta?.cast?.forEach(c => actors.add(c.name));

                    if (item.Production && item.Production !== "N/A") {
                        item.Production.split(",").map(s => s.trim()).forEach(s => studios.add(s));
                    }
                });

                return {
                    genres: [...genres].sort(),
                    directors: [...directors].sort(),
                    actors: [...actors].sort(),
                    studios: [...studios].sort()
                };
            }, [allItems]);

            const processedItems = useMemo(() => {
                let items = allItems;

                // 1. Text Search (Local)
                if (searchQuery && searchQuery.length < 3) {
                    // Small UX fix: allow filtering local list instantly even if <3 chars, 
                    // though API search waits for 3.
                    const q = searchQuery.toLowerCase(); 
                    items = items.filter(i => i.Title.toLowerCase().includes(q)); 
                } else if (searchQuery) {
                    const q = searchQuery.toLowerCase(); 
                    items = items.filter(i => i.Title.toLowerCase().includes(q));
                }

                // 2. Smart Lists
                if (activeSmartList) { 
                    const list = SMART_LISTS.find(l => l.id === activeSmartList); 
                    if (list) items = items.filter(list.filter); 
                }

                // 3. Advanced Filters
                items = items.filter(item => {
                    const itemGenres = Array.isArray(item.meta?.genre) ? item.meta.genre : item.Genre?.split(",").map(g => g.trim()) || [];
                    const itemDirectors = Array.isArray(item.meta?.director) ? item.meta.director : (item.meta?.director ? [item.meta.director] : []);
                    const itemActors = item.meta?.cast?.map(c => c.name) || [];
                    const itemStudios = item.Production ? item.Production.split(",").map(s => s.trim()) : [];

                    return (
                        includesAny(itemGenres, filters.genre) &&
                        includesAny(itemDirectors, filters.director) &&
                        includesAny(itemActors, filters.actor) &&
                        includesAny(itemStudios, filters.studio)
                    );
                });

                // 4. Sorting
                items.sort((a, b) => {
                    let result = 0;
                    if (sortBy === "name") result = a.Title.localeCompare(b.Title);
                    else if (sortBy === "year") result = (parseInt(a.Year) || 0) - (parseInt(b.Year) || 0);
                    else if (sortBy === "rating") result = (a.userMeta?.ratings?.overall || 0) - (b.userMeta?.ratings?.overall || 0);
                    else if (sortBy === "updated") result = (a.userMeta?.lastUpdated || 0) - (b.userMeta?.lastUpdated || 0);
                    
                    return sortOrder === "asc" ? result : -result;
                });

                return items;
            }, [allItems, searchQuery, activeSmartList, filters, sortBy, sortOrder]);

            // Split into movies and series for new layout
            const movies = useMemo(() => processedItems.filter(i => i.Type === "movie"), [processedItems]);
            const series = useMemo(() => processedItems.filter(i => i.Type === "series"), [processedItems]);

            const analytics = useMemo(() => {
                const total = allItems.length; if (total === 0) return { avgRating: 0, totalRewatch: 0, watchedCount: 0, watchedEpisodes: 0, avgEpisodeRating: 0 };
                const watched = Object.values(vault.watched); const avgRating = watched.reduce((acc, curr) => acc + (curr.userMeta?.ratings?.overall || 0), 0) / (watched.length || 1); const totalRewatch = watched.reduce((acc, curr) => acc + (curr.userMeta?.rewatchCount || 0), 0);
                const eps = allItems.filter(i => i.Type === "series" && i.meta?.series?.seasons).flatMap(i => i.meta.series.seasons.flatMap(s => s.episodes || [])); const watchedEps = eps.filter(e => e.watched); const ratedEps = eps.filter(e => e.rating > 0); const avgEpRating = ratedEps.length > 0 ? ratedEps.reduce((a, e) => a + (e.rating || 0), 0) / ratedEps.length : 0;
                return { avgRating: avgRating.toFixed(1), totalRewatch, watchedCount: watched.length, watchedEpisodes: watchedEps.length, avgEpisodeRating: avgEpRating.toFixed(1) };
            }, [allItems, vault]);
            const mdlStats = useMemo(() => { const dramas = allItems.map(i => i.meta?.asian?.mdl).filter(Boolean); return { avgMDL: dramas.length > 0 ? (dramas.reduce((a, d) => a + (d.rating || 0), 0) / dramas.length).toFixed(1) : 0, totalTitles: dramas.length }; }, [allItems]);
            
            const timelineEvents = useMemo(() => {
                const events = []; Object.values(vault.watched).forEach(item => { events.push({ type: "movie", imdbID: item.imdbID, title: item.Title, watchedOn: item.userMeta.watchedOn, rating: item.userMeta.ratings.overall, poster: item.Poster }); });
                allItems.filter(i => i.Type === "series" && i.meta?.series?.seasons).forEach(series => { series.meta.series.seasons.forEach(s => s.episodes.forEach(e => { if (e.watched) { events.push({ type: "episode", imdbID: series.imdbID, title: `${series.Title} • S${s.season}E${e.episode}`, watchedOn: e.watchedOn, rating: e.rating, poster: series.Poster }); } })); });
                return events.sort((a, b) => new Date(b.watchedOn) - new Date(a.watchedOn));
            }, [vault, allItems]);

            const peopleStats = useMemo(() => {
                const map = {}; allItems.forEach(item => { if (Array.isArray(item.meta?.director)) { item.meta.director.forEach(name => { map[name] ??= { movies: 0, avgRating: [], type: "director" }; map[name].movies++; if(item.userMeta.ratings.overall > 0) map[name].avgRating.push(item.userMeta.ratings.overall); }); } else if (item.meta?.director && item.meta.director !== "N/A") { const name = item.meta.director; map[name] ??= { movies: 0, avgRating: [], type: "director" }; map[name].movies++; if(item.userMeta.ratings.overall > 0) map[name].avgRating.push(item.userMeta.ratings.overall); } item.meta?.cast?.forEach(actor => { map[actor.name] ??= { movies: 0, avgRating: [], type: "actor" }; map[actor.name].movies++; if(item.userMeta.ratings.overall > 0) map[actor.name].avgRating.push(item.userMeta.ratings.overall); }); });
                return Object.entries(map).map(([name, d]) => ({ name, type: d.type, count: d.movies, avgRating: d.avgRating.length > 0 ? (d.avgRating.reduce((a, b) => a + b, 0) / d.avgRating.length) : 0 })).filter(p => p.count > 1).sort((a, b) => b.count - a.count).slice(0, 8);
            }, [allItems]);

            // Handling Preview Item click from Search Results
            const handleSearchResultClick = async (item) => {
                // If already in vault, select it
                if (existsInVault(item.imdbID)) {
                    setSelectedMovie(vault.watched[item.imdbID] || vault.watchlist[item.imdbID]);
                    setSearchResults([]); setSearchQuery('');
                    return;
                }
                // Open Preview Modal
                setPreviewLoading(true);
                setPreviewItem(null); // Clear previous
                // Fetch full details
                const fullDetails = await fetchFullDetails(item.imdbID);
                setPreviewLoading(false);
                if (fullDetails) {
                    setPreviewItem(fullDetails);
                } else {
                    alert("Failed to load details");
                }
                setSearchResults([]); setSearchQuery('');
            };

            return (
                <div className="min-h-screen pb-32 selection:bg-indigo-500 selection:text-white">
                    <AuthModal isOpen={showAuth} onClose={() => setShowAuth(false)} onLogin={handleLogin} />

                    <header className="sticky top-0 z-30 bg-white/80 dark:bg-dark-bg/80 backdrop-blur-md border-b border-light-border dark:border-dark-border px-4 h-16 flex items-center justify-between">
                         <div className="flex items-center gap-3">
                             <div className="text-indigo-600 dark:text-indigo-500"><VaultLogoIcon size={38} strokeWidth={1.5} /></div>
                             <div className="flex flex-col justify-center">
                                 <span className="text-[10px] font-bold tracking-[0.25em] leading-tight text-gray-500 dark:text-gray-400 uppercase pl-0.5">The</span>
                                 <span className="text-2xl font-black tracking-[0.15em] leading-none uppercase text-gray-900 dark:text-white font-sans">Vault</span>
                             </div>
                         </div>
                         <div className="flex bg-gray-100 dark:bg-gray-800 rounded-full p-1 mx-4">
                             <button onClick={() => setViewMode('grid')} className={`p-2 rounded-full transition-all ${viewMode === 'grid' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><Grid size={18}/></button>
                             <button onClick={() => setViewMode('timeline')} className={`p-2 rounded-full transition-all ${viewMode === 'timeline' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><Clock size={18}/></button>
                             <button onClick={() => setViewMode('analytics')} className={`p-2 rounded-full transition-all ${viewMode === 'analytics' ? 'bg-white dark:bg-dark-card shadow text-indigo-600' : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'}`}><BarChart size={18}/></button>
                         </div>
                         <div className="flex items-center gap-2">
                             {/* ADMIN BADGE & INBOX */}
                             {isAdmin && (
                                <div className="flex items-center mr-2 gap-2">
                                    <span className="text-[10px] font-black tracking-widest text-indigo-500 border border-indigo-500/30 px-2 py-1 rounded bg-indigo-500/10">ADMIN</span>
                                    <button onClick={() => setShowAdminSuggestions(true)} className="relative p-2 text-gray-500 hover:text-indigo-600 bg-gray-100 dark:bg-gray-800 rounded-full">
                                        <Inbox size={18}/>
                                        {pendingCount > 0 && <span className="absolute top-0 right-0 w-3.5 h-3.5 bg-red-500 rounded-full border-2 border-white dark:border-dark-bg text-[9px] flex items-center justify-center text-white font-bold leading-none">{pendingCount}</span>}
                                    </button>
                                </div>
                             )}
                             
                             {!session ? (<button onClick={() => setShowAuth(true)} className="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold transition-colors"><LogIn size={16} /> Login</button>) : ( <div className="flex items-center gap-2"> <div className={`w-2 h-2 rounded-full ${syncStatus === 'syncing' ? 'bg-yellow-400 animate-pulse' : syncStatus === 'error' ? 'bg-red-500' : 'bg-green-500'}`} title={`Sync Status: ${syncStatus}`}></div> <button onClick={handleLogout} className="p-2 text-gray-500 hover:text-red-500"><User size={20}/></button> </div> )}
                             <button onClick={() => setShowSettings(true)} className="p-2 text-gray-500 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-white"><Settings size={20} /></button>
                         </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-4 pt-8">
                        {viewMode === 'grid' && (
                            <>
                                <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-blue-100 dark:bg-blue-900/30 text-blue-600 rounded-lg"><Film size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Total Items</div><div className="text-xl font-black dark:text-white">{allItems.length}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-600 rounded-lg"><Star size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Avg Rating</div><div className="text-xl font-black dark:text-white">{analytics.avgRating}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-green-100 dark:bg-green-900/30 text-green-600 rounded-lg"><CheckSquare size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Ep. Watched</div><div className="text-xl font-black dark:text-white">{analytics.watchedEpisodes}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-purple-100 dark:bg-purple-900/30 text-purple-600 rounded-lg"><BarChart size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">Ep. Score</div><div className="text-xl font-black dark:text-white">{analytics.avgEpisodeRating}</div></div>
                                    </div>
                                    <div className="bg-white dark:bg-dark-card p-4 rounded-xl border border-light-border dark:border-dark-border flex items-center gap-3">
                                        <div className="p-3 bg-teal-100 dark:bg-teal-900/30 text-teal-600 rounded-lg"><Globe size={20}/></div>
                                        <div><div className="text-xs text-gray-500 uppercase font-bold">MDL Avg</div><div className="text-xl font-black dark:text-white">{mdlStats.avgMDL}</div></div>
                                    </div>
                                </div>

                                <div className="flex flex-wrap items-center justify-between gap-4 mb-6">
                                    <div className="flex items-center gap-2 overflow-x-auto">
                                        {/* Smart Lists Only (Removed Type filters as layout is now split) */}
                                        {SMART_LISTS.map(list => (
                                            <button key={list.id} onClick={() => { setActiveSmartList(list.id === activeSmartList ? null : list.id); }} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap flex items-center gap-2 ${activeSmartList === list.id ? 'bg-indigo-600 text-white' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}><list.icon size={14}/> {list.label}</button>
                                        ))}
                                        <button onClick={() => setShowFilters(!showFilters)} className={`px-4 py-1.5 rounded-full text-sm font-medium transition-colors whitespace-nowrap flex items-center gap-2 ${showFilters || (filters.genre.length+filters.director.length+filters.actor.length+filters.studio.length > 0) ? 'bg-gray-900 text-white dark:bg-white dark:text-black' : 'text-gray-500 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-800'}`}>
                                            <ListPlus size={14}/> Filters {(filters.genre.length+filters.director.length+filters.actor.length+filters.studio.length > 0) ? `(${filters.genre.length+filters.director.length+filters.actor.length+filters.studio.length})` : ''}
                                        </button>
                                    </div>
                                    <div className="relative w-full md:w-80">
                                        <div className="flex flex-col gap-2">
                                            {/* Search Type Tabs */}
                                            <div className="flex gap-2 text-xs">
                                                <button onClick={() => handleSearchTypeChange('')} className={`px-2 py-1 rounded transition-colors ${searchType === '' ? 'bg-indigo-600 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300'}`}>All</button>
                                                <button onClick={() => handleSearchTypeChange('movie')} className={`px-2 py-1 rounded transition-colors ${searchType === 'movie' ? 'bg-indigo-600 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300'}`}>Movies</button>
                                                <button onClick={() => handleSearchTypeChange('series')} className={`px-2 py-1 rounded transition-colors ${searchType === 'series' ? 'bg-indigo-600 text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300'}`}>Series</button>
                                            </div>
                                            <div className="relative">
                                                <Search className="absolute left-3 top-2.5 text-gray-400" size={16} />
                                                <input type="text" placeholder="Search API & Vault..." value={searchQuery} onChange={(e) => handleSearchInput(e.target.value)} className="w-full bg-gray-100 dark:bg-gray-800 rounded-full pl-10 pr-4 py-2 text-sm text-gray-900 dark:text-white outline-none focus:border-indigo-500" />
                                            </div>
                                        </div>
                                        
                                        {/* Updated Search Dropdown */}
                                        {searchResults.length > 0 && (
                                            <div className="absolute z-50 mt-2 w-full bg-white dark:bg-dark-card rounded-xl shadow-xl max-h-96 overflow-y-auto border border-gray-200 dark:border-gray-700">
                                                {searchResults.map((item, idx) => {
                                                const inVault = item.media_type !== 'person' && existsInVault(item.imdbID);
                                                const suggestion = item.media_type !== 'person' && pendingMap[item.imdbID];

                                                if (item.media_type === 'person') {
                                                    return (
                                                        <div key={`${item.id}_person_${idx}`} onClick={() => { onActorClick({ id: item.id, name: item.Title, photo: item.profile_path ? `https://image.tmdb.org/t/p/w185${item.profile_path}` : null }); setSearchResults([]); setSearchQuery(''); }} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-800 border-b border-gray-100 dark:border-gray-800 cursor-pointer">
                                                            <div className="w-8 h-8 rounded-full bg-indigo-100 dark:bg-indigo-900/50 flex items-center justify-center text-indigo-600 dark:text-indigo-400">{item.profile_path ? <img src={`https://image.tmdb.org/t/p/w45${item.profile_path}`} className="w-full h-full rounded-full object-cover"/> : <User size={14} />}</div>
                                                            <div className="flex-1"><p className="font-semibold text-sm dark:text-white">{item.Title}</p><p className="text-xs text-gray-500">Actor • View Credits</p></div>
                                                        </div>
                                                    )
                                                }
                                                // New Search Result Card (Simplified)
                                                return (
                                                    <div 
                                                        key={`${item.imdbID}_${idx}`} 
                                                        onClick={() => handleSearchResultClick(item)}
                                                        className="flex items-center gap-3 px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-800 border-b border-gray-100 dark:border-gray-800 last:border-0 cursor-pointer group"
                                                    >
                                                        <img src={getHighResPoster(item.Poster, 200)} className="w-10 h-14 object-cover rounded bg-gray-800" />
                                                        <div className="flex-1 min-w-0">
                                                            <p className="font-semibold text-sm truncate dark:text-white group-hover:text-indigo-400 transition-colors">{item.Title}</p>
                                                            <p className="text-xs text-gray-500 capitalize">{item.Year} • {item.Type}</p>
                                                        </div>
                                                        <div className="flex gap-2 shrink-0">
                                                            {inVault ? (
                                                                <span className="text-[10px] uppercase font-bold text-green-500 bg-green-100 dark:bg-green-900/30 px-2 py-1 rounded">In Vault</span>
                                                            ) : suggestion ? (
                                                                <span className="text-[10px] uppercase font-bold text-yellow-500 bg-yellow-100 dark:bg-yellow-900/30 px-2 py-1 rounded">Pending</span>
                                                            ) : null}
                                                        </div>
                                                    </div>
                                                );
                                                })}
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* NEW: FILTER PANEL */}
                                {showFilters && (
                                    <div className="mb-8 p-4 bg-white dark:bg-dark-card border border-gray-200 dark:border-gray-800 rounded-2xl shadow-sm animate-fade-in">
                                        <div className="flex justify-between items-center mb-4">
                                            <h3 className="font-bold text-sm dark:text-white flex items-center gap-2"><Settings size={16}/> Advanced Filters</h3>
                                            <div className="flex gap-4 items-center">
                                                {(filters.genre.length > 0 || filters.director.length > 0 || filters.actor.length > 0 || filters.studio.length > 0) && (
                                                    <button onClick={() => setFilters({ genre: [], director: [], actor: [], studio: [] })} className="text-xs text-red-500 hover:text-red-600 font-bold flex items-center gap-1">
                                                        <Trash size={12}/> Clear Filters
                                                    </button>
                                                )}
                                                <SortControls sortBy={sortBy} setSortBy={setSortBy} sortOrder={sortOrder} setSortOrder={setSortOrder} />
                                            </div>
                                        </div>
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                            <FilterSelect label="Genre" options={filterOptions.genres} value={filters.genre} onChange={(v) => setFilters(f => ({ ...f, genre: v }))} />
                                            <FilterSelect label="Director" options={filterOptions.directors} value={filters.director} onChange={(v) => setFilters(f => ({ ...f, director: v }))} />
                                            <FilterSelect label="Actor" options={filterOptions.actors} value={filters.actor} onChange={(v) => setFilters(f => ({ ...f, actor: v }))} />
                                            <FilterSelect label="Studio" options={filterOptions.studios} value={filters.studio} onChange={(v) => setFilters(f => ({ ...f, studio: v }))} />
                                        </div>
                                    </div>
                                )}

                                {/* Divided Grid Layout */}
                                
                                {processedItems.length === 0 && (
                                    <div className="text-center py-20 text-gray-500">
                                        <div className="mb-2">No items found</div>
                                        <div className="text-xs opacity-60">Try searching or clearing filters</div>
                                    </div>
                                )}

                                {movies.length > 0 && (
                                    <section className="mb-12">
                                        <div className="flex justify-between items-end mb-6">
                                            <h2 className="text-xl font-bold dark:text-white flex items-center gap-2"><Film size={20}/> Movies <span className="text-sm font-normal text-gray-500 ml-2">({movies.length})</span></h2>
                                            {!showFilters && <div className="text-xs text-gray-400">Sorted by {sortBy}</div>}
                                        </div>
                                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-6 gap-y-10">
                                            {movies.map((item, idx) => (
                                                <div key={`${item.imdbID}_${idx}`} onClick={() => setSelectedMovie(item)} className="group relative bg-white dark:bg-dark-card rounded-xl overflow-hidden shadow-lg hover:scale-[1.02] transition-all cursor-pointer border border-light-border dark:border-dark-border">
                                                    <div className="relative aspect-[2/3] overflow-hidden bg-gray-900">
                                                        <img src={tmdbImg(item.tmdb?.credits?.images?.posters?.[0]?.file_path, "w342") || getHighResPoster(item.Poster, 400)} className="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity" loading="lazy" />
                                                        <div className="absolute top-2 right-2 flex flex-col gap-1 items-end">{item.userMeta?.status === 'watched' && <span className="bg-green-500/90 text-white text-[10px] font-bold px-2 py-1 rounded-md shadow-lg"><CheckCircle size={10} /></span>}</div>
                                                        {item.userMeta?.ratings?.overall > 0 && <div className="absolute bottom-2 left-2 bg-yellow-500 text-white px-1.5 py-0.5 rounded text-xs font-bold flex items-center gap-1 shadow-lg"><Star size={10} fill="currentColor" /> {item.userMeta.ratings.overall}</div>}
                                                        {item.meta?.asian?.mdl?.rating && <div className="absolute bottom-2 right-2 bg-teal-600 text-white px-1.5 py-0.5 rounded text-[10px] font-bold shadow-lg">MDL {item.meta.asian.mdl.rating}</div>}
                                                    </div>
                                                    <div className="p-3 space-y-1">
                                                        <h3 className="font-bold text-sm line-clamp-1 dark:text-white">{item.Title}</h3>
                                                        <div className="text-[11px] text-gray-500 flex flex-wrap gap-x-2"><span>{item.Year}</span><span>•</span><span>{item.Type === "series" ? "TV Series" : "Movie"}</span></div>
                                                        {item.meta?.director && <div className="text-[11px] text-gray-400 line-clamp-1"><span className="font-semibold">Dir:</span> {Array.isArray(item.meta.director) ? item.meta.director.join(", ") : item.meta.director}</div>}
                                                        <div className="flex flex-wrap gap-1 pt-1">{item.meta?.genre?.slice(0, 2).map(g => <span key={g} className="px-1.5 py-0.5 text-[9px] rounded bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300">{g}</span>)}</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </section>
                                )}

                                {series.length > 0 && (
                                    <section className="mb-12">
                                        <div className="flex justify-between items-end mb-6">
                                            <h2 className="text-xl font-bold dark:text-white flex items-center gap-2"><Tv size={20}/> TV Shows <span className="text-sm font-normal text-gray-500 ml-2">({series.length})</span></h2>
                                        </div>
                                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-6 gap-y-10">
                                            {series.map((item, idx) => (
                                                <div key={`${item.imdbID}_${idx}`} onClick={() => setSelectedMovie(item)} className="group relative bg-white dark:bg-dark-card rounded-xl overflow-hidden shadow-lg hover:scale-[1.02] transition-all cursor-pointer border border-light-border dark:border-dark-border">
                                                    <div className="relative aspect-[2/3] overflow-hidden bg-gray-900">
                                                        <img src={tmdbImg(item.tmdb?.credits?.images?.posters?.[0]?.file_path, "w342") || getHighResPoster(item.Poster, 400)} className="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity" loading="lazy" />
                                                        <div className="absolute top-2 right-2 flex flex-col gap-1 items-end">{item.userMeta?.status === 'watched' && <span className="bg-green-500/90 text-white text-[10px] font-bold px-2 py-1 rounded-md shadow-lg"><CheckCircle size={10} /></span>}</div>
                                                        {item.userMeta?.ratings?.overall > 0 && <div className="absolute bottom-2 left-2 bg-yellow-500 text-white px-1.5 py-0.5 rounded text-xs font-bold flex items-center gap-1 shadow-lg"><Star size={10} fill="currentColor" /> {item.userMeta.ratings.overall}</div>}
                                                        {item.meta?.asian?.mdl?.rating && <div className="absolute bottom-2 right-2 bg-teal-600 text-white px-1.5 py-0.5 rounded text-[10px] font-bold shadow-lg">MDL {item.meta.asian.mdl.rating}</div>}
                                                    </div>
                                                    <div className="p-3 space-y-1">
                                                        <h3 className="font-bold text-sm line-clamp-1 dark:text-white">{item.Title}</h3>
                                                        <div className="text-[11px] text-gray-500 flex flex-wrap gap-x-2"><span>{item.Year}</span><span>•</span><span>{item.Type === "series" ? "TV Series" : "Movie"}</span></div>
                                                        {item.Type === "series" && <div className="text-[10px] text-indigo-400 pt-1 font-medium">{item.meta?.totalSeasons || '?'} seasons</div>}
                                                        <div className="flex flex-wrap gap-1 pt-1">{item.meta?.genre?.slice(0, 2).map(g => <span key={g} className="px-1.5 py-0.5 text-[9px] rounded bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300">{g}</span>)}</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </section>
                                )}
                            </>
                        )}

                        {viewMode === 'timeline' && (
                            <div className="max-w-2xl mx-auto space-y-6">
                                <h2 className="text-2xl font-black dark:text-white mb-6">Watch History</h2>
                                {timelineEvents.length === 0 && <div className="text-center text-gray-500 py-10">No history found. Mark items as watched!</div>}
                                {timelineEvents.map((ev, idx) => (
                                    <div key={`${ev.imdbID}-${idx}-${ev.watchedOn}`} className="flex gap-4 p-4 bg-white dark:bg-dark-card rounded-xl border border-gray-100 dark:border-gray-800 shadow-sm relative">
                                        <div className="w-16 h-24 shrink-0 rounded-lg overflow-hidden bg-gray-200"><img src={getHighResPoster(ev.poster, 200)} className="w-full h-full object-cover" loading="lazy" /></div>
                                        <div className="flex-1 min-w-0">
                                            <div className="flex justify-between items-start"><h3 className="font-bold dark:text-white text-base truncate">{ev.title}</h3><span className="text-xs text-gray-400 whitespace-nowrap">{new Date(ev.watchedOn).toLocaleDateString()}</span></div>
                                            <div className="flex items-center gap-2 mt-1"><span className={`text-[10px] uppercase font-bold px-2 py-0.5 rounded ${ev.type === 'movie' ? 'bg-blue-100 text-blue-600' : 'bg-purple-100 text-purple-600'}`}>{ev.type}</span>{ev.rating > 0 && <span className="text-yellow-500 text-sm font-bold">★ {ev.rating}</span>}</div>
                                        </div>
                                        {idx !== timelineEvents.length - 1 && <div className="absolute left-8 top-28 bottom-[-24px] w-0.5 bg-gray-200 dark:bg-gray-800 -z-10"></div>}
                                    </div>
                                ))}
                            </div>
                        )}

                        {viewMode === 'analytics' && (
                            <div className="space-y-10">
                                <div>
                                    <h2 className="text-2xl font-black dark:text-white mb-6 flex items-center gap-2"><User size={24}/> Top Directors & Actors</h2>
                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    {peopleStats.map((p, idx) => (
                                        <div key={`${p.name}-${idx}`} className="p-4 rounded-xl bg-white dark:bg-dark-card border border-gray-100 dark:border-gray-800 shadow-sm">
                                            <div className="font-bold dark:text-white truncate">{p.name}</div>
                                            <div className="text-xs text-gray-500 uppercase font-bold tracking-wider mb-2">{p.type}</div>
                                            <div className="flex justify-between items-end"><span className="text-2xl font-black text-indigo-600">{p.count}</span>{p.avgRating > 0 && <span className="text-sm font-bold text-yellow-500">★ {p.avgRating.toFixed(1)}</span>}</div>
                                        </div>
                                    ))}
                                    </div>
                                </div>
                                <div>
                                    <h2 className="text-2xl font-black dark:text-white mb-6">Library Composition</h2>
                                    <div className="h-4 bg-gray-200 dark:bg-gray-800 rounded-full overflow-hidden flex"><div className="bg-blue-500 h-full" style={{width: `${(allItems.filter(i=>i.Type==='movie').length / allItems.length * 100) || 0}%`}}></div><div className="bg-purple-500 h-full" style={{width: `${(allItems.filter(i=>i.Type==='series').length / allItems.length * 100) || 0}%`}}></div></div>
                                    <div className="flex justify-between text-xs text-gray-500 mt-2"><span className="flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-blue-500"></div> Movies ({allItems.filter(i=>i.Type==='movie').length})</span><span className="flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-purple-500"></div> TV Shows ({allItems.filter(i=>i.Type==='series').length})</span></div>
                                </div>
                            </div>
                        )}
                    </main>

                     {/* REPLACED DETAIL MODAL */}
                     <DetailModal 
                        item={selectedMovie} 
                        onClose={() => setSelectedMovie(null)} 
                        onUpdateStatus={(status) => updateItem(selectedMovie.imdbID, i => ({...i, userMeta: {...i.userMeta, status}}))}
                     />

                     {/* PREVIEW MODAL */}
                     {previewItem && (
                        <SearchPreviewModal 
                            item={previewItem} 
                            onClose={() => setPreviewItem(null)} 
                            onAdd={addToVault}
                            onSuggest={handleOpenSuggestModal}
                            isAdmin={isAdmin}
                        />
                     )}
                     
                     {/* LOADING OVERLAY FOR PREVIEW */}
                     {previewLoading && (
                         <div className="fixed inset-0 z-[150] flex items-center justify-center bg-black/50 backdrop-blur-sm">
                             <div className="bg-white dark:bg-dark-card p-4 rounded-xl shadow-2xl flex items-center gap-3">
                                 <RefreshCw className="animate-spin text-indigo-600"/>
                                 <span className="font-bold text-sm dark:text-white">Fetching Details...</span>
                             </div>
                         </div>
                     )}

                    {actorModalData && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md animate-fade-in">
                            <div className="bg-white dark:bg-dark-card w-full max-w-2xl h-[80vh] rounded-2xl relative flex flex-col overflow-hidden">
                                <button onClick={() => setActorModalData(null)} className="absolute top-4 right-4 p-2 bg-black/20 rounded-full text-white hover:bg-black/40 z-10"><X/></button>
                                <div className="p-6 border-b border-gray-100 dark:border-gray-800 flex items-center gap-4 shrink-0 bg-white dark:bg-dark-card z-0 relative">
                                    <div className="w-16 h-16 rounded-full overflow-hidden bg-gray-200 shrink-0">{actorModalData.photo ? <img src={actorModalData.photo} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-xl font-bold text-gray-400">{actorModalData.name.charAt(0)}</div>}</div>
                                    <div><h2 className="text-2xl font-black dark:text-white">{actorModalData.name}</h2><p className="text-sm text-gray-500">Filmography</p></div>
                                </div>
                                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                                    <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                                        {actorModalData.credits.map((credit, cIdx) => (
                                            <div key={`${credit.id}-${cIdx}`} className="group relative">
                                                <div className="aspect-[2/3] bg-gray-800 rounded-lg overflow-hidden mb-2 relative">
                                                    <img src={tmdbImg(credit.poster_path, "w342")} className="w-full h-full object-cover group-hover:opacity-75 transition-opacity" loading="lazy"/>
                                                    <button onClick={(e) => { e.stopPropagation(); handleSearch(credit.title || credit.name); setActorModalData(null); }} className="absolute bottom-2 right-2 bg-indigo-600 text-white p-1.5 rounded-full opacity-0 group-hover:opacity-100 transition-opacity shadow-lg" title="Find in Vault"><Search size={12}/></button>
                                                </div>
                                                <h4 className="text-xs font-bold dark:text-white line-clamp-1">{credit.title || credit.name}</h4>
                                                <p className="text-[10px] text-gray-500">{credit.character}</p>
                                                <p className="text-[10px] text-gray-600">{(credit.release_date || credit.first_air_date || "").substring(0,4)}</p>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {suggestModalItem && <SuggestModal item={suggestModalItem} onClose={() => setSuggestModalItem(null)} onSubmit={handleSubmitSuggestion} />}
                    <AdminSuggestionsModal isOpen={showAdminSuggestions} onClose={() => setShowAdminSuggestions(false)} suggestions={adminSuggestions} onApprove={handleApprove} onReject={handleReject} />

                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} apiKeys={apiKeys} setApiKeys={setApiKeys} theme={theme} setTheme={setTheme} 
                        onImport={handleImport}
                        onExport={handleExport}
                        onReset={async () => {
                          if (session) { await supabaseClient.from("vault_items").delete().eq("user_id", session.user.id); }
                          setVault({ watched: {}, watchlist: {} });
                          localStorage.removeItem("vault_v6_data");
                        }}
                    />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>